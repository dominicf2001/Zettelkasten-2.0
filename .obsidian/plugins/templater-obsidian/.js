/
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var __toBinary = / @__PURE__ / (() => {
  var table = new UintArray();
  for (var i = ; i < ; i++)
    table[i <  ? i +  : i <  ? i +  : i <  ? i -  : i   - ] = i;
  return (base) => {
    var n = base.length, bytes = new UintArray((n - (base[n - ] == "=") - (base[n - ] == "="))   /  | );
    for (var i = , j = ; i < n; ) {
      var c = table[base.charCodeAt(i++)], c = table[base.charCodeAt(i++)];
      var c = table[base.charCodeAt(i++)], c = table[base.charCodeAt(i++)];
      bytes[j++] = c <<  | c >> ;
      bytes[j++] = c <<  | c >> ;
      bytes[j++] = c <<  | c;
    }
    return bytes;
  };
})();

// src/main.ts
__export(exports, {
  default: () => TemplaterPlugin
});
var import_obsidian = __toModule(require("obsidian"));

// src/settings/Settings.ts
var import_obsidian = __toModule(require("obsidian"));

// src/utils/Log.ts
var import_obsidian = __toModule(require("obsidian"));
function log_error(e) {
  const notice = new import_obsidian.Notice("", e);
  if (e instanceof TemplaterError && e.console_msg) {
    notice.noticeEl.innerHTML = `<b>Templater Error</b>:<br/>${e.message}<br/>Check console for more information`;
    console.error(`Templater Error:`, e.message, "\n", e.console_msg);
  } else {
    notice.noticeEl.innerHTML = `<b>Templater Error</b>:<br/>${e.message}`;
  }
}

// src/utils/Error.ts
var TemplaterError = class extends Error {
  constructor(msg, console_msg) {
    super(msg);
    this.console_msg = console_msg;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
};
async function errorWrapper(fn, msg) {
  try {
    return await fn();
  } catch (e) {
    if (!(e instanceof TemplaterError)) {
      log_error(new TemplaterError(msg, e.message));
    } else {
      log_error(e);
    }
    return null;
  }
}
function errorWrapperSync(fn, msg) {
  try {
    return fn();
  } catch (e) {
    log_error(new TemplaterError(msg, e.message));
    return null;
  }
}

// src/settings/suggesters/FolderSuggester.ts
var import_obsidian = __toModule(require("obsidian"));

// src/settings/suggesters/suggest.ts
var import_obsidian = __toModule(require("obsidian"));

// node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = / @__PURE__ / basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = / @__PURE__ / [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}

// node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name) {
      var value = attributes[name];
      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref) {
  var state = _ref.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "",
      top: "",
      margin: ""
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style, property) {
        style[property] = "";
        return style;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[];
}

// node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)safari/i.test(getUAString());
}

// node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void ) {
    includeScale = false;
  }
  if (isFixedStrategy === void ) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = ;
  var scaleY = ;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth >  ? round(clientRect.width) / element.offsetWidth ||  : ;
    scaleY = element.offsetHeight >  ? round(clientRect.height) / element.offsetHeight ||  : ;
  }
  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : )) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : )) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= ) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= ) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}

// node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}

// node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}

// node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= ;
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element) {
  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
}

// node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
}

// node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < ) {
    var css = getComputedStyle(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== - || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
    return window;
  }
  return offsetParent || getContainingBlock(element) || window;
}

// node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >=  ? "x" : "y";
}

// node_modules/@popperjs/core/lib/utils/within.js
function within(min, value, max) {
  return max(min, min(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

// node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: ,
    right: ,
    bottom: ,
    left: 
  };
}

// node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= ;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight ||  : arrowOffsetParent.clientWidth ||  : ;
  var centerToReference = endDiff /  - startDiff / ;
  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize /  - arrowRect[len] /  + centerToReference;
  var offset = within(min, center, max);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}
function effect(_ref) {
  var state = _ref.state, options = _ref.options;
  var _options$element = options.element, arrowElement = _options$element === void  ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[];
}

// node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || ;
  return {
    x: round(x  dpr) / dpr || ,
    y: round(y  dpr) / dpr || 
  };
}
function mapToStyles(_ref) {
  var _Object$assign;
  var popper = _ref.popper, popperRect = _ref.popperRect, placement = _ref.placement, variation = _ref.variation, offsets = _ref.offsets, position = _ref.position, gpuAcceleration = _ref.gpuAcceleration, adaptive = _ref.adaptive, roundOffsets = _ref.roundOffsets, isFixed = _ref.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void  ?  : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void  ?  : _offsets$y;
  var _ref = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref.x;
  y = _ref.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper)) {
      offsetParent = getDocumentElement(popper);
      if (getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y = gpuAcceleration ?  : -;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x = gpuAcceleration ?  : -;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref.x;
  y = _ref.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "" : "", _Object$assign[sideX] = hasX ? "" : "", _Object$assign.transform = (win.devicePixelRatio || ) <=  ? "translate(" + x + "px, " + y + "px)" : "translated(" + x + "px, " + y + "px, )", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? y + "px" : "", _Object$assign[sideX] = hasX ? x + "px" : "", _Object$assign.transform = "", _Object$assign));
}
function computeStyles(_ref) {
  var state = _ref.state, options = _ref.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void  ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void  ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void  ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= ;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void  ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void  ? true : _options$resize;
  var window = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window.removeEventListener("resize", instance.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}

// node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = ;
  var y = ;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void  : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : , body ? body.clientWidth : );
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : , body ? body.clientHeight : );
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : ) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "document"].indexOf(getNodeName(node)) >= ) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void ) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void  : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= ;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[];
  var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference.x + reference.width /  - element.width / ;
  var commonY = reference.y + reference.height /  - element.height / ;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] /  - element[len] / );
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] /  - element[len] / );
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void ) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void  ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void  ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void  ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void  ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void  ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void  ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void  ?  : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >=  ?  : -;
      var axis = [top, bottom].indexOf(key) >=  ? "y" : "x";
      overflowOffsets[key] += offset[axis]  multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void ) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void  ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement) {
    return getVariation(placement) === variation;
  }) : basePlacements;
  var allowedPlacements = placements.filter(function(placement) {
    return allowedAutoPlacements.indexOf(placement) >= ;
  });
  if (allowedPlacements.length === ) {
    allowedPlacements = placements;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement) {
    acc[placement] = detectOverflow(state, {
      placement: placement,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void  ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void  ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void  ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement) {
    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
      placement: placement,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[];
  for (var i = ; i < placements.length; i++) {
    var placement = placements[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= ;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= );
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= , overflow[altVariationSide] <= );
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ?  : ;
    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function(placement) {
        var checks = checksMap.get(placement);
        if (checks) {
          return checks.slice(, _i).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > ; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void ) {
    preventedOffsets = {
      x: ,
      y: 
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= ;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >=  ? - : ;
  var _ref = typeof offset === "function" ? offset(Object.assign({}, rects, {
    placement
  })) : offset, skidding = _ref[], distance = _ref[];
  skidding = skidding || ;
  distance = (distance || )  invertDistance;
  return [left, right].indexOf(basePlacement) >=  ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$offset = options.offset, offset = _options$offset === void  ? [, ] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void  ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void  ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void  ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void  ?  : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: ,
    altAxis: 
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: ,
    y: 
  };
  if (!popperOffsets) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] /  : ;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: ,
      height: 
    };
    var arrowPaddingObject = state.modifiersData["arrowpersistent"] ? state.modifiersData["arrowpersistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] /  - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] /  + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop ||  : arrowOffsetParent.clientLeft ||  : ;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void  : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : ;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min, tetherMin) : min, offset, tether ? max(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }
  if (checkAltAxis) {
    var _offsetModifierState$;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -;
    var _offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void  : offsetModifierState[altAxis]) != null ? _offsetModifierState$ : ;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

// node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || ;
  var scaleY = round(rect.height) / element.offsetHeight || ;
  return scaleX !==  || scaleY !== ;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void ) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: ,
    scrollTop: 
  };
  var offsets = {
    x: ,
    y: 
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void ;
          resolve(fn());
        });
      });
    }
    return pending;
  };
}

// node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len >  ? _len -  : ), _key = ; _key < _len; _key++) {
    args[_key - ] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < ) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function(item) {
    var identifier = fn(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = ; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void ) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void  ? [] : _generatorOptions$def, _generatorOptions$def = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def === void  ? DEFAULT_OPTIONS : _generatorOptions$def;
  return function createPopper(reference, popper, options) {
    if (options === void ) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
          popper: listScrollParents(popper)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref) {
              var name = _ref.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle(popper), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper;
        if (!areValidElements(reference, popper)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = ;
        for (var index = ; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += ;
            if (__debug_loops__ > ) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie = _state$orderedModifie.options, _options = _state$orderedModifie === void  ? {} : _state$orderedModifie, name = _state$orderedModifie.name;
          if (typeof fn === "function") {
            state = fn({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference, popper)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance;
    }
    instance.setOptions(options).then(function(state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options = _ref$options === void  ? {} : _ref$options, effect = _ref.effect;
        if (typeof effect === "function") {
          var cleanupFn = effect({
            state,
            name,
            instance,
            options: options
          });
          var noopFn = function noopFn() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn) {
        return fn();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}

// node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = / @__PURE__ / popperGenerator({
  defaultModifiers
});

// src/settings/suggesters/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on("click", ".suggestion-item", this.onSuggestionClick.bind(this));
    containerEl.on("mousemove", ".suggestion-item", this.onSuggestionMouseover.bind(this));
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - , true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + , true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(selectedIndex, this.suggestions.length);
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion?.removeClass("is-selected");
    selectedSuggestion?.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(inputEl) {
    this.inputEl = inputEl;
    this.scope = new import_obsidian.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on("mousedown", ".suggestion-container", (event) => {
      event.preventDefault();
    });
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > ) {
      this.suggest.setSuggestions(suggestions);
      this.open(app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/settings/suggesters/FolderSuggester.ts
var FolderSuggest = class extends TextInputSuggest {
  getSuggestions(inputStr) {
    const abstractFiles = app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings/suggesters/FileSuggester.ts
var import_obsidian = __toModule(require("obsidian"));

// src/utils/Utils.ts
var import_obsidian = __toModule(require("obsidian"));
function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
function escape_RegExp(str) {
  return str.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
}
function generate_dynamic_command_regex() {
  return /(<%(?:-|_)?\s[~]{,})\+((?:.|\s)?%>)/g;
}
function resolve_tfolder(folder_str) {
  folder_str = (, import_obsidian.normalizePath)(folder_str);
  const folder = app.vault.getAbstractFileByPath(folder_str);
  if (!folder) {
    throw new TemplaterError(`Folder "${folder_str}" doesn't exist`);
  }
  if (!(folder instanceof import_obsidian.TFolder)) {
    throw new TemplaterError(`${folder_str} is a file, not a folder`);
  }
  return folder;
}
function resolve_tfile(file_str) {
  file_str = (, import_obsidian.normalizePath)(file_str);
  const file = app.vault.getAbstractFileByPath(file_str);
  if (!file) {
    throw new TemplaterError(`File "${file_str}" doesn't exist`);
  }
  if (!(file instanceof import_obsidian.TFile)) {
    throw new TemplaterError(`${file_str} is a folder, not a file`);
  }
  return file;
}
function get_tfiles_from_folder(folder_str) {
  const folder = resolve_tfolder(folder_str);
  const files = [];
  import_obsidian.Vault.recurseChildren(folder, (file) => {
    if (file instanceof import_obsidian.TFile) {
      files.push(file);
    }
  });
  files.sort((a, b) => {
    return a.basename.localeCompare(b.basename);
  });
  return files;
}
function arraymove(arr, fromIndex, toIndex) {
  if (toIndex <  || toIndex === arr.length) {
    return;
  }
  const element = arr[fromIndex];
  arr[fromIndex] = arr[toIndex];
  arr[toIndex] = element;
}

// src/settings/suggesters/FileSuggester.ts
var FileSuggestMode;
(function(FileSuggestMode) {
  FileSuggestMode[FileSuggestMode["TemplateFiles"] = ] = "TemplateFiles";
  FileSuggestMode[FileSuggestMode["ScriptFiles"] = ] = "ScriptFiles";
})(FileSuggestMode || (FileSuggestMode = {}));
var FileSuggest = class extends TextInputSuggest {
  constructor(inputEl, plugin, mode) {
    super(inputEl);
    this.inputEl = inputEl;
    this.plugin = plugin;
    this.mode = mode;
  }
  get_folder(mode) {
    switch (mode) {
      case :
        return this.plugin.settings.templates_folder;
      case :
        return this.plugin.settings.user_scripts_folder;
    }
  }
  get_error_msg(mode) {
    switch (mode) {
      case :
        return `Templates folder doesn't exist`;
      case :
        return `User Scripts folder doesn't exist`;
    }
  }
  getSuggestions(input_str) {
    const all_files = errorWrapperSync(() => get_tfiles_from_folder(this.get_folder(this.mode)), this.get_error_msg(this.mode));
    if (!all_files) {
      return [];
    }
    const files = [];
    const lower_input_str = input_str.toLowerCase();
    all_files.forEach((file) => {
      if (file instanceof import_obsidian.TFile && file.extension === "md" && file.path.toLowerCase().contains(lower_input_str)) {
        files.push(file);
      }
    });
    return files;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings/Settings.ts
var DEFAULT_SETTINGS = {
  command_timeout: ,
  templates_folder: "",
  templates_pairs: [["", ""]],
  trigger_on_file_creation: false,
  auto_jump_to_cursor: false,
  enable_system_commands: false,
  shell_path: "",
  user_scripts_folder: "",
  enable_folder_templates: true,
  folder_templates: [{ folder: "", template: "" }],
  syntax_highlighting: true,
  enabled_templates_hotkeys: [""],
  startup_templates: [""],
  enable_ribbon_icon: true
};
var TemplaterSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    this.add_general_setting_header();
    this.add_template_folder_setting();
    this.add_internal_functions_setting();
    this.add_syntax_highlighting_setting();
    this.add_auto_jump_to_cursor();
    this.add_trigger_on_new_file_creation_setting();
    this.add_ribbon_icon_setting();
    this.add_templates_hotkeys_setting();
    if (this.plugin.settings.trigger_on_file_creation) {
      this.add_folder_templates_setting();
    }
    this.add_startup_templates_setting();
    this.add_user_script_functions_setting();
    this.add_user_system_command_functions_setting();
    this.add_donating_setting();
  }
  add_general_setting_header() {
    this.containerEl.createEl("h", { text: "General Settings" });
  }
  add_template_folder_setting() {
    new import_obsidian.Setting(this.containerEl).setName("Template folder location").setDesc("Files in this folder will be available as templates.").addSearch((cb) => {
      new FolderSuggest(cb.inputEl);
      cb.setPlaceholder("Example: folder/folder").setValue(this.plugin.settings.templates_folder).onChange((new_folder) => {
        this.plugin.settings.templates_folder = new_folder;
        this.plugin.save_settings();
      });
      cb.containerEl.addClass("templater_search");
    });
  }
  add_internal_functions_setting() {
    const desc = document.createDocumentFragment();
    desc.append("Templater provides multiples predefined variables / functions that you can use.", desc.createEl("br"), "Check the ", desc.createEl("a", {
      href: "https://silentvoid.github.io/Templater/",
      text: "documentation"
    }), " to get a list of all the available internal variables / functions.");
    new import_obsidian.Setting(this.containerEl).setName("Internal Variables and Functions").setDesc(desc);
  }
  add_syntax_highlighting_setting() {
    const desc = document.createDocumentFragment();
    desc.append("Adds syntax highlighting for Templater commands in edit mode.");
    new import_obsidian.Setting(this.containerEl).setName("Syntax Highlighting").setDesc(desc).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.syntax_highlighting).onChange((syntax_highlighting) => {
        this.plugin.settings.syntax_highlighting = syntax_highlighting;
        this.plugin.save_settings();
        this.plugin.event_handler.update_syntax_highlighting();
      });
    });
  }
  add_auto_jump_to_cursor() {
    const desc = document.createDocumentFragment();
    desc.append("Automatically triggers ", desc.createEl("code", { text: "tp.file.cursor" }), " after inserting a template.", desc.createEl("br"), "You can also set a hotkey to manually trigger ", desc.createEl("code", { text: "tp.file.cursor" }), ".");
    new import_obsidian.Setting(this.containerEl).setName("Automatic jump to cursor").setDesc(desc).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.auto_jump_to_cursor).onChange((auto_jump_to_cursor) => {
        this.plugin.settings.auto_jump_to_cursor = auto_jump_to_cursor;
        this.plugin.save_settings();
      });
    });
  }
  add_trigger_on_new_file_creation_setting() {
    const desc = document.createDocumentFragment();
    desc.append("Templater will listen for the new file creation event, and replace every command it finds in the new file's content.", desc.createEl("br"), "This makes Templater compatible with other plugins like the Daily note core plugin, Calendar plugin, Review plugin, Note refactor plugin, ...", desc.createEl("br"), desc.createEl("b", {
      text: "Warning: "
    }), "This can be dangerous if you create new files with unknown / unsafe content on creation. Make sure that every new file's content is safe on creation.");
    new import_obsidian.Setting(this.containerEl).setName("Trigger Templater on new file creation").setDesc(desc).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.trigger_on_file_creation).onChange((trigger_on_file_creation) => {
        this.plugin.settings.trigger_on_file_creation = trigger_on_file_creation;
        this.plugin.save_settings();
        this.plugin.event_handler.update_trigger_file_on_creation();
        this.display();
      });
    });
  }
  add_ribbon_icon_setting() {
    const desc = document.createDocumentFragment();
    desc.append("Show Templater icon in sidebar ribbon, allowing you to quickly use templates anywhere.");
    new import_obsidian.Setting(this.containerEl).setName("Show icon in sidebar").setDesc(desc).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enable_ribbon_icon).onChange((enable_ribbon_icon) => {
        this.plugin.settings.enable_ribbon_icon = enable_ribbon_icon;
        this.plugin.save_settings();
        if (this.plugin.settings.enable_ribbon_icon) {
          this.plugin.addRibbonIcon("templater-icon", "Templater", async () => {
            this.plugin.fuzzy_suggester.insert_template();
          }).setAttribute("id", "rb-templater-icon");
        } else {
          document.getElementById("rb-templater-icon")?.remove();
        }
      });
    });
  }
  add_templates_hotkeys_setting() {
    this.containerEl.createEl("h", { text: "Template Hotkeys" });
    const desc = document.createDocumentFragment();
    desc.append("Template Hotkeys allows you to bind a template to a hotkey.");
    new import_obsidian.Setting(this.containerEl).setDesc(desc);
    this.plugin.settings.enabled_templates_hotkeys.forEach((template, index) => {
      const s = new import_obsidian.Setting(this.containerEl).addSearch((cb) => {
        new FileSuggest(cb.inputEl, this.plugin, FileSuggestMode.TemplateFiles);
        cb.setPlaceholder("Example: folder/template_file").setValue(template).onChange((new_template) => {
          if (new_template && this.plugin.settings.enabled_templates_hotkeys.contains(new_template)) {
            log_error(new TemplaterError("This template is already bound to a hotkey"));
            return;
          }
          this.plugin.command_handler.add_template_hotkey(this.plugin.settings.enabled_templates_hotkeys[index], new_template);
          this.plugin.settings.enabled_templates_hotkeys[index] = new_template;
          this.plugin.save_settings();
        });
        cb.containerEl.addClass("templater_search");
      }).addExtraButton((cb) => {
        cb.setIcon("any-key").setTooltip("Configure Hotkey").onClick(() => {
          app.setting.openTabById("hotkeys");
          const tab = app.setting.activeTab;
          tab.searchInputEl.value = "Templater: Insert";
          tab.updateHotkeyVisibility();
        });
      }).addExtraButton((cb) => {
        cb.setIcon("up-chevron-glyph").setTooltip("Move up").onClick(() => {
          arraymove(this.plugin.settings.enabled_templates_hotkeys, index, index - );
          this.plugin.save_settings();
          this.display();
        });
      }).addExtraButton((cb) => {
        cb.setIcon("down-chevron-glyph").setTooltip("Move down").onClick(() => {
          arraymove(this.plugin.settings.enabled_templates_hotkeys, index, index + );
          this.plugin.save_settings();
          this.display();
        });
      }).addExtraButton((cb) => {
        cb.setIcon("cross").setTooltip("Delete").onClick(() => {
          this.plugin.command_handler.remove_template_hotkey(this.plugin.settings.enabled_templates_hotkeys[index]);
          this.plugin.settings.enabled_templates_hotkeys.splice(index, );
          this.plugin.save_settings();
          this.display();
        });
      });
      s.infoEl.remove();
    });
    new import_obsidian.Setting(this.containerEl).addButton((cb) => {
      cb.setButtonText("Add new hotkey for template").setCta().onClick(() => {
        this.plugin.settings.enabled_templates_hotkeys.push("");
        this.plugin.save_settings();
        this.display();
      });
    });
  }
  add_folder_templates_setting() {
    this.containerEl.createEl("h", { text: "Folder Templates" });
    const descHeading = document.createDocumentFragment();
    descHeading.append("Folder Templates are triggered when a new ", descHeading.createEl("strong", { text: "empty " }), "file is created in a given folder.", descHeading.createEl("br"), "Templater will fill the empty file with the specified template.", descHeading.createEl("br"), "The deepest match is used. A global default template would be defined on the root ", descHeading.createEl("code", { text: "/" }), ".");
    new import_obsidian.Setting(this.containerEl).setDesc(descHeading);
    const descUseNewFileTemplate = document.createDocumentFragment();
    descUseNewFileTemplate.append("When enabled Templater will make use of the folder templates defined below.");
    new import_obsidian.Setting(this.containerEl).setName("Enable Folder Templates").setDesc(descUseNewFileTemplate).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enable_folder_templates).onChange((use_new_file_templates) => {
        this.plugin.settings.enable_folder_templates = use_new_file_templates;
        this.plugin.save_settings();
        this.display();
      });
    });
    if (!this.plugin.settings.enable_folder_templates) {
      return;
    }
    new import_obsidian.Setting(this.containerEl).setName("Add New").setDesc("Add new folder template").addButton((button) => {
      button.setTooltip("Add additional folder template").setButtonText("+").setCta().onClick(() => {
        this.plugin.settings.folder_templates.push({
          folder: "",
          template: ""
        });
        this.plugin.save_settings();
        this.display();
      });
    });
    this.plugin.settings.folder_templates.forEach((folder_template, index) => {
      const s = new import_obsidian.Setting(this.containerEl).addSearch((cb) => {
        new FolderSuggest(cb.inputEl);
        cb.setPlaceholder("Folder").setValue(folder_template.folder).onChange((new_folder) => {
          if (new_folder && this.plugin.settings.folder_templates.some((e) => e.folder == new_folder)) {
            log_error(new TemplaterError("This folder already has a template associated with it"));
            return;
          }
          this.plugin.settings.folder_templates[index].folder = new_folder;
          this.plugin.save_settings();
        });
        cb.containerEl.addClass("templater_search");
      }).addSearch((cb) => {
        new FileSuggest(cb.inputEl, this.plugin, FileSuggestMode.TemplateFiles);
        cb.setPlaceholder("Template").setValue(folder_template.template).onChange((new_template) => {
          this.plugin.settings.folder_templates[index].template = new_template;
          this.plugin.save_settings();
        });
        cb.containerEl.addClass("templater_search");
      }).addExtraButton((cb) => {
        cb.setIcon("up-chevron-glyph").setTooltip("Move up").onClick(() => {
          arraymove(this.plugin.settings.folder_templates, index, index - );
          this.plugin.save_settings();
          this.display();
        });
      }).addExtraButton((cb) => {
        cb.setIcon("down-chevron-glyph").setTooltip("Move down").onClick(() => {
          arraymove(this.plugin.settings.folder_templates, index, index + );
          this.plugin.save_settings();
          this.display();
        });
      }).addExtraButton((cb) => {
        cb.setIcon("cross").setTooltip("Delete").onClick(() => {
          this.plugin.settings.folder_templates.splice(index, );
          this.plugin.save_settings();
          this.display();
        });
      });
      s.infoEl.remove();
    });
  }
  add_startup_templates_setting() {
    this.containerEl.createEl("h", { text: "Startup Templates" });
    const desc = document.createDocumentFragment();
    desc.append("Startup Templates are templates that will get executed once when Templater starts.", desc.createEl("br"), "These templates won't output anything.", desc.createEl("br"), "This can be useful to set up templates adding hooks to obsidian events for example.");
    new import_obsidian.Setting(this.containerEl).setDesc(desc);
    this.plugin.settings.startup_templates.forEach((template, index) => {
      const s = new import_obsidian.Setting(this.containerEl).addSearch((cb) => {
        new FileSuggest(cb.inputEl, this.plugin, FileSuggestMode.TemplateFiles);
        cb.setPlaceholder("Example: folder/template_file").setValue(template).onChange((new_template) => {
          if (new_template && this.plugin.settings.startup_templates.contains(new_template)) {
            log_error(new TemplaterError("This startup template already exist"));
            return;
          }
          this.plugin.settings.startup_templates[index] = new_template;
          this.plugin.save_settings();
        });
        cb.containerEl.addClass("templater_search");
      }).addExtraButton((cb) => {
        cb.setIcon("cross").setTooltip("Delete").onClick(() => {
          this.plugin.settings.startup_templates.splice(index, );
          this.plugin.save_settings();
          this.display();
        });
      });
      s.infoEl.remove();
    });
    new import_obsidian.Setting(this.containerEl).addButton((cb) => {
      cb.setButtonText("Add new startup template").setCta().onClick(() => {
        this.plugin.settings.startup_templates.push("");
        this.plugin.save_settings();
        this.display();
      });
    });
  }
  add_user_script_functions_setting() {
    this.containerEl.createEl("h", { text: "User Script Functions" });
    let desc = document.createDocumentFragment();
    desc.append("All JavaScript files in this folder will be loaded as CommonJS modules, to import custom user functions.", desc.createEl("br"), "The folder needs to be accessible from the vault.", desc.createEl("br"), "Check the ", desc.createEl("a", {
      href: "https://silentvoid.github.io/Templater/",
      text: "documentation"
    }), " for more information.");
    new import_obsidian.Setting(this.containerEl).setName("Script files folder location").setDesc(desc).addSearch((cb) => {
      new FolderSuggest(cb.inputEl);
      cb.setPlaceholder("Example: folder/folder").setValue(this.plugin.settings.user_scripts_folder).onChange((new_folder) => {
        this.plugin.settings.user_scripts_folder = new_folder;
        this.plugin.save_settings();
      });
      cb.containerEl.addClass("templater_search");
    });
    desc = document.createDocumentFragment();
    let name;
    if (!this.plugin.settings.user_scripts_folder) {
      name = "No User Scripts folder set";
    } else {
      const files = errorWrapperSync(() => get_tfiles_from_folder(this.plugin.settings.user_scripts_folder), `User Scripts folder doesn't exist`);
      if (!files || files.length === ) {
        name = "No User Scripts detected";
      } else {
        let count = ;
        for (const file of files) {
          if (file.extension === "js") {
            count++;
            desc.append(desc.createEl("li", {
              text: `tp.user.${file.basename}`
            }));
          }
        }
        name = `Detected ${count} User Script(s)`;
      }
    }
    new import_obsidian.Setting(this.containerEl).setName(name).setDesc(desc).addExtraButton((extra) => {
      extra.setIcon("sync").setTooltip("Refresh").onClick(() => {
        this.display();
      });
    });
  }
  add_user_system_command_functions_setting() {
    let desc = document.createDocumentFragment();
    desc.append("Allows you to create user functions linked to system commands.", desc.createEl("br"), desc.createEl("b", {
      text: "Warning: "
    }), "It can be dangerous to execute arbitrary system commands from untrusted sources. Only run system commands that you understand, from trusted sources.");
    this.containerEl.createEl("h", {
      text: "User System Command Functions"
    });
    new import_obsidian.Setting(this.containerEl).setName("Enable User System Command Functions").setDesc(desc).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enable_system_commands).onChange((enable_system_commands) => {
        this.plugin.settings.enable_system_commands = enable_system_commands;
        this.plugin.save_settings();
        this.display();
      });
    });
    if (this.plugin.settings.enable_system_commands) {
      new import_obsidian.Setting(this.containerEl).setName("Timeout").setDesc("Maximum timeout in seconds for a system command.").addText((text) => {
        text.setPlaceholder("Timeout").setValue(this.plugin.settings.command_timeout.toString()).onChange((new_value) => {
          const new_timeout = Number(new_value);
          if (isNaN(new_timeout)) {
            log_error(new TemplaterError("Timeout must be a number"));
            return;
          }
          this.plugin.settings.command_timeout = new_timeout;
          this.plugin.save_settings();
        });
      });
      desc = document.createDocumentFragment();
      desc.append("Full path to the shell binary to execute the command with.", desc.createEl("br"), "This setting is optional and will default to the system's default shell if not specified.", desc.createEl("br"), "You can use forward slashes ('/') as path separators on all platforms if in doubt.");
      new import_obsidian.Setting(this.containerEl).setName("Shell binary location").setDesc(desc).addText((text) => {
        text.setPlaceholder("Example: /bin/bash, ...").setValue(this.plugin.settings.shell_path).onChange((shell_path) => {
          this.plugin.settings.shell_path = shell_path;
          this.plugin.save_settings();
        });
      });
      let i = ;
      this.plugin.settings.templates_pairs.forEach((template_pair) => {
        const div = this.containerEl.createEl("div");
        div.addClass("templater_div");
        const title = this.containerEl.createEl("h", {
          text: "User Function n\xB" + i
        });
        title.addClass("templater_title");
        const setting = new import_obsidian.Setting(this.containerEl).addExtraButton((extra) => {
          extra.setIcon("cross").setTooltip("Delete").onClick(() => {
            const index = this.plugin.settings.templates_pairs.indexOf(template_pair);
            if (index > -) {
              this.plugin.settings.templates_pairs.splice(index, );
              this.plugin.save_settings();
              this.display();
            }
          });
        }).addText((text) => {
          const t = text.setPlaceholder("Function name").setValue(template_pair[]).onChange((new_value) => {
            const index = this.plugin.settings.templates_pairs.indexOf(template_pair);
            if (index > -) {
              this.plugin.settings.templates_pairs[index][] = new_value;
              this.plugin.save_settings();
            }
          });
          t.inputEl.addClass("templater_template");
          return t;
        }).addTextArea((text) => {
          const t = text.setPlaceholder("System Command").setValue(template_pair[]).onChange((new_cmd) => {
            const index = this.plugin.settings.templates_pairs.indexOf(template_pair);
            if (index > -) {
              this.plugin.settings.templates_pairs[index][] = new_cmd;
              this.plugin.save_settings();
            }
          });
          t.inputEl.setAttr("rows", );
          t.inputEl.addClass("templater_cmd");
          return t;
        });
        setting.infoEl.remove();
        div.appendChild(title);
        div.appendChild(this.containerEl.lastChild);
        i += ;
      });
      const div = this.containerEl.createEl("div");
      div.addClass("templater_div");
      const setting = new import_obsidian.Setting(this.containerEl).addButton((button) => {
        button.setButtonText("Add New User Function").setCta().onClick(() => {
          this.plugin.settings.templates_pairs.push(["", ""]);
          this.plugin.save_settings();
          this.display();
        });
      });
      setting.infoEl.remove();
      div.appendChild(this.containerEl.lastChild);
    }
  }
  add_donating_setting() {
    const s = new import_obsidian.Setting(this.containerEl).setName("Donate").setDesc("If you like this Plugin, consider donating to support continued development.");
    const a = document.createElement("a");
    a.setAttribute("href", "https://github.com/sponsors/silentvoid");
    a.addClass("templater_donating");
    const img = document.createElement("img");
    img.src = "https://img.shields.io/static/v?label=Sponsor&message=%E%D%A&logo=GitHub&color=%fee";
    a.appendChild(img);
    const a = document.createElement("a");
    a.setAttribute("href", "https://www.paypal.com/donate?hosted_button_id=USRGAFYXTQ");
    a.addClass("templater_donating");
    const img = document.createElement("img");
    img.src = "https://img.shields.io/badge/paypal-silentvoid-yellow?style=social&logo=paypal";
    a.appendChild(img);
    s.settingEl.appendChild(a);
    s.settingEl.appendChild(a);
  }
};

// src/handlers/FuzzySuggester.ts
var import_obsidian = __toModule(require("obsidian"));
var OpenMode;
(function(OpenMode) {
  OpenMode[OpenMode["InsertTemplate"] = ] = "InsertTemplate";
  OpenMode[OpenMode["CreateNoteTemplate"] = ] = "CreateNoteTemplate";
})(OpenMode || (OpenMode = {}));
var FuzzySuggester = class extends import_obsidian.FuzzySuggestModal {
  constructor(plugin) {
    super(app);
    this.plugin = plugin;
    this.setPlaceholder("Type name of a template...");
  }
  getItems() {
    if (!this.plugin.settings.templates_folder) {
      return app.vault.getMarkdownFiles();
    }
    const files = errorWrapperSync(() => get_tfiles_from_folder(this.plugin.settings.templates_folder), `Couldn't retrieve template files from templates folder ${this.plugin.settings.templates_folder}`);
    if (!files) {
      return [];
    }
    return files;
  }
  getItemText(item) {
    return item.basename;
  }
  onChooseItem(item) {
    switch (this.open_mode) {
      case :
        this.plugin.templater.append_template_to_active_file(item);
        break;
      case :
        this.plugin.templater.create_new_note_from_template(item, this.creation_folder);
        break;
    }
  }
  start() {
    try {
      this.open();
    } catch (e) {
      log_error(e);
    }
  }
  insert_template() {
    this.open_mode = ;
    this.start();
  }
  create_new_note_from_template(folder) {
    this.creation_folder = folder;
    this.open_mode = ;
    this.start();
  }
};

// src/utils/Constants.ts
var UNSUPPORTED_MOBILE_TEMPLATE = "Error_MobileUnsupportedTemplate";
var ICON_DATA = `<svg xmlns="http://www.w.org//svg" viewBox="  . ."><path d="M .  . . . . . . . . . . . . .  .ZM. .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C.. .  . C.  .. . .M.. . . . . .. ..M. .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .M. .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .M. .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .C. . . . . .Z" fill="currentColor"/></svg>`;

// src/core/Templater.ts
var import_obsidian = __toModule(require("obsidian"));

// src/core/functions/internal_functions/InternalModule.ts
var InternalModule = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.static_functions = new Map();
    this.dynamic_functions = new Map();
  }
  getName() {
    return this.name;
  }
  async init() {
    await this.create_static_templates();
    this.static_object = Object.fromEntries(this.static_functions);
  }
  async generate_object(new_config) {
    this.config = new_config;
    await this.create_dynamic_templates();
    return {
      ...this.static_object,
      ...Object.fromEntries(this.dynamic_functions)
    };
  }
};

// src/core/functions/internal_functions/date/InternalModuleDate.ts
var InternalModuleDate = class extends InternalModule {
  constructor() {
    super(...arguments);
    this.name = "date";
  }
  async create_static_templates() {
    this.static_functions.set("now", this.generate_now());
    this.static_functions.set("tomorrow", this.generate_tomorrow());
    this.static_functions.set("weekday", this.generate_weekday());
    this.static_functions.set("yesterday", this.generate_yesterday());
  }
  async create_dynamic_templates() {
  }
  generate_now() {
    return (format = "YYYY-MM-DD", offset, reference, reference_format) => {
      if (reference && !window.moment(reference, reference_format).isValid()) {
        throw new TemplaterError("Invalid reference date format, try specifying one with the argument 'reference_format'");
      }
      let duration;
      if (typeof offset === "string") {
        duration = window.moment.duration(offset);
      } else if (typeof offset === "number") {
        duration = window.moment.duration(offset, "days");
      }
      return window.moment(reference, reference_format).add(duration).format(format);
    };
  }
  generate_tomorrow() {
    return (format = "YYYY-MM-DD") => {
      return window.moment().add(, "days").format(format);
    };
  }
  generate_weekday() {
    return (format = "YYYY-MM-DD", weekday, reference, reference_format) => {
      if (reference && !window.moment(reference, reference_format).isValid()) {
        throw new TemplaterError("Invalid reference date format, try specifying one with the argument 'reference_format'");
      }
      return window.moment(reference, reference_format).weekday(weekday).format(format);
    };
  }
  generate_yesterday() {
    return (format = "YYYY-MM-DD") => {
      return window.moment().add(-, "days").format(format);
    };
  }
};

// src/core/functions/internal_functions/file/InternalModuleFile.ts
var import_obsidian = __toModule(require("obsidian"));
var DEPTH_LIMIT = ;
var InternalModuleFile = class extends InternalModule {
  constructor() {
    super(...arguments);
    this.name = "file";
    this.include_depth = ;
    this.create_new_depth = ;
    this.linkpath_regex = new RegExp("^\\[\\[(.)\\]\\]$");
  }
  async create_static_templates() {
    this.static_functions.set("creation_date", this.generate_creation_date());
    this.static_functions.set("create_new", this.generate_create_new());
    this.static_functions.set("cursor", this.generate_cursor());
    this.static_functions.set("cursor_append", this.generate_cursor_append());
    this.static_functions.set("exists", this.generate_exists());
    this.static_functions.set("find_tfile", this.generate_find_tfile());
    this.static_functions.set("folder", this.generate_folder());
    this.static_functions.set("include", this.generate_include());
    this.static_functions.set("last_modified_date", this.generate_last_modified_date());
    this.static_functions.set("move", this.generate_move());
    this.static_functions.set("path", this.generate_path());
    this.static_functions.set("rename", this.generate_rename());
    this.static_functions.set("selection", this.generate_selection());
  }
  async create_dynamic_templates() {
    this.dynamic_functions.set("content", await this.generate_content());
    this.dynamic_functions.set("tags", this.generate_tags());
    this.dynamic_functions.set("title", this.generate_title());
  }
  async generate_content() {
    return await app.vault.read(this.config.target_file);
  }
  generate_create_new() {
    return async (template, filename, open_new = false, folder) => {
      this.create_new_depth += ;
      if (this.create_new_depth > DEPTH_LIMIT) {
        this.create_new_depth = ;
        throw new TemplaterError("Reached create_new depth limit (max = )");
      }
      const new_file = await this.plugin.templater.create_new_note_from_template(template, folder, filename, open_new);
      this.create_new_depth -= ;
      return new_file;
    };
  }
  generate_creation_date() {
    return (format = "YYYY-MM-DD HH:mm") => {
      return window.moment(this.config.target_file.stat.ctime).format(format);
    };
  }
  generate_cursor() {
    return (order) => {
      return `<% tp.file.cursor(${order ?? ""}) %>`;
    };
  }
  generate_cursor_append() {
    return (content) => {
      const active_view = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (active_view === null) {
        log_error(new TemplaterError("No active view, can't append to cursor."));
        return;
      }
      const editor = active_view.editor;
      const doc = editor.getDoc();
      doc.replaceSelection(content);
      return "";
    };
  }
  generate_exists() {
    return async (filename) => {
      const path = (, import_obsidian.normalizePath)(filename);
      return await app.vault.exists(path);
    };
  }
  generate_find_tfile() {
    return (filename) => {
      const path = (, import_obsidian.normalizePath)(filename);
      return app.metadataCache.getFirstLinkpathDest(path, "");
    };
  }
  generate_folder() {
    return (relative = false) => {
      const parent = this.config.target_file.parent;
      let folder;
      if (relative) {
        folder = parent.path;
      } else {
        folder = parent.name;
      }
      return folder;
    };
  }
  generate_include() {
    return async (include_link) => {
      this.include_depth += ;
      if (this.include_depth > DEPTH_LIMIT) {
        this.include_depth -= ;
        throw new TemplaterError("Reached inclusion depth limit (max = )");
      }
      let inc_file_content;
      if (include_link instanceof import_obsidian.TFile) {
        inc_file_content = await app.vault.read(include_link);
      } else {
        let match;
        if ((match = this.linkpath_regex.exec(include_link)) === null) {
          this.include_depth -= ;
          throw new TemplaterError("Invalid file format, provide an obsidian link between quotes.");
        }
        const { path, subpath } = (, import_obsidian.parseLinktext)(match[]);
        const inc_file = app.metadataCache.getFirstLinkpathDest(path, "");
        if (!inc_file) {
          this.include_depth -= ;
          throw new TemplaterError(`File ${include_link} doesn't exist`);
        }
        inc_file_content = await app.vault.read(inc_file);
        if (subpath) {
          const cache = app.metadataCache.getFileCache(inc_file);
          if (cache) {
            const result = (, import_obsidian.resolveSubpath)(cache, subpath);
            if (result) {
              inc_file_content = inc_file_content.slice(result.start.offset, result.end?.offset);
            }
          }
        }
      }
      try {
        const parsed_content = await this.plugin.templater.parser.parse_commands(inc_file_content, this.plugin.templater.current_functions_object);
        this.include_depth -= ;
        return parsed_content;
      } catch (e) {
        this.include_depth -= ;
        throw e;
      }
    };
  }
  generate_last_modified_date() {
    return (format = "YYYY-MM-DD HH:mm") => {
      return window.moment(this.config.target_file.stat.mtime).format(format);
    };
  }
  generate_move() {
    return async (path, file_to_move) => {
      const file = file_to_move || this.config.target_file;
      const new_path = (, import_obsidian.normalizePath)(`${path}.${file.extension}`);
      const dirs = new_path.replace(/\\/g, "/").split("/");
      dirs.pop();
      if (dirs.length) {
        const dir = dirs.join("/");
        if (!window.app.vault.getAbstractFileByPath(dir)) {
          await window.app.vault.createFolder(dir);
        }
      }
      await app.fileManager.renameFile(file, new_path);
      return "";
    };
  }
  generate_path() {
    return (relative = false) => {
      let vault_path = "";
      if (import_obsidian.Platform.isMobileApp) {
        const vault_adapter = app.vault.adapter.fs.uri;
        const vault_base = app.vault.adapter.basePath;
        vault_path = `${vault_adapter}/${vault_base}`;
      } else {
        if (app.vault.adapter instanceof import_obsidian.FileSystemAdapter) {
          vault_path = app.vault.adapter.getBasePath();
        } else {
          throw new TemplaterError("app.vault is not a FileSystemAdapter instance");
        }
      }
      if (relative) {
        return this.config.target_file.path;
      } else {
        return `${vault_path}/${this.config.target_file.path}`;
      }
    };
  }
  generate_rename() {
    return async (new_title) => {
      if (new_title.match(/[\\/:]+/g)) {
        throw new TemplaterError("File name cannot contain any of these characters: \\ / :");
      }
      const new_path = (, import_obsidian.normalizePath)(`${this.config.target_file.parent.path}/${new_title}.${this.config.target_file.extension}`);
      await app.fileManager.renameFile(this.config.target_file, new_path);
      return "";
    };
  }
  generate_selection() {
    return () => {
      const active_view = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (active_view == null) {
        throw new TemplaterError("Active view is null, can't read selection.");
      }
      const editor = active_view.editor;
      return editor.getSelection();
    };
  }
  generate_tags() {
    const cache = app.metadataCache.getFileCache(this.config.target_file);
    if (cache) {
      return (, import_obsidian.getAllTags)(cache);
    }
    return null;
  }
  generate_title() {
    return this.config.target_file.basename;
  }
};

// src/core/functions/internal_functions/web/InternalModuleWeb.ts
var InternalModuleWeb = class extends InternalModule {
  constructor() {
    super(...arguments);
    this.name = "web";
  }
  async create_static_templates() {
    this.static_functions.set("daily_quote", this.generate_daily_quote());
    this.static_functions.set("random_picture", this.generate_random_picture());
  }
  async create_dynamic_templates() {
  }
  async getRequest(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new TemplaterError("Error performing GET request");
      }
      return response;
    } catch (error) {
      throw new TemplaterError("Error performing GET request");
    }
  }
  generate_daily_quote() {
    return async () => {
      try {
        const response = await this.getRequest("https://api.quotable.io/random");
        const json = await response.json();
        const author = json.author;
        const quote = json.content;
        const new_content = `> ${quote}
> \u <cite>${author}</cite>`;
        return new_content;
      } catch (error) {
        new TemplaterError("Error generating daily quote");
        return "Error generating daily quote";
      }
    };
  }
  generate_random_picture() {
    return async (size, query, include_size = false) => {
      try {
        const response = await this.getRequest(`https://templater-unsplash.fly.dev/${query ? "?q=" + query : ""}`).then((res) => res.json());
        let url = response.full;
        if (size && !include_size) {
          if (size.includes("x")) {
            const [width, height] = size.split("x");
            url = url.concat(`&w=${width}&h=${height}`);
          } else {
            url = url.concat(`&w=${size}`);
          }
        }
        if (include_size) {
          return `![photo by ${response.photog} on Unsplash|${size}](${url})`;
        }
        return `![photo by ${response.photog} on Unsplash](${url})`;
      } catch (error) {
        new TemplaterError("Error generating random picture");
        return "Error generating random picture";
      }
    };
  }
};

// src/core/functions/internal_functions/frontmatter/InternalModuleFrontmatter.ts
var InternalModuleFrontmatter = class extends InternalModule {
  constructor() {
    super(...arguments);
    this.name = "frontmatter";
  }
  async create_static_templates() {
  }
  async create_dynamic_templates() {
    const cache = app.metadataCache.getFileCache(this.config.target_file);
    this.dynamic_functions = new Map(Object.entries(cache?.frontmatter || {}));
  }
};

// src/core/functions/internal_functions/system/InternalModuleSystem.ts
var import_obsidian = __toModule(require("obsidian"));

// src/core/functions/internal_functions/system/PromptModal.ts
var import_obsidian = __toModule(require("obsidian"));
var PromptModal = class extends import_obsidian.Modal {
  constructor(prompt_text, default_value, multi_line) {
    super(app);
    this.prompt_text = prompt_text;
    this.default_value = default_value;
    this.multi_line = multi_line;
    this.submitted = false;
  }
  onOpen() {
    this.titleEl.setText(this.prompt_text);
    this.createForm();
  }
  onClose() {
    this.contentEl.empty();
    if (!this.submitted) {
      this.reject();
    }
  }
  createForm() {
    const div = this.contentEl.createDiv();
    div.addClass("templater-prompt-div");
    let textInput;
    if (this.multi_line) {
      textInput = new import_obsidian.TextAreaComponent(div);
      const buttonDiv = this.contentEl.createDiv();
      buttonDiv.addClass("templater-button-div");
      const submitButton = new import_obsidian.ButtonComponent(buttonDiv);
      submitButton.buttonEl.addClass("mod-cta");
      submitButton.setButtonText("Submit").onClick((evt) => {
        this.resolveAndClose(evt);
      });
    } else {
      textInput = new import_obsidian.TextComponent(div);
    }
    this.value = this.default_value ?? "";
    textInput.inputEl.addClass("templater-prompt-input");
    textInput.setPlaceholder("Type text here");
    textInput.setValue(this.value);
    textInput.onChange((value) => this.value = value);
    textInput.inputEl.addEventListener("keydown", (evt) => this.enterCallback(evt));
  }
  enterCallback(evt) {
    if (this.multi_line) {
      if (import_obsidian.Platform.isDesktop) {
        if (evt.shiftKey && evt.key === "Enter") {
        } else if (evt.key === "Enter") {
          this.resolveAndClose(evt);
        }
      } else {
        if (evt.key === "Enter") {
          evt.preventDefault();
        }
      }
    } else {
      if (evt.key === "Enter") {
        this.resolveAndClose(evt);
      }
    }
  }
  resolveAndClose(evt) {
    this.submitted = true;
    evt.preventDefault();
    this.resolve(this.value);
    this.close();
  }
  async openAndGetValue(resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
    this.open();
  }
};

// src/core/functions/internal_functions/system/SuggesterModal.ts
var import_obsidian = __toModule(require("obsidian"));
var SuggesterModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(text_items, items, placeholder, limit) {
    super(app);
    this.text_items = text_items;
    this.items = items;
    this.submitted = false;
    this.setPlaceholder(placeholder);
    limit && (this.limit = limit);
  }
  getItems() {
    return this.items;
  }
  onClose() {
    if (!this.submitted) {
      this.reject(new TemplaterError("Cancelled prompt"));
    }
  }
  selectSuggestion(value, evt) {
    this.submitted = true;
    this.close();
    this.onChooseSuggestion(value, evt);
  }
  getItemText(item) {
    if (this.text_items instanceof Function) {
      return this.text_items(item);
    }
    return this.text_items[this.items.indexOf(item)] || "Undefined Text Item";
  }
  onChooseItem(item) {
    this.resolve(item);
  }
  async openAndGetValue(resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
    this.open();
  }
};

// src/core/functions/internal_functions/system/InternalModuleSystem.ts
var InternalModuleSystem = class extends InternalModule {
  constructor() {
    super(...arguments);
    this.name = "system";
  }
  async create_static_templates() {
    this.static_functions.set("clipboard", this.generate_clipboard());
    this.static_functions.set("prompt", this.generate_prompt());
    this.static_functions.set("suggester", this.generate_suggester());
  }
  async create_dynamic_templates() {
  }
  generate_clipboard() {
    return async () => {
      if (import_obsidian.Platform.isMobileApp) {
        return UNSUPPORTED_MOBILE_TEMPLATE;
      }
      return await navigator.clipboard.readText();
    };
  }
  generate_prompt() {
    return async (prompt_text, default_value, throw_on_cancel = false, multi_line = false) => {
      const prompt = new PromptModal(prompt_text, default_value, multi_line);
      const promise = new Promise((resolve, reject) => prompt.openAndGetValue(resolve, reject));
      try {
        return await promise;
      } catch (error) {
        if (throw_on_cancel) {
          throw error;
        }
        return null;
      }
    };
  }
  generate_suggester() {
    return async (text_items, items, throw_on_cancel = false, placeholder = "", limit) => {
      const suggester = new SuggesterModal(text_items, items, placeholder, limit);
      const promise = new Promise((resolve, reject) => suggester.openAndGetValue(resolve, reject));
      try {
        return await promise;
      } catch (error) {
        if (throw_on_cancel) {
          throw error;
        }
        return null;
      }
    };
  }
};

// src/core/functions/internal_functions/config/InternalModuleConfig.ts
var InternalModuleConfig = class extends InternalModule {
  constructor() {
    super(...arguments);
    this.name = "config";
  }
  async create_static_templates() {
  }
  async create_dynamic_templates() {
  }
  async generate_object(config) {
    return config;
  }
};

// src/core/functions/internal_functions/InternalFunctions.ts
var InternalFunctions = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.modules_array = [];
    this.modules_array.push(new InternalModuleDate(this.plugin));
    this.modules_array.push(new InternalModuleFile(this.plugin));
    this.modules_array.push(new InternalModuleWeb(this.plugin));
    this.modules_array.push(new InternalModuleFrontmatter(this.plugin));
    this.modules_array.push(new InternalModuleSystem(this.plugin));
    this.modules_array.push(new InternalModuleConfig(this.plugin));
  }
  async init() {
    for (const mod of this.modules_array) {
      await mod.init();
    }
  }
  async generate_object(config) {
    const internal_functions_object = {};
    for (const mod of this.modules_array) {
      internal_functions_object[mod.getName()] = await mod.generate_object(config);
    }
    return internal_functions_object;
  }
};

// src/core/functions/user_functions/UserSystemFunctions.ts
var import_child_process = __toModule(require("child_process"));
var import_util = __toModule(require("util"));
var import_obsidian = __toModule(require("obsidian"));
var UserSystemFunctions = class {
  constructor(plugin) {
    this.plugin = plugin;
    if (import_obsidian.Platform.isMobileApp || !(app.vault.adapter instanceof import_obsidian.FileSystemAdapter)) {
      this.cwd = "";
    } else {
      this.cwd = app.vault.adapter.getBasePath();
      this.exec_promise = (, import_util.promisify)(import_child_process.exec);
    }
  }
  async generate_system_functions(config) {
    const user_system_functions = new Map();
    const internal_functions_object = await this.plugin.templater.functions_generator.generate_object(config, FunctionsMode.INTERNAL);
    for (const template_pair of this.plugin.settings.templates_pairs) {
      const template = template_pair[];
      let cmd = template_pair[];
      if (!template || !cmd) {
        continue;
      }
      if (import_obsidian.Platform.isMobileApp) {
        user_system_functions.set(template, () => {
          return new Promise((resolve) => resolve(UNSUPPORTED_MOBILE_TEMPLATE));
        });
      } else {
        cmd = await this.plugin.templater.parser.parse_commands(cmd, internal_functions_object);
        user_system_functions.set(template, async (user_args) => {
          const process_env = {
            ...process.env,
            ...user_args
          };
          const cmd_options = {
            timeout: this.plugin.settings.command_timeout  e,
            cwd: this.cwd,
            env: process_env,
            ...this.plugin.settings.shell_path && {
              shell: this.plugin.settings.shell_path
            }
          };
          try {
            const { stdout } = await this.exec_promise(cmd, cmd_options);
            return stdout.trimRight();
          } catch (error) {
            throw new TemplaterError(`Error with User Template ${template}`, error);
          }
        });
      }
    }
    return user_system_functions;
  }
  async generate_object(config) {
    const user_system_functions = await this.generate_system_functions(config);
    return Object.fromEntries(user_system_functions);
  }
};

// src/core/functions/user_functions/UserScriptFunctions.ts
var UserScriptFunctions = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async generate_user_script_functions() {
    const user_script_functions = new Map();
    const files = errorWrapperSync(() => get_tfiles_from_folder(this.plugin.settings.user_scripts_folder), `Couldn't find user script folder "${this.plugin.settings.user_scripts_folder}"`);
    if (!files) {
      return new Map();
    }
    for (const file of files) {
      if (file.extension.toLowerCase() === "js") {
        await this.load_user_script_function(file, user_script_functions);
      }
    }
    return user_script_functions;
  }
  async load_user_script_function(file, user_script_functions) {
    const req = (s) => {
      return window.require && window.require(s);
    };
    const exp = {};
    const mod = {
      exports: exp
    };
    const file_content = await app.vault.read(file);
    const wrapping_fn = window.eval("(function anonymous(require, module, exports){" + file_content + "\n})");
    wrapping_fn(req, mod, exp);
    const user_function = exp["default"] || mod.exports;
    if (!user_function) {
      throw new TemplaterError(`Failed to load user script ${file.path}. No exports detected.`);
    }
    if (!(user_function instanceof Function)) {
      throw new TemplaterError(`Failed to load user script ${file.path}. Default export is not a function.`);
    }
    user_script_functions.set(`${file.basename}`, user_function);
  }
  async generate_object() {
    const user_script_functions = await this.generate_user_script_functions();
    return Object.fromEntries(user_script_functions);
  }
};

// src/core/functions/user_functions/UserFunctions.ts
var UserFunctions = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.user_system_functions = new UserSystemFunctions(plugin);
    this.user_script_functions = new UserScriptFunctions(plugin);
  }
  async generate_object(config) {
    let user_system_functions = {};
    let user_script_functions = {};
    if (this.plugin.settings.enable_system_commands) {
      user_system_functions = await this.user_system_functions.generate_object(config);
    }
    if (this.plugin.settings.user_scripts_folder) {
      user_script_functions = await this.user_script_functions.generate_object();
    }
    return {
      ...user_system_functions,
      ...user_script_functions
    };
  }
};

// src/core/functions/FunctionsGenerator.ts
var obsidian_module = __toModule(require("obsidian"));
var FunctionsMode;
(function(FunctionsMode) {
  FunctionsMode[FunctionsMode["INTERNAL"] = ] = "INTERNAL";
  FunctionsMode[FunctionsMode["USER_INTERNAL"] = ] = "USER_INTERNAL";
})(FunctionsMode || (FunctionsMode = {}));
var FunctionsGenerator = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.internal_functions = new InternalFunctions(this.plugin);
    this.user_functions = new UserFunctions(this.plugin);
  }
  async init() {
    await this.internal_functions.init();
  }
  additional_functions() {
    return {
      obsidian: obsidian_module
    };
  }
  async generate_object(config, functions_mode = ) {
    const final_object = {};
    const additional_functions_object = this.additional_functions();
    const internal_functions_object = await this.internal_functions.generate_object(config);
    let user_functions_object = {};
    Object.assign(final_object, additional_functions_object);
    switch (functions_mode) {
      case :
        Object.assign(final_object, internal_functions_object);
        break;
      case :
        user_functions_object = await this.user_functions.generate_object(config);
        Object.assign(final_object, {
          ...internal_functions_object,
          user: user_functions_object
        });
        break;
    }
    return final_object;
  }
};

// node_modules/@silentvoid/rusty_engine/rusty_engine.js
var import_meta = {};
var wasm;
var heap = new Array().fill(void );
heap.push(void , null, true, false);
function getObject(idx) {
  return heap[idx];
}
var heap_next = heap.length;
function dropObject(idx) {
  if (idx < )
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var cachedTextDecoder = new TextDecoder("utf-", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
var cachedUintMemory = new UintArray();
function getUintMemory() {
  if (cachedUintMemory.byteLength === ) {
    cachedUintMemory = new UintArray(wasm.memory.buffer);
  }
  return cachedUintMemory;
}
function getStringFromWasm(ptr, len) {
  return cachedTextDecoder.decode(getUintMemory().subarray(ptr, ptr + len));
}
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + );
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
var WASM_VECTOR_LEN = ;
var cachedTextEncoder = new TextEncoder("utf-");
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm(arg, malloc, realloc) {
  if (realloc === void ) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr = malloc(buf.length);
    getUintMemory().subarray(ptr, ptr + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr;
  }
  let len = arg.length;
  let ptr = malloc(len);
  const mem = getUintMemory();
  let offset = ;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > )
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== ) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length  );
    const view = getUintMemory().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function isLikeNone(x) {
  return x === void  || x === null;
}
var cachedIntMemory = new IntArray();
function getIntMemory() {
  if (cachedIntMemory.byteLength === ) {
    cachedIntMemory = new IntArray(wasm.memory.buffer);
  }
  return cachedIntMemory;
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > ) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > ) {
      debug += debugString(val[]);
    }
    for (let i = ; i < length; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > ) {
    className = builtInMatches[];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
function _assertClass(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
  return instance.ptr;
}
var stack_pointer = ;
function addBorrowedObject(obj) {
  if (stack_pointer == )
    throw new Error("out of js stack");
  heap[--stack_pointer] = obj;
  return stack_pointer;
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm.__wbindgen_exn_store(addHeapObject(e));
  }
}
var ParserConfig = class {
  static __wrap(ptr) {
    const obj = Object.create(ParserConfig.prototype);
    obj.ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = ;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_parserconfig_free(ptr);
  }
  get interpolate() {
    const ret = wasm.__wbg_get_parserconfig_interpolate(this.ptr);
    return String.fromCodePoint(ret);
  }
  set interpolate(arg) {
    wasm.__wbg_set_parserconfig_interpolate(this.ptr, arg.codePointAt());
  }
  get execution() {
    const ret = wasm.__wbg_get_parserconfig_execution(this.ptr);
    return String.fromCodePoint(ret);
  }
  set execution(arg) {
    wasm.__wbg_set_parserconfig_execution(this.ptr, arg.codePointAt());
  }
  get single_whitespace() {
    const ret = wasm.__wbg_get_parserconfig_single_whitespace(this.ptr);
    return String.fromCodePoint(ret);
  }
  set single_whitespace(arg) {
    wasm.__wbg_set_parserconfig_single_whitespace(this.ptr, arg.codePointAt());
  }
  get multiple_whitespace() {
    const ret = wasm.__wbg_get_parserconfig_multiple_whitespace(this.ptr);
    return String.fromCodePoint(ret);
  }
  set multiple_whitespace(arg) {
    wasm.__wbg_set_parserconfig_multiple_whitespace(this.ptr, arg.codePointAt());
  }
  constructor(opt, clt, inte, ex, sw, mw, gv) {
    const ptr = passStringToWasm(opt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len = WASM_VECTOR_LEN;
    const ptr = passStringToWasm(clt, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len = WASM_VECTOR_LEN;
    const ptr = passStringToWasm(gv, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len = WASM_VECTOR_LEN;
    const ret = wasm.parserconfig_new(ptr, len, ptr, len, inte.codePointAt(), ex.codePointAt(), sw.codePointAt(), mw.codePointAt(), ptr, len);
    return ParserConfig.__wrap(ret);
  }
  get opening_tag() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-);
      wasm.parserconfig_opening_tag(retptr, this.ptr);
      var r = getIntMemory()[retptr /  + ];
      var r = getIntMemory()[retptr /  + ];
      return getStringFromWasm(r, r);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer();
      wasm.__wbindgen_free(r, r);
    }
  }
  set opening_tag(val) {
    const ptr = passStringToWasm(val, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len = WASM_VECTOR_LEN;
    wasm.parserconfig_set_opening_tag(this.ptr, ptr, len);
  }
  get closing_tag() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-);
      wasm.parserconfig_closing_tag(retptr, this.ptr);
      var r = getIntMemory()[retptr /  + ];
      var r = getIntMemory()[retptr /  + ];
      return getStringFromWasm(r, r);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer();
      wasm.__wbindgen_free(r, r);
    }
  }
  set closing_tag(val) {
    const ptr = passStringToWasm(val, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len = WASM_VECTOR_LEN;
    wasm.parserconfig_set_closing_tag(this.ptr, ptr, len);
  }
  get global_var() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-);
      wasm.parserconfig_global_var(retptr, this.ptr);
      var r = getIntMemory()[retptr /  + ];
      var r = getIntMemory()[retptr /  + ];
      return getStringFromWasm(r, r);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer();
      wasm.__wbindgen_free(r, r);
    }
  }
  set global_var(val) {
    const ptr = passStringToWasm(val, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len = WASM_VECTOR_LEN;
    wasm.parserconfig_set_global_var(this.ptr, ptr, len);
  }
};
var Renderer = class {
  static __wrap(ptr) {
    const obj = Object.create(Renderer.prototype);
    obj.ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.ptr;
    this.ptr = ;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_renderer_free(ptr);
  }
  constructor(config) {
    _assertClass(config, ParserConfig);
    var ptr = config.ptr;
    config.ptr = ;
    const ret = wasm.renderer_new(ptr);
    return Renderer.__wrap(ret);
  }
  render_content(content, context) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-);
      const ptr = passStringToWasm(content, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len = WASM_VECTOR_LEN;
      wasm.renderer_render_content(retptr, this.ptr, ptr, len, addBorrowedObject(context));
      var r = getIntMemory()[retptr /  + ];
      var r = getIntMemory()[retptr /  + ];
      var r = getIntMemory()[retptr /  + ];
      if (r) {
        throw takeObject(r);
      }
      return takeObject(r);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer();
      heap[stack_pointer++] = void ;
    }
  }
};
async function load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module: module };
    } else {
      return instance;
    }
  }
}
function getImports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_object_drop_ref = function(arg) {
    takeObject(arg);
  };
  imports.wbg.__wbindgen_string_new = function(arg, arg) {
    const ret = getStringFromWasm(arg, arg);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_string_get = function(arg, arg) {
    const obj = getObject(arg);
    const ret = typeof obj === "string" ? obj : void ;
    var ptr = isLikeNone(ret) ?  : passStringToWasm(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len = WASM_VECTOR_LEN;
    getIntMemory()[arg /  + ] = len;
    getIntMemory()[arg /  + ] = ptr;
  };
  imports.wbg.__wbg_call_aeddcb = function() {
    return handleError(function(arg, arg) {
      const ret = getObject(arg).call(getObject(arg));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_dafbceee = function(arg, arg) {
    const ret = new Error(getStringFromWasm(arg, arg));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_message_feafcccbc = function(arg) {
    const ret = getObject(arg).message;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithargs_feece = function(arg, arg, arg, arg) {
    const ret = new Function(getStringFromWasm(arg, arg), getStringFromWasm(arg, arg));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_call_daef = function() {
    return handleError(function(arg, arg, arg) {
      const ret = getObject(arg).call(getObject(arg), getObject(arg));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_beeef = function() {
    return handleError(function(arg, arg, arg, arg) {
      const ret = getObject(arg).call(getObject(arg), getObject(arg), getObject(arg));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_debug_string = function(arg, arg) {
    const ret = debugString(getObject(arg));
    const ptr = passStringToWasm(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len = WASM_VECTOR_LEN;
    getIntMemory()[arg /  + ] = len;
    getIntMemory()[arg /  + ] = ptr;
  };
  imports.wbg.__wbindgen_throw = function(arg, arg) {
    throw new Error(getStringFromWasm(arg, arg));
  };
  return imports;
}
function initMemory(imports, maybe_memory) {
}
function finalizeInit(instance, module) {
  wasm = instance.exports;
  init.__wbindgen_wasm_module = module;
  cachedIntMemory = new IntArray();
  cachedUintMemory = new UintArray();
  return wasm;
}
async function init(input) {
  if (typeof input === "undefined") {
    input = new URL("rusty_engine_bg.wasm", import_meta.url);
  }
  const imports = getImports();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  initMemory(imports);
  const { instance, module: module } = await load(await input, imports);
  return finalizeInit(instance, module);
}
var rusty_engine_default = init;

// wasm-embed:/home/runner/work/Templater/Templater/node_modules/@silentvoid/rusty_engine/rusty_engine_bg.wasm
var rusty_engine_bg_default = __toBinary("AGFzbQEAAAABvwEaYAJ/fwBgAn/AXgAXBfADf/AXgA/fwBgAXAYAV/f/fwBgBH/fAYAR/f/AXgAABgBX/f/AXgAXBfmAAAXgBn/f/fwBgB/f/fAYAV/f/fwBgBX/fX/AGAFffAYAR/fn/AGAFf/fAYAR/fX/AGAEfx/fwBgBn/f/fwF/YAd/f/f/AXgCn/f/f/fBfACfnBfwLkAgsDdJnGlfdJpbmRnZWfbJqZWNXRybBfcmVmAAUDdJnFVfdJpbmRnZWfcRyaWnXldwABAdiZxVfXdiaWkZVuXNcmluZnZXQAAANYmcbXYmdfYFsbFNFlOWQNjQZGMzODhiAAEDdJnGlfdJnXldZDJhZjAwYmMxZTMyOWVlAAEDdJnHlfdJnXlcNhZVfZmUyYWYMNjYzgODViYwACAdiZyJfXdiZuZXdaXRoYXJncZmUyMUzODQyODQwYzhlAAgDdJnGfdJnXNhbGxfMTYZGEODcOWUzNWYMQADAdiZxtfXdiZjYWxsXzMOTliZWUOWUZjcMTkACANYmcXXYmluZGdlblkZWJZzdHJpbmcAAANYmcQXYmluZGdlblaHJvdwAAAkBtwECBwAGAgYEBAcBBQMKCAAEBgYAAwcCAAEADgETAQQXAQICAQAAAwcZAQAFAQwABgACAgAAAgAEBAAGAQAAAAAEBwCAQUEBQYCDBgAAQAAAAQBAQEAAQABBAQEBgMDBwMJAwQIAAAABQkAAgEAAAAABwAAAgICAgAFBQMEFgoGEQQAAUHAwIBAgABBQEBCAACAQEBBQEAAgECAgACAQEBAgAJCQICAgIAAAAAAwMDAQECAgsLCwUEBQFwATsBQMBABEGCQF/AUGAgMAACwfcBRkGbWVtbJAgAXXYmdfcGFycVyYuZmlnXZyZWUAUSJfXdiZnZXRfcGFycVyYuZmlnXludGVycGsYXRlAHiXYmdfcVXBhcnNlcmNvbmZpZpbnRlcnBvbGFZQBIFfdJnXdldFwYXJzZXJjbmaWdfZXhlYVaWuAHgXYmdfcVXBhcnNlcmNvbmZpZleGVjdXRpbAeChfXdiZnZXRfcGFycVyYuZmlnXNpbmdsZVaGlZXNwYWNlAIABKFfdJnXNldFwYXJzZXJjbmaWdfcluZxlXdoaXRlcBhYUAeSpfXdiZnZXRfcGFycVyYuZmlnXbHRpcGxlXdoaXRlcBhYUAgQEqXYmdfcVXBhcnNlcmNvbmZpZtdWxaXBsZVaGlZXNwYWNlAHoQcGFycVyYuZmlnXldwBVGHBhcnNlcmNvbmZpZvcGVuaWnXRhZwBGHHBhcnNlcmNvbmZpZzZXRfbBlbmluZYWcAYxhwYXJzZXJjbmaWdfYxvcluZYWcARxxwYXJzZXJjbmaWdfcVXNsbNpbmdfdGFnAGQXcGFycVyYuZmlnXdsbJhbFYXIASBtwYXJzZXJjbmaWdfcVXdsbJhbFYXIAZRNfXdiZyZWkZXJlclmcmVlAEMcmVuZGVyZXJfbmVACAXcmVuZGVyZXJfcmVuZGVyXNvbnRlbnQAORFfXdiaWkZVuXhbGxvYwBElfdJpbmRnZWfcmVhbGxvYwCFARfXdiaWkZVuXFkZFbzdGFjawbludGVyAKsBDfdJpbmRnZWfZnJlZQCaARRfXdiaWkZVuXVblzdGyZQCfAQllAQBBAQsmAGdAaoBPzzBAZUBlgFOkgGOAWotYsEBwQFnKlBAXaIAUyJAYgBhwGQAYBiQGJAYwBigGLAZgBXEBaKABXoBvwG+AYQBOElwoQHBAWioAWCjAVclqQGcAcEBwAEKdYCtwGIAIPfwF+IwBBEGsiCyQAAkACQCAAQfUBTwRAQYCAfEEIQQgQlwFBFEEIEJcBakEQQQgQlwFqaFcUFaiICQQBBEEEIEJcBQQJayIBIAEgAksbIABNDQIgAEEEakEIEJcBIQRBrKAACgCAEUNAUEAIARrIQMCQAJAAnBACAEQYACSQAGkEfIARB////BsNABogBEEGIARBCHZnIgBrdkEBcSAAQQFaE+agsiBkECdEGsMAAaigCACIABEAgBCAGEJMBdCEHQQAhAQNAAkAgABCvASICIARJDQAgAiAEayICIANPDQAgACEBIAIiAwAQQAhAwwDCyAAQRRqKAIAIgIgBSACIAAgBEddkEEcWpBEGooAgAiAEcbIAUgAhshBSAHQQFIQcgAAACyAFBEAgBSEADAILIAENAgtBACEBQQEgBnQQmwFBrKAACgCAHEiAEUNAyAAEKQBaEECdEGsMAAaigCACIARQDCwNAIAAgASAAEKBIgEgBEgASAEayIFIANJcSICGyEBIAUgAyACGyEDIAAQkQEiAAACyABRQCCGscAAKAIAIgAgBEBACADIAAgBGtPGwBIAEiACAEELoBIQYgABAAkAgAEQQQgQlwFPBEAgACAEEKYBIAYgAxCUASADQYACTwRAIAYgAxADAILIANBAYiAUEDdEGwrsAAaiEFAnBqKAACgCACICQQEgAXQiAXEEQCAFKAIIDAELQaiuwAAgASACcjYCACAFCyEBIAUgBjYCCCABIAYAgwgBiAFNgIMIAYgATYCCAwBCyAAIAMgBGoQjQELIAAQvAEiAUNAQwCCEQIABBBGpBEEEIEJcBQXtqIABLGEIEJcBIQQCQAJAAkACfwJAAkBBqKAACgCACIBIARBAYiAHYiAkEDcUUEQCAEQbixwAAoAgBNDQcgAgBQayuwAAoAgAiAEUNByAAEKQBaEECdEGsMAAaigCACIBEKBIARrIQMgARCRASIABEADQCAAEKBIARrIgIgAyACIANJIgIbIQMgACABIAIbIQEgABCRASIADQALCyABIgAgBBCASEFIAAQNSADQRBBCBCXAUkNBSAAIAQQpgEgBSADEJQBQbixwAAoAgAiAUUNBCABQQNIgFBARBsKAAGohBHAscAAKAIAIQZBqKAACgCACICQQEgAXQiAXFFDQIgBygCCAwDCwJAIAJBfNBAXEgAGoiAEDdCIAQbiuwABqKAIAIgVBCGooAgAiAiAAQbCuwABqIgBHBEAgAiAANgIMIAAgAjYCCAwBCGorsAAIAFBfiADdEAgALIAUgAEDdBCNASAFELwBIQMMBwsCQEEBIABBHEiAHQQmwEgAiAAdHEQpAFoIgJBAQiAEGrsAAaigCACIDQQhqKAIAIgEgAEGwrsAAaiIARwRAIAEgADYCDCAAIAEAggMAQtBqKAAEGorsAAKAIAQXgAndxNgIACyADIAQQpgEgAyAEELoBIgUgAkEDdCAEayICEJQBQbixwAAoAgAiAARAIABBAYiAEEDdEGwrsAAaiEHQcCxwAAoAgAhBgJ/QaiuwAAoAgAiAUEBIABIgBxBEAgBygCCAwBCGorsAAIAAgAXIAgAgBwshACAHIAYAgggACAGNgIMIAYgBzYCDCAGIAAAggLQcCxwAAgBTYCAEGscAAIAIAgAgAxCASEDDAYLQaiuwAAgASACcjYCACAHCyEBIAcgBjYCCCABIAYAgwgBiAHNgIMIAYgATYCCAtBwLHAACAFNgIAQbixwAAgAzYCAAwBCyAAIAMgBGoQjQELIAAQvAEiAwBCwJAAkACQAJAAkACQAJAAkBBuLHAACgCACIAIARJBEBBvLHAACgCACIAIARLDQIgCEIQQgQlwEgBGpBFEEIEJcBakEQQQgQlwFqQYCABBCXARBxIAsoAgAiCABQQAhAwwJCHAscAAKAIAIQIgACAEayIBQRBBCBCXAUkEQEHAscAAQQAAgBBuLHAACgCACEAQbixwABBADYCACACIAAQjQEgAhCASEDDAkLIAIgBBCASEAQbixwAAgATYCAEHAscAAIAAAgAgACABEJQBIAIgBBCmASACELwBIQMMCAsgCygCCCEMQcixwAAgCygCBCIKQcixwAAoAgBqIgEAgBBzLHAAEHMscAAKAIAIgAgASAAIAFLGzYCAAJAAkBBxLHAACgCAARAQdCxwAAhAANAIAAQpwEgCEYNAiAAKAIIIgANAAsMAgtBLHAACgCACIARSAIIABJcgDDAcLIAAQsQENACAAELIBIAxHDQAgACIBKAIAIgVBxLHAACgCACICTQR/IAUgASgCBGogAksFQQALDQMLQeSxwABBLHAACgCACIAIAggCCAASxsAgAgCCAKaiEBQdCxwAAhAAJAAkADQCABIAAoAgBHBEAgACgCCCIADQEMAgsLIAAQsQENACAAELIBIAxGDQELQcSxwAAoAgAhCUHQscAAIQACQANAIAAoAgAgCUEQCAAEKcBIAlLDQILIAAoAggiAAACEAIQALIAkgABCnASIGQRRBCBCXASIPaFpaiIBELwBIgBBCBCXASAAayABaiIAIABBEEEIEJcBIAlqSRsiDRCASEOIAgDxCASEAQQhBCBCXASEDQRRBCBCXASEFQRBBCBCXASECQcSxwAAgCCAIELwBIgFBCBCXASABayIBELoBIgcAgBBvLHAACAKQQhqIAIgAyAFamogAWprIgMAgAgByADQQFyNgIEQQhBCBCXASEFQRRBCBCXASECQRBBCBCXASEBIAcgAxCASABIAIgBUEIapqNgIEQeCxwABBgICAATYCACANIAQpgFBLHAACkCACEQIABCGpBLHAACkCADcCACAOIBAAgBBLHAACAMNgIAQdSxwAAgCjYCAEHQscAAIAgAgBBLHAACAONgIAAAgAEEEELoBIQEgAEEHNgIEIAYgASIAQQRqSwACyAJIAGDQcgCSANIAlrIgAgCSAAELoBEIYBIABBgAJPBEAgCSAAEDQMCAsgAEEDdiIAQQNQbCuwABqIQICfGorsAAKAIAIgFBASAAdCIAcQRAIAIoAggMAQtBqKAACAAIAFyNgIAIAILIQAgAiAJNgIIIAAgCTYCDCAJIAIAgwgCSAANgIIDAcLIAAoAgAhAyAAIAgAgAgACAAKAIEIApqNgIEIAgQvAEiBUEIEJcBIQIgAxCASIBQQgQlwEhACAIIAIgBWtqIgYgBBCASEHIAYgBBCmASADIAAgAWtqIgAgBCAGamshBCAAQcSxwAAoAgBHBEBBwLHAACgCACAARgEIAAoAgRBAFBAUcNBQJAIAAQrwEiBUGAAkEQCAAEDUMAQsgAEEMaigCACICIABBCGooAgAiAUcEQCABIAIAgwgAiABNgIIDAELQaiuwABBqKAACgCAEF+IAVBAZcTYCAAsgBCAFaiEEIAAgBRCASEADAULQcSxwAAgBzYCAEGscAAQbyxwAAoAgAgBGoiADYCACAHIABBAXIAgQgBhCASEDDAcLQbyxwAAgACAEayIBNgIAQcSxwABBxLHAACgCACICIAQQugEiADYCACAAIAFBAXIAgQgAiAEEKYBIAIQvAEhAwwGCHkscAAIAgAgAMAwsgACAAKAIEIApqNgIEQcSxwAAoAgBBvLHAACgCACAKahBWDAMLQcCxwAAgBzYCAEGscAAQbixwAAoAgAgBGoiADYCACAHIAAQlAEgBhCASEDDAMLIAcgBCAAEIYBIARBgAJPBEAgByAEEDQgBhCASEDDAMLIARBAYiAEEDdEGwrsAAaiECAnBqKAACgCACIBQQEgAHQiAHEEQCACKAIIDAELQaiuwAAgACABcjYCACACCyEAIAIgBzYCCCAAIAcAgwgByACNgIMIAcgADYCCCAGELwBIQMMAgtBLHAAEH/HzYCAEHcscAAIAwAgBBLHAACAKNgIAQdCxwAAgCDYCAEGrsAAQbCuwAAAgBBxKAAEGrsAANgIAQbiuwABBsKAADYCAEHMrsAAQcCuwAAAgBBwKAAEGrsAANgIAQdSuwABByKAADYCAEHIrsAAQcCuwAAAgBBKAAEHQrsAANgIAQdCuwABByKAADYCAEHkrsAAQdiuwAAAgBBKAAEHQrsAANgIAQeyuwABBKAADYCAEHgrsAAQdiuwAAAgBBKAAEHorsAANgIAQeiuwABBKAADYCAEHrsAAQfCuwAAAgBBKAAEHorsAANgIAQfiuwABBKAADYCAEGErAAQfiuwAAAgBBgK/AAEHrsAANgIAQYyvwABBgK/AADYCAEGIrAAQYCvwAAAgBBlK/AAEGIrAANgIAQZCvwABBiK/AADYCAEGcrAAQZCvwAAAgBBmK/AAEGQrAANgIAQaSvwABBmK/AADYCAEGgrAAQZivwAAAgBBrK/AAEGgrAANgIAQaivwABBoK/AADYCAEGrAAQaivwAAAgBBsK/AAEGorAANgIAQbyvwABBsK/AADYCAEHErAAQbivwAAAgBBuK/AAEGwrAANgIAQcyvwABBwK/AADYCAEHArAAQbivwAAAgBBK/AAEHIrAANgIAQcivwABBwK/AADYCAEHcrAAQdCvwAAAgBBK/AAEHIrAANgIAQeSvwABBK/AADYCAEHYrAAQdCvwAAAgBBK/AAEHgrAANgIAQeCvwABBK/AADYCAEHrAAQeivwAAAgBBK/AAEHgrAANgIAQfyvwABBK/AADYCAEHwrAAQeivwAAAgBBhLDAAEHrAANgIAQfivwABBK/AADYCAEGMsMAAQYCwwAAAgBBgLDAAEHrAANgIAQZSwwABBiLDAADYCAEGIsMAAQYCwwAAAgBBnLDAAEGQsMAANgIAQZCwwABBiLDAADYCAEGksMAAQZiwwAAAgBBmLDAAEGQsMAANgIAQaywwABBoLDAADYCAEGgsMAAQZiwwAAAgBBtLDAAEGosMAANgIAQaiwwABBoLDAADYCAEGwsMAAQaiwwAAAgBBCEEIEJcBIQVBFEEIEJcBIQJBEEEIEJcBIQFBxLHAACAIIAgQvAEiAEEIEJcBIABrIgAQugEiAzYCAEGscAAIApBCGogASACIAVqaiAAamsiBTYCACADIAVBAXIAgRBCEEIEJcBIQJBFEEIEJcBIQFBEEEIEJcBIQAgAyAFELoBIAAgASACQQhramoAgRBLHAAEGAgIABNgIACEAIQNBvLHAACgCACIAIARNDQBBvLHAACAAIARrIgEAgBBxLHAAEHEscAAKAIAIgIgBBCASIANgIAIAAgAUEBcjYCBCACIAQQpgEgAhCASEDCyALQRBqJAAgAwvgDwINfwp+IwBBMGsiCSQAAkAgASgCDCIKIAJqIgIgCkkEQBBrIAkoAgwhAiAJKAIIIQQMAQsCQAJAAkACfwJAIAIgASgCACIIIAhBAWoiBEDdkEHbCAIQQhJGyILQQFSwRAIAIgCEBaiIEIAIgBEsbIgJBCEkNASACIAJB/////wFxRgRAQXgAkEDdEEHbkF/amdQQFqDAMLEGsgCSgCLCECIAkoAighBAwGCyABQQRqKAIAIQVBACECAACQAJAIARBAXFFBEAgAiAHTwBDAILIAJBBoiBCACSQAIAQiAiAHSQBCwJAAkAgBEITwRAIAUgBogBSkAADcAAAwBCyAFQQhqIAUgBxAaIAdFDQELIANBCGopAwAiGELtpHzlszct+QAhSIRIAMpAwAiFkLysDzbt/MAhXwiFIgiSEZIBFCDYkgFUiFIRiSEaIBZCeSVbsbzsAIUhFkEAIQIDQAJAIAUgAiIDaiIMLQAAQYABRwAIAUgAEDdGtBeGohDyAFIANBfNBARqIQcCQANAIAggGCAPNQIAQoCAgICAgICABIQiEYVCrRyeMbLAIUiEkIQiSASIBZIhKFIhMgGXwiFCARhSASIBdIhEgGoUiEnwiFSASQgJhSISIBNCFYkgFIUiEyARQiCJQvBhXwiEXwiFCASQhGJhSISQgJIBIgEIQiSARhSIRIBVCIIlIhNIhKFIhVCEYkgFSARQhWJIBOFIhEgFEIgiXwiEwiFIUiFUINiSAVIBFCEIkgEUiESASQiCJfCISfIUiEyARQhWJIBKFIhEgFEIgiXwiEnwiFCARQhCJIBKFQhWJhSATQhGJhSAUQiCIhaciDXEiBiEEIAUgBmopAABCgIGChIiQoMCAfMiEVAEQEEIIQIgBiEEAAgAiAEaiEEIAJBCGohAiAFIAQgCHEiBGopAABCgIGChIiQoMCAfMiEVANAAsLIAUgEXqnQQNIARqIAhxIgRqLAAAQXKBEAgBSkDAEKAgYKEiJCgwIB/gqnQQNIQQLIAQgBmsgAyAGaMgCHFBCEEQCAFIARBfNBARqIQIgBCAFaiIGLQAAIAYgDUEZdiIGOgAAIARBeGogCHEgBWpBCGogBjoAAEH/AUYNAiAHLQAFIQQgByABCEGIAcgAiABDsABCACLQAHIQgAiABiEOIAIgByABjsABiAHKAAAIRAgByACKAAANgAAIAIgEDYAACACIAYAAQgByAOOgAGIAIgBDoABSAHIAAAcMAQsLIAwgDUEZdiICOgAAIANBeGogCHEgBWpBCGogAjoAAAwBCyAMQfBOgAAIANBeGogCHEgBWpBCGpB/wEAAAgAiAHKQAANwAACyADQQFqIQIgAyAIRwACwsgASALIAprNgIIDAULIAIgBWoiBCAEKQMAIhFCBhCfVCgYKEiJCgwIABgyARQv/+/fv+//wCEfDcDAEEBIQQgAkEBaiECDAALAAtBBEEIIAJBBEkbCyICQf////BcSACRgRAIAJBAQiBCACQQhqIgtqIgYgBENAQsQayAJKAIUIQIgCSgCECEEDAMLAkACQCAGQQBOBEBBCCEFAkAgBkUNACAGQQgQngEiBQAIAZBCBCzAQALIAQgBWogCxBFIQYgAkF/aiIFIAJBAZBBwgBUEISRsgCmshCyABQQRqIgIoAgAhCiAHDQEgASALNgIIIAEgBTYCACACIAYAgAMAgsQayAJKAIcIQIgCSgCGCEEDAQLIANBCGopAwAiGELtpHzlszct+QAhSIRIAMpAwAiFkLysDzbt/MAhXwiFIgiSEZIBFCDYkgFUiFIRiSEaIBZCeSVbsbzsAIUhFkEAIQMDQCADIApqLAAAQQBOBEAgBiAFIBggCiADQQNaFajUCAEKAgICAgICAgASEIhGFQvPKcunjNmyACFIhJCEIkgEiAWfCIShSITIBlIhQgEYUgEiAXfCIRIBqFIhJIhUgEkINiYUiEiATQhWJIBSFIhMgEUIgiUL/AYVIhFIhQgEkIRiYUiEkINiSASIBNCEIkgEYUiESAVQiCJfCITfCIShSIVQhGJIBUgEUIViSAThSIRIBRCIIlIhNIhSFIhVCDYkgFSARQhCJIBOFIhEgEkIgiXwiEnyFIhMgEUIViSAShSIRIBRCIIlIhJIhQgEUIQiSAShUIViYUgEIRiYUgFEIgiIWnIgxxIgRqKQAAQoCBgoSIkKDAgH+DIhFQBEBBCCECAAgAiAEaiEEIAJBCGohAiAGIAQgBXEiBGopAABCgIGChIiQoMCAfMiEVANAAsLIAYgEXqnQQNIARqIAVxIgJqLAAAQXKBEAgBikDAEKAgYKEiJCgwIB/gqnQQNIQILIAIgBmogDEEZdiIEOgAAIAJBeGogBXEgBmpBCGogBDoAACAGIAJBfNBARqIAogAF/cEDdGopAAAAwALIAMgCEYgAEBaiEDRQACyABIAsAgggASAFNgIAIAFBBGogBjYCACAIRQBCGBgICAeCECIAggBEDdCIEakEJakUNASAKIARrEBUMAQtBgYCAgHghAgsLIAAgAjYCBCAAIAQAgAgCUEwaiQACYNAhV/AXjAEHQAGsiAiQAIAJBADYCECACQgQAwggAkEYaiABKAIAIggAUEEaigCACIOIAFBCGooAgAiChAfAkACQAJAIAIoAhgiAUUEQCAOIQUgDSEGDAELIApBDGohFCACQTBqIREgAkEoakEFciESIApBCGohFSAKQRRqIRYCQANAIBUoAgAgEohCCACKAIkIQcgAigCICEDIAIoAhwiBQRAIAIoAhAiBCACKAIMRgRAIAJBCGogBBAIAIoAhAhBAsgAigCCCAEQQRaiIGIAEAgRBACEEIAZBADYCACAGQQhqIAUAgAgAiACKAIQQQFqNgIQIAVBAEhCSAFQXqQQNPBEAgBUFcSEMAAgBCABLQAAQQpGaiABQQFqLQAAQQpGaiABQQJqLQAAQQpGaiABQQNqLQAAQQpGaiEEIAFBBGohASAMQXxqIgwNAAsLIAkEQANAIAQgASAAEEKRmohBCABQQFqIQEgCUF/aiIJDQALCyAEIAtqIQsgBSAIaiEICwJAAkACQAJAIAcEQAJAIAMsAAAiAUF/SgRAIAFB/wFxIQQMAQsgAyAAUE/cSEGIAFBHEhBSABQVNBEAgBUEGdCAGciEEDAELIAMtAAJBPEgBkEGdHIhBiABQXBJBEAgBiAFQQxciEEDAELIAVBEnRBgIDwAHEgAyAAE/cSAGQQZcnIiBEGAgMQARgCCEBIRAgCigCJCAERwRAQQAhECAEIAooAiBHDQILIAdBAUEQCAIQQFqIQgMBQsgAywAASIBQb/SgCDAkLIABBCGogDSAOIAsgCBAcIABCgYCAgDAAgAMBQtBAiEQDAELIANBAWohAyAIQQFqIQggBF/aiEHCwJAIAFBfwEQCADLQABQTxIQYgAUEfcSEFIAFBXEQCAFQQZIAZyIQEMAgsgAyAAkE/cSAGQQZciEGIAFBcEkEQCAGIAVBDHRyIQEMAgsgBUESdEGAgPAAcSADLQADQTxIAZBBnRyciIBQYCAxABGDQIMAQsgAUH/AXEhAQsCQAJAAkACQCAKKAIcIgUgAUcEQCABIAooAhgiBkYNASAGDQJBACEPDAQLQQEhDyAHQQJJDQIgAywAAUG/fwNCQwCCEAIQgBECSQBIAMsAAFBvKDQEMCAtBASEPIAUNAgwBCyAIQQFqIQggAEBaiEDIAdBfohBwsgAkFAayADIAcgFBAfAkACQAJAAkACQCACKAJAIgcEQCACKAJMIQUgAigCSCEGIBYoAgACQCACKAJEIgNBfoiAUUEQCAHLQAAIQkMAQsgAUNBCABIAdqLAAAIglBvMDQQLIAhqIQRBASEIIAlB/wFxIgkgCigCJEYNAUEAIQggCigCICAJRgBIAMgBGohEECIQgMAgsgESANIAgCyAIEBwgAikDMCEXIABBEGogAigCODYCACAAQQhqIBcAgAgAEKBgICAMDcCAAwHCyADIARqIRMgAUUNAiABIQMLIANBAEhCQJAIANBfpBAkEQEEAIQQgByEBDAELIANBfHEhDEEAIQQgByEBAAgBCABLQAAQQpGaiABQQFqLQAAQQpGaiABQQJqLQAAQQpGaiABQQNqLQAAQQpGaiEEIAFBBGohASAMQXxqIgwNAAsLIAlFDQIDQCAEIAEtAABBCkZqIQQgAUEBaiEBIAlBfoiCQACwwCCyAHIAMgASADEHsACEAIQNBACEECyACKAIQIgEgAigCDEYEQCACQQhqIAEQPSACKAIQIQELIAQgCohCyACKAIIIAFBBHRqIgEgCDoADiABIBAAAgASAHNgIEIAFBATYCACABQQxqIAAAAgAUEIaiADNgIAIAIgAigCEEEBajYCECACQRhqIAYgBSAKEBgAigCGCIBRQDDAELCyARIAgDiALIAgQHCACQQIAiwgAkHCAGogEkECaiAACIBOgAAIAIgEiAACIHOwFAIAJBOGooAgAhAyACKQMwIRcgAEECOgAEIAAgBzsABSAAQQdqIAEAAAgAEEQaiADNgIAIABBCGogFzcCACAAQQEAgALIAIoAgxFDQEgAigCCBAVDAELIAUEQCACKAIQIgEgAigCDEYEQCACQQhqIAEQPSACKAIQIQELIAIoAgggAUEEdGoiASAGNgIEIAFBADYCACABQQhqIAUAgAgAiACKAIQQQFqNgIQCyAAIAIpAwgAgQgAEEANgIAIABBDGogAkEQaigCADYCAAsgAkHQAGokAALIAMgBEBIAcQewALqwsCCnBfgJ/AkAgBARAQQEhDQJAIARBAUYEQEEBIQgMAQtBASEGQQEhBwNAIAchCwJAAkAgBSAKaiIIIARJBEAgAyAGaiAACIHIAMgCGotAAAiBkEQCAGIAdGDQJBASENIAtBAWohBEAIQUgCyEKDAMLIAUgCpBAWoiByAKayENQQAhBQwCCyAIIARB+JfAABBbAAtBACAFQQFqIgcgByANRiIGGyEFIAdBACAGGyALaiEHCyAFIAdqIgYgBEkNAAtBASEGQQEhBEAIQVBASEIAAgByELAkACQCAFIAlqIgwgBEkEQCADIAZqLQAAIgcgAyAMaiAACIGTQRAIAYgBYNAkEBIQggCEBaiEHQQAhBSALIQkMAwsgBSALakEBaiIHIAlrIQhBACEFDAILIAwgBEHlAAEFsACEAIAVBAWoiByAHIAhGIgYbIQUgBEAIAYbIAtqIQcLIAUgBoiBiAESQACyAKIQULIAUgCSAFIAlLIgUbIgsgBEEQCANIAggBRsiByALaiIFIAdPBEAgBSAETQRAIAMgAyAHaiALELgBBEAgCyAEIAtrIgZLIQogBEEDcSEHIARBfpBAkEQCADIQUMBgsgBEFcSEIIAMhBQNAQgEgBTEAAIYgDRCASAFQQFqMQAAhoRCASAFQQJqMQAAhoRCASAFQQNqMQAAhoQhDyAFQQRqIQUgCEFaiIIDQALDAULQQEhCUEAIQVBASEGQQAhDQNAIAYiCiAFaiIMIARJBEACQAJAAkAgBCAFayAKQXzaiIIIARJBEAgBUF/cyAEaiANayIGIARPDQEgAyAIaiAACIIIAMgBmotAAAiBkEQCAGIAhGDQMgCkEBaiEGQQAhBUEBIQkgCiENDAQLIAxBAWoiBiANayEJQQAhBQwDCyAIIARBiJjAABBbAAsgBiAEQZiYwAAQWwALQQAgBUEBaiIIIAggCUYiBhshBSAIQQAgBhsgCmohBgsgByAJRwBCwtBASEJQQAhBUEBIQZBACEIAAgBiIKIAVqIggBEkEQAJAAkACQCAEIAVrIApBfNqIgwgBEkEQCAFQXzIARqIAhrIgYgBENASADIAxqLQAAIgwgAyAGaiAACIGTQRAIAYgDEYNAyAKQQFqIQZBACEFQQEhCSAKIQgMBAsgDkEBaiIGIAhrIQlBACEFDAMLIAwgBEGImMAAEFsACyAGIARBmJjAABBbAAtBACAFQQFqIgwgCSAMRiIGGyEFIAxBACAGGyAKaiEGCyAHIAlHDQELCyAHIARNBEAgBCANIAggDSAISxtrIQpBACEJAkAgBUEQEEAIQcMAQsgBEDcSEIAkAgBF/akEDSQRAIAMhBQwBCyAHQXxxIQYgAyEFABCASAFMQAAhiAPhEIBIAVBAWoxAACGhEIBIAVBAmoxAACGhEIBIAVBAoxAACGhCEPIAVBBGohBSAGQXxqIgYNAAsLIAhFDQADQEIBIAUxAACGIA+EIQgBUEBaiEFIAhBfoiCAACwsgBAwGCyAHIAQQtQEACyAFIAQQtQEACyAHIAUQtgEACyALIAQQtQEACyAAIAMAjggACABNgIwIABBADoADiAAQgAAwAgAEEakEANgIAIABBNGogAjYCACAAQQxqQYECOwEAIABBCGogAjYCAALIAcEQANAQgEgBTEAAIYgDQhDyAFQQFqIQUgBF/aiIHDQALCyALIAYgChtBAWohBF/IQkgCyEKQXLIQUgACADNgIIAAgATYCMCAAQQEAgAgAEEaiAENgIAIABBNGogAjYCACAAQShqIAUAgAgAEEkaiAJNgIAIABBIGogAjYCACAAQRxqQQAAgAgAEEYaiAHNgIAIABBFGogCjYCACAAQRBqIAsAgAgAEEIaiAPNwIAC+AJAQ/IwBBABrIgEkACABQcgAaiAAQShqKAIAIgYAgAgAUFAayILIABBIGopAgAAwAgAUEaiAAQRhqKQIANwMAIAFBMGogAEEQaikCADcDACABQShqIABBCGopAgAAwAgASAAKQIANwMgAkAgBkUEQAwBCyABKAIoIQcgASgCJCEIIAEtAEQhCiABQTRqKAIAIgUgAUEsaigCACIMSwRAIApFIAggASgCICIARnEEQAwCCyAHRQRADAILIAggAGshBCABLQBFRSEAAAgAEEBcUUNAiADIARqQQFqIQNBACEAIAZBfoiBgACwwBCyABQTxqKAIAIgkgCpBfohDSAJQQRNBEAgASARSECAAgAkH/AXENAgJ/AkAgBSABKAIwIgJJDQADQCACIAdqIQgDSAACEPAkACfyAFIAJrIgRBCEEQCABQRhqIAgDiAEEDEgASgCHCEAIAEoAhgMAQtBACEAQQAgBEUNABoDQEEBIAgACAOaiAAEYNARogBCAAQQFqIgBHDQALIAQhAEEACEBRgRAIAEgACACakEBaiICNgIwIAIgCUkgAiAMSINASAHIAIgCWsiAGogCyAJELgBDQEgASgCICEEIAEgAjYCICAAIARrIQBBAAwECyABIAUAjAMAgsgBSACTwACwsgCkVBACABKAIgIgAgCEYbDQMgAUEBOgBFIAggAGshAEEBCyECIAdFBEBBACEDDAMLIAAgApBAWohAyAGQXqIgYNAAsMAQsgASARSEAAkACQCAKRUEAIAEoAiAiBCAIRhtFBEAgBUNASAIIARrIQsgAEUhAANAIABBAXFFDQQCQCAFIAEoAjAiAkkNAANAIAIgBohCCANLQAAIQoCfyAFIAJrIgRBCEEQCABQQhqIAogCCAEEDEgASgCDCEAIAEoAggMAQtBACEAQQAgBEUNABoDQEEBIAogACAIaiAAEYNARogBCAAQQFqIgBHDQALIAQhAEEACEBRgRAIAEgACACakEBaiICNgIwIAIgCUBACACIAxNGwGIAUgAkkNAgwBCwsgASAFNgIwCyABQQEAEUgAyALakEBaiEDQQAhACAGQXqIgYNAAsMAwsgAARADAMLIAUgASgCMCICSQRADAMLAAgAiAHaiEDIAtAAAhBgJ/IAUgAmsiBEEITwRAIAFBEGogBiADIAQQMSABKAIUIQAgASgCEAwBCEAIQBBACAERQAGgNAQQEgBiAAIANqLQAARgBGiAEIABBAWoiAEcNAAsgBCEAQQALQQFHBEBBACEDDAQLIAEgACACakEBaiICNgIwIAIgCUBACACIAxNGwCIAUgAkNAAtBACEDDAILIAAEQAwCCyAFIAEoAjAiAkkEQAwCCyAFIAdqIQcCQANAIAtAAAhAwJ/IAUgAmsiBEEITwRAIAEgAyACIAQQMSABKAIEIQAgASgCAAwBCEAIQBBACAERQAGgNAQQEgAyAAIAJqLQAARgBGiACIABBAWoiAGogBcNAAsgBCEAQQALQQFHDQEgASAAIAJqQQFqIgIAjAgAiAJTEAIAIgDEbDQIgBSACTwACEAIQMMAgsgASAFNgIwQQAhAwwBCyAJQQQQtQEACyABQdAAaiQAIAMLzAkBBXjAEEQayIGJAACQCADRQAAkACQAJAAkACQAJAAkACQCADLQAARQRAIAYgATYCACAGIAEgAmoiAzYCBCAGIAMAgwgBiABNgIIIAYgBkEIaiAEGEEQQUgBBsRAgBBdmoOBAIBAQMBCyAEDQcgAkUEQEEAIQIMCQsgASACaiEDAkADQAJAIAMiAkF/aiIDLQAAIgRBGHRBGHUiBUF/SgAIAVBPECfyACQXqIgMtAAAiBEEYdEEYdSIHQUBOBEAgBEEfcQwBCyAHQTxAngAkFaiIDLQAAIgRBGHRBGHUiCEFATgRAIARBDEMAQsgCEE/cSACQXxqIgMtAABBBFBBnRyCEGdHILQQZciIEQYCAxABHDQBBACECDAsLIARBIEYgBEFakEFSXJFBEAgBEGAAUkNAiAEECxFDQILIAEgAcNAAtBACECDAkLIAIgAWshAgwICEAIQMgBEUNAgwECEBIQUgBACIAYoAgwiAyAGKAIIRgRAQXhAwwCCyAGIANBfoiBDYCDCAELQAAIgRBGHRBGHUiBUF/TARAIAYgAF+aiIENgIMAngBCAACIEQRhQRhIgdBQEEQCAEQRxDAELIAYgAFaiIENgIMIAdBPECfyAELQAAIgRBGHRBGHUiCEFATgRAIARBDEMAQsgBiADQXxqIgMAgwgCEE/cSADLQAAQQdxQQZcgtBBnRyCyEEQXhAyAFQTxIARBBnRyIgRBgIDEAEYNAgtBfkF/IARBDUYbIQMMAQtBfyEDIARFDQAgBigCACIDIAYoAgRGBEBBASEFDAILIAYgAEBajYCAAJAIAMtAAAiBEEYdEEYdUF/SgAIAYgAECajYCACADLQABQTxIQUgBEEfcSEHIARBwFNBEAgBEGdCAFciEEDAELIAYgAEDajYCACADLQACQTxIAVBBnRyIQggBEHwAUkEQCAIIAdBDHRyIQQMAQsgBiADQQRqNgIAQQEhBSAHQRJQYCAABxIAMtAANBPEgCEEGdHJyIgRBgIDEAEYNAgtBAkEBIARBCkYbIQUMAQsgAiADaiIERQRAQQAhAgwFCwJAIAQgAkEQCADDQEgBCECDAYLIAEgBGosAABBvMDQAgBCECDAULIAEgAkEAIAQQewALIAUgAkEQCAFIAIiAYNAQwCCyABIAVqLAAAQb/TABIAUhAwsgASADaiEBIAIgAshAgwCCyABIAIgBSACEHsACwJAIAJFBEAMAQsgASACaiEJIAEhAwNAAkACfyADIgQsAAAiBUF/SgRAIAVB/wFxIQUgBEEBagwBCyAELQABQTxIQggBUEfcSEDIAVBXEQCADQQZIAhyIQUgBEECagwBCyAELQACQTxIAhBBnRyIQggBUFwSQRAIAggAEMdHIhBSAEQQNqDAELIANBEnRBgIDwAHEgBCAAE/cSAIQQZcnIiBUGAgMQARgBIARBBGoLIQMgBUEgRiAFQXdqQQVJckUEQCAFQYABSQDIAUQLEUNAwsgByAEayADaiEHIAMgCUcNAQsLIAIhBwsgASAHaiEBIAIgBshAgsgACACNgIEIAAgATYCACAGQRBqJAALyAsBCHjAEHgAGsiAyQAIABCATcCACAAQQhqIgRBADYCACAAQQBBEBBBIAQoAgAiBSAAKAIAaiIGQdSDwAApAAAAAAgBCAFQRBqNgIAIAZBCGpBIPAACkAADcAACADQQEAiwgAyABKAIIQShqIgUAiggAyAANgIYIANBABqQQEAgAgAICNwJMIANBIPAADYCSCADIANBKGoAlgCQAJAAkACQAJAAkAgAEYakGYisAAIANByABqEBFBEAgAigCACEIAkAgAigCCCIBRQAIAFBBHQhCkGQhMAAIQZBACEBQQAhBANAAngASAIaiIHQQRqIgkgBygCAEUNABoCQCAERQAIANBEGogBCgCACAEKAIEQQAgBiAGLQAAQQJGGEBEBAgAEIaiADKAIQIAMoAhRBACAHQQqIgQgBCAAEECRhtBABAQIANBGGogAygCCCADKAIMEBIgAEBNgIIANBATYCLCADIAUAiggAyADQRhqNgIwIAMgADYCRCADQQIAlwgAIDNwJMIANBmITAADYCSCADIANBKGoAlggAHEAGpBmIrAACADQcgAahAeDQUgAygCHEUNACADKAIYEBULIAdBDmohBgJAIAdBDGotAABFBEAgAECNgIsIAMgCTYCKCADIAAAhggAEBNgJcIANCAjcCTCADQfSEwAAAkggAyADQShqNgJYIANBGGpBmIrAACADQcgAahAeDQcgAECNgIIANBoIXAADYCMCADQQEAiwgAyAFNgIoIAMgADYCGCADQQIAlwgAIDNwJMIANBmITAADYCSCADIANBKGoAlggAEYakGYisAAIANByABqEBFDQFBqHAAEErIANByABqQdiBwABBqIXAABBSAAsgAECNgIsIAMgCTYCKCADIAAAhggAEBNgJcIANCAjcCTCADQcSEwAAAkggAyADQShqNgJYIANBGGpBmIrAACADQcgAahAeDQcLQQALIQQgCiABQRBqIgFHDQALIARFDQAgAyAEKAIAIAQoAgRBACAGIAYtAABBAkYbQQEQECADQRhqIAMoAgAgAygCBBASIANBNGpBATYCACADQQEAiwgAyAFNgIoIAMgAEYajYCMCADIAAAkQgAHcAGpBAjYCACADQgMAkwgAGYhMAANgJIIAMgAEoajYCWCADQcQAakGYisAAIANByABqEBNBSADKAIcRQAIAMoAhgQFQsgAEEEaigCACAAQQhqIgQoAgAiAWtBJEQCAAIAFBKBBBIAQoAgAhAQsgBCABQShqNgIAIAAoAgAgAWoiAUHIhcAAKQAANwAAIAFBCGpBIXAACkAADcAACABQRBqQdiFwAApAAAAAAgAUEYakHghcAAKQAANwAAIAFBIGpBIXAACkAADcAACADQTxqQQIAgAgAEakEBNgIAIANBoIXAADYCOCADIAUAjAgAEBNgIsIAMgBTYCKCADIAAAhggAHcAGoiAUEDNgIAIANCBDcCTCADQZiGwAAAkggAyADQShqNgJYIANBGGpBmIrAACADQcgAahAeDQUgAEBNgIsIAMgBTYCKCADIAAAhggAUEBNgIAIANCAjcCTCADQdCGwAAAkggAyADQShqNgJYIANBGGpBmIrAACADQcgAahAeDQYgAkEEaigCAARAIAgQFQsgAHgAGokAALQauBwABBKyADQcgAakHYgcAAQYCEwAAQUgALQauBwABBKyADQcgAakHYgcAAQbCEwAAQUgALQauBwABBKyADQcgAakHYgcAAQYSFwAAQUgALQauBwABBKyADQcgAakHYgcAAQdSEwAAQUgALQauBwABBKyADQcgAakHYgcAAQbiFwAAQUgALQauBwABBKyADQcgAakHYgcAAQbiGwAAQUgALQauBwABBKyADQcgAakHYgcAAQeCGwAAQUgALQkCCHGfiMAQdAAayIDJAACQAJAAkAQVCIEBEAgAEgakIANwMAIANBHGpBkIrAADYCACAEIAQpAwAiCIBfDcDACADQQAAhggAyALNwMIIAMgBEEIaikDADcDECADQqeAgIDwBDcDSCADQoAgICgDjcDQCADQoqAgIDgDTcDOCADQtyAgIDACzcDMCADQQhqIANBMGoQGSADQQAAjggAIENwMwIAJFBEAgAEEANgIIIABCATcCAEEEIQRBBCEBDAQLIAEgAmohCEEAIQIDQAJ/IAEsAAAiBEF/SgRAIARB/wFxIQQgAUEBagwBCyABLQABQTxIQUgBEEfcSEGIARBXEQCAGQQZIAVyIQQgAUECagwBCyABLQACQTxIAVBBnRyIQUgBEFwSQRAIAUgBkEMdHIhBCABQQNqDAELIAZBEnRBgIDwAHEgASAAE/cSAFQQZcnIiBEGAgMQARgEIAFBBGoLIQEgAyAENgIsAkAgAEIaiADQSxqECJFBEAgAygCLCECIAMoAjgiBCADKAIRgRAIANBMGogBBA+IAMoAjghBAsgAygCMCAEQQJaiACNgIADAELIAMoAjgiBCADKAIRgRAIANBMGogBBA+IAMoAjghBAsgAygCMCAEQQJakHcADYCACADIAMoAjhBAWoiAjYCOCADKAIkRQDIAMoAhgiBiADKQMQIgsgAygCLCIJrUKAgICAgICAgASEIgyFQvPKcunjNmyACFIgCEIkgDSADKQMIIgCeSVbsbzsAIVIgFIggCLtpHzlszct+QAhSILIACcrNgesfzAIVIgCIIlIhAgDIUgDSALQgJIAFIgtIgwgCIRiYUiCwiDSALQgJhSILIACFYkgEIUiDiAMQiCJQvBhXwiDHwiDyALQhGJhSILQgJIAsgDkIQiSAMhSIMIACIIlIgIguFIgCEYkgDiAMQhWJIAFIgwgDIgiXwiDXwiDoUiDINiSAPIAxCEIkgDYUiDCALQiCJfCILfIUiDSAMQhWJIAuFIgsgDkIgiXwiDHwiDiALQhCJIAyFQhWJhSANQhGJhSAOQiCIhSILpEhBCALQhmIQvAgKBgoSIkKDAgAF+IQBACEFIAMoAhwhBwNAIAQgBopAAAiDCANhSILQn+FIAtC//+/fv/+fINCgIGChIiQoMCAfMhCwNAIAtQBEAgDCAMQgGGgKAgYKEiJCgwIB/gBFDQYgBCAFQQhqIgVqIAZxIQQMAgsgCohDiALQnIAuDIQsgByAOpEDdiAEaiAGcUEDdGsiCkFaigCACAJRwACwsgCkFaigCACEEIAMoAjQgAkYEQCADQTBqIAIQPiADKAIIQILIAMoAjAgAkECdGogBDYCAAsgAyADKAIQQFqIgIAjggASAIRwACwwCCGwisAAQcYAIANBMGpBIvAAEHIiAAEFIACGAgcAAQZSDwAAQbwALIABBADYCCCAAQgEAgAgAygCMCIBIAJBAnRqIQQgAkUNACAAQQAgAhBBCyABIAQgABAoIAMoAjQEQCADKAIwEBULAkAgAygCGCIARQAIAAgAEEDdEEIaiIBakEJakUNACADKAIcIAFrEBULIANBABqJAALmAkBBXjAEHwAGsiBCQAIAQgAzYCDCAEIAIAggCQAJAAkACQAJAIAQCfwJAIAFBgQJPBEACfGAAiAALACAAkG/foNABpB/wEgACwA/wFBvKDQAaQfBIAAsAPBQb/SgAGkHAQsiBSABSQBIAEgBUcNAwsgBCABNgIUIAQgADYCEEGAkAAIQZBAAwBCyAEIAUAhQgBCAANgIQQcOYwAAhBkEFCzYCHCAEIAYAhggAiABSyIFIAMgAUtyDQEgAiADTQRAAkACQCACRQAIAIgAUEQCABIAJGDQEMAgsgACACaiwAAEFASABCyADIQILIAQgAjYCICACIAEiAkEQCACQQFqIgVBACACQXqIgMgAyACSxsiAkNBAJAIAMgBUYNACAAIAVqIAAgAoiBshBSAAIAJqIggsAABBvKBEAgBUF/aiEGDAELIAIgAYNACAIQXqIgIsAABBvKBEAgBUF+aiEGDAELIAIgBYNACAIQXqIgIsAABBvKBEAgBUFaiEGDAELIAIgBYNACAIQXqIgIsAABBvKBEAgBUFaiEGDAELIAIgBYNACAFQXtqIQYLIAMgBmohAwsCQCADRQAIAMgAUEQCABIANGDQEMBwsgACADaiwAAEG/fwNBgsgASADRgEAnCQAJAIAAgAoiASwAACIAQXMBEAgASAAUE/cSEFIABBHEhAiAAQVLDQEgAkEGdCAFciECDAILIAQgAEH/AXEAiRBAQwCCyABLQACQTxIAVBBnRyIQUgAEFwSQRAIAUgAkEMdHIhAgwBCyACQRJQYCAABxIAEtAANBPEgBUEGdHJyIgJBgIDEAEYNBgsgBCACNgIkQQEgAkGAAUkNABpBAiACQYAQSQAGkEDQQQgAkGAgARJGwshASAEIAMAiggBCABIANqNgIsIARBxABqQQUAgAgBEHsAGpBNDYCACAEQeQAakENgIAIARBABqQTUAgAgBEHUAGpBNjYCACAEQgUAjQgBEGsmsAANgIwIARBAzYCTCAEIARByABqNgJAIAQgBEEYajYCaCAEIARBEGoAmAgBCAEQShqNgJYIAQgBEEkajYCUCAEIARBIGoAkggBEEwakHUmsAAEHQACyAEQeQAakENgIAIARBABqQTQAgAgBEHUAGpBAzYCACAEQcQAakEENgIAIARCBDcCNCAEQbiZwAAAjAgBEEDNgJMIAQgBEHIAGoAkAgBCAEQRhqNgJgIAQgBEEQajYCWCAEIARBDGoAlAgBCAEQQhqNgJIIARBMGpBJnAABBAAsgACABQQAgBRBAAsgBCACIAMgBRsAiggBEHEAGpBAzYCACAEQdwAakENgIAIARBABqQTQAgAgBEIDNwIIARBJjAADYCMCAEQQMAkwgBCAEQcgAajYCQCAEIARBGGoAlggBCAEQRBqNgJQIAQgBEEoajYCSCAEQTBqQYSZwAAQdAALIAMgBRCAQALQdCTwABBJnAABBvAAsgACABIAMgARBAAv/BwEIfwJAAkAgAEEDakFcSICIABrIgMgAUsgAEESINACABIANrIgZBBEkNACAGQQNxIQdBACEBAkAgAUNACADQQNxIQgCQCACIABBfNqQQNJBEAgACECDAELIANBfHEhBCAAIQIDQCABIAIsAABBvKaiACQQFqLAAAQb/SmogAkECaiwAAEG/fpqIAJBAosAABBvKaiEBIAJBBGohAiAEQXxqIgQNAAsLIAhFDQADQCABIAIsAABBvKaiEBIAJBAWohAiAIQXqIggNAAsLIAAgAohAAJAIAdFDQAgACAGQXxxaiICLAAAQb/SiEFIAdBAUYNACAFIAIsAAFBvKaiEFIAdBAkYNACAFIAIsAAJBvKaiEFCyAGQQJIQMgASAFaiEEAAgACEBIANFDQIgAHAASADQcABSRsiBUEDcSEGIAVBAnQhBwJAIAVB/AFxIghBAnQiAEUEQEEAIQIMAQsgACABaiEJQQAhAiABIQADQCACIAAoAgAiAkF/cEHdiACQQZckGBgoQIcWogAEEEaigCACICQXzQQdIAJBBnZyQYGChAhxaiAAQQhqKAIAIgJBfNBBYgAkEGdnJBgYKECHFqIABBDGooAgAiAkF/cEHdiACQQZckGBgoQIcWohAiAAQRBqIgAgCUcNAAsLIAEgBohACADIAVrIQMgAkEIdkH/gfwHcSACQf+B/AdxakGBgARsQRBIARqIQQgBkUNAAsgASAIQQJaiEAIAZB/////wNqIgNB/////wNxIgFBAWoiAkEDcQJAIAFBAkEQEEAIQIMAQsgAkH////BEhAUEAIQIDQCACIAAoAgAiAkF/cEHdiACQQZckGBgoQIcWogAEEEaigCACICQXzQQdIAJBBnZyQYGChAhxaiAAQQhqKAIAIgJBfNBBYgAkEGdnJBgYKECHFqIABBDGooAgAiAkF/cEHdiACQQZckGBgoQIcWohAiAAQRBqIQAgAUFaiIBDQALCwRAIANBgYCAgHxqIQEDQCACIAAoAgAiAkF/cEHdiACQQZckGBgoQIcWohAiAAQQRqIQAgAUF/aiIBDQALCyACQQhQf+B/AdxIAJB/HBFqQYGABGxBEHYgBGoPCyABRQRAQQAPCyABQQNxIQICQCABQXqQQNJBEAMAQsgAUFcSEBAAgBCAALAAAQb/SmogAEEBaiwAAEG/fpqIABBAmosAABBvKaiAAQQNqLAAAQb/SmohBCAAQQRqIQAgAUFaiIBDQALCyACRQAAAgBCAALAAAQb/SmohBCAAQQFqIQAgAkF/aiICDQALCyAECcHAQV/IAAQvQEiACAAEKBIgIQugEhAQJAAkACQCAAELABDQAgACgCACEDAkAgABClAUUEQCACIANqIQIgACADELsBIgBBwLHAACgCAEcNASABKAIEQQNxQQNHDQJBuLHAACACNgIAIAAgAiABEIYBDwsgAiADakEQaiEADAILIANBgAJPBEAgABADAELIABBDGooAgAiBCAAQQhqKAIAIgVHBEAgBSAENgIMIAQgBTYCCAwBCGorsAAQaiuwAAoAgBBfiADQQNdEAgALAkAgARCiAQRAIAAgAiABEIYBDAELAkACQAJAQcSxwAAoAgAgAUcEQCABQcCxwAAoAgBHDQFBwLHAACAANgIAQbixwABBuLHAACgCACACaiIBNgIAIAAgARCUAQLQcSxwAAgADYCAEGscAAQbyxwAAoAgAgAmoiATYCACAAIAFBAXIAgQgAEHAscAAKAIARgBDAILIAEQrwEiAyACaiECAkAgAGAAkEQCABEDUMAQsgAUEMaigCACIEIAFBCGooAgAiAUcEQCABIAQAgwgBCABNgIIDAELQaiuwABBqKAACgCAEF+IANBAZcTYCAAsgACACEJQBIABBwLHAACgCAEcNAkGscAAIAIAgAMAwtBuLHAAEEANgIAQcCxwABBADYCAAtBLHAACgCACABTwBQYCAfEEIQQgQlwFBFEEIEJcBakEQQQgQlwFqaFcUFaiIAQQBBEEEIEJcBQQJayIBIAEgAEsbRQBQcSxwAAoAgBFDQFBCEEIEJcBIQBBFEEIEJcBIQFBEEEIEJcBIQJBAAJAQbyxwAAoAgAiBCACIAEgAEEIapqIgJNDQBBxLHAACgCACEBQdCxwAAhAAJAAAgACgCACABTQRAIAAQpwEgAUsNAgsgACgCCCIADQALQQAhAAsgABCxAQAIABBDGooAgAaDAALQQAQNtHDQFBvLHAACgCAEHgscAAKAIATQBQeCxwABBfzYCAALIAJBgAJJDQEgACACEDRBLHAAEHoscAAKAIAQXqIgAAgAgAAAEDcaDwsPCyACQQNIgNBARBsKAAGohAQJ/QaiuwAAoAgAiAkEBIANIgNxBEAgASgCCAwBCGorsAAIAIgAIAgAgAQshAyABIAAAgggAyAANgIMIAAgATYCDCAAIAMAggLgYBBnCQAJAAkACQAJAIAAoAggiCEEBREAIAAoAhAiBEEBRxtFBEAgBEEBRwDIAEgAmohByAAQRRqKAIAIgYNASABIQQMAgsgACgCGCABIAIgAEEcaigCACgCDBEDACEDDAMLIAEhBANAIAQiAyAHRgCAngAEBaiADLAAAIgRBfoNABogAECaiAEQWBJDQAaIANBAogBEFwSQAGiAEQfBcUESdEGAgPAAcSADLQADQTxIAMtAAJBPFBBnQgAyAAUE/cUEMdHJyckGAgMQARgDIANBBGoLIgQgBSADaohBSAGQXqIgYNAAsLIAQgBYNACAELAAAIgNBfogAFgSXIgAFwSXJFBEAgAH/AXFBEnRBgIDwAHEgBCAAE/cSAELQACQTxQQZIAQtAAFBPFBDHRycnJBgIDEAEYNAQsCQAJAIAVFBEBBACEEDAELIAUgAkEQEEAIQMgBSACIgRGDQEMAgtBACEDIAUiBCABaiwAAEFASABCyAEIQUgASEDCyAFIAIgAxshAiADIAEgAxshAQsgCEUNASAAQQxqKAIAIQcCQCACQRBPBEAgASACEBQhBAwBCyACRQRAQQAhBAwBCyACQQNxIQUCQCACQXqQQNJBEBBACEEIAEhAwwBCyACQXxxIQZBACEEIAEhAwNAIAQgAywAAEG/fpqIANBAWosAABBvKaiADQQJqLAAAQb/SmogAEDaiwAAEG/fpqIQQgAEEaiEDIAZBfGoiBgACwsgBUUNAANAIAQgAywAAEG/fpqIQQgAEBaiEDIAVBfoiBQACwsgByAESwRAQQAhAyAHIARrIgQhBgJAAkACQEEAIAAtACAiBSAFQQNGGEDcUEBawCAAECCEAIQYgBCEDDAELIARBAXYhAyAEQQFqQQFIQYLIANBAWohAyAAQRxqKAIAIQQgACgCBCEFIAAoAhghAAJAAAgAF/aiIDRQBIAAgBSAEKAIQEQEARQACEBDwtBASEDIAVBgIDEAEYNASAAIAEgAiAEKAIMEQMADQFBACEDAAgAyAGRgRAQQAPCyADQQFqIQMgACAFIAQoAhARAQBFDQALIANBfogBkkPCwwBCyADDwsgACgCGCABIAIgAEEcaigCACgCDBEDAAv+BgEGfErQYCAxAAgACgCACIFQQFxIgYbIQogBCAGaiEHAkAgBUEEcUUEQEEAIQEMAQsCQCACQRBPBEAgASACEBQhCAwBCyACRQAIAJBAEhBgJAIAJBfpBAkEQCABIQUMAQsgAkFcSEJIAEhBQNAIAggBSwAAEG/fpqIAVBAWosAABBvKaiAFQQJqLAAAQb/SmogBUEDaiwAAEG/fpqIQggBUEEaiEFIAlBfGoiCQACwsgBkUNAANAIAggBSwAAEG/fpqIQggBUEBaiEFIAZBfoiBgACwsgByAIaiEHCwJAAkAgACgCCEUEQEEBIQUgACAKIAEgAhBuDQEMAgsCQAJAAkACQCAAQQxqKAIAIgYgBsEQCAALQAAQQhxDQRBACEFIAYgBsiBiEHQQEgACAICIIIAhBAYbQQNxQQFrDgIBAgMLQQEhBSAAIAogASACEGNBAwFCEAIQcgBiEFDAELIAZBAXYhBSAGQQFqQQFIQcLIAVBAWohBSAAQRxqKAIAIQggACgCBCEGIAAoAhghCQJAAAgBUF/aiIFRQBIAkgBiAIKAIQEQEARQACEBDwtBASEFIAZBgIDEAEYNASAAIAogASACEGNASAAKAIYIAMgBCAAKAIcKAIMEQMADQEgACgCHCEBIAAoAhghAEEAIQUCfwNAIAcgBSAHRgBGiAFQQFqIQUgACAGIAEoAhARAQBFDQALIAVBfoLIAdJIQUMAQsgACgCBCEIIABBMDYCBCAALQAgIQlBASEFIABBAToAICAAIAogASACEGNAEEAIQUgBiAHayIBIQICQAJAAkBBASAALQAgIgYgBkEDRhtBAFBAWsOAgABAgtBACECIAEhBQwBCyABQQFIQUgAUEBakEBdiECCyAFQQFqIQUgAEEcaigCACEGIAAoAgQhASAAKAIYIQcCQANAIAVBfoiBUUNASAHIAEgBigCEBEBAEUNAAtBAQLQQEhBSABQYCAxABGDQAgACgCGCADIAQgACgCHCgCDBEDAAAIAAoAhwhAyAAKAIYIQRBACEGAkADQCACIAZGDQEgBkEBaiEGIAQgASADKAIQEQEARQACyAGQXqIAJJDQELIAAgCToAICAAIAgAgRBAALIAUPCyAAKAIYIAMgBCAAQRxqKAIAKAIMEQMACMHAQZ/AkACQAJAIAJBCUEQCADIAIQJyICDQFBAALQQAhAkGAgHxBCEEIEJcBQRRBCBCXAWpBEEEIEJcBamtBdFBfWoiAUEAQRBBCBCXAUECdGsiBSAFIAFLGyADTQBQRAgAEEakEQQQgQlwFBeogAsbQQgQlwEhBSAAELBIgEgARCvASIGELoBIQQCQAJAAkACQAJAAkACQCABEKUBRQRAIAYgBUNASAEQcSxwAAoAgBGDQIgBEHAscAAKAIARgDIAQQogENByAEEKBIgcgBmoiCCAFSQHIAggBWshBiAHQYACSQEIAQQNQwFCyABEKBIQQgBUGAAkkNBiAEIAVBBGpPQQAgBCAFaGBgAhJGwFIAEoAgAiBiAEakEQaiEHIAVBHpBgIAEEJcBIQRBACIFRQGIAUgBmoiASAEIAZrIgBBcGoiAjYCBCABIAIQugFBBzYCBCABIABBdGoQugFBADYCBEHIscAAQcixwAAoAgAgBCAHaoiADYCAEHkscAAQeSxwAAoAgAiAiAFIAUgAksbNgIAQcyxwABBzLHAACgCACICIAAgAiAASxsAgAMCQsgBiAFayIEQRBBCBCXAUkNBCABIAUQugEhBiABIAUQggEgBiAEEIIBIAYgBBAhDAQLQbyxwAAoAgAgBmoiBiAFTQEIAEgBRCASEEIAEgBRCCASAEIAYgBWsiBUEBcjYCBEGscAAIAUAgBBxLHAACAENgIADAMLQbixwAAoAgAgBmoiBiAFSQDAkAgBiAFayIEQRBBCBCXAUkEQCABIAYQggFBACEEQQAhBgwBCyABIAUQugEiBiAEELoBIQcgASAFEIIBIAYgBBCUASAHIAcoAgRBfnEAgQLQcCxwAAgBjYCAEGscAAIAQAgAMAgsgBEEMaigCACIJIARBCGooAgAiBEcEQCAEIAkAgwgCSAENgIIDAELQaiuwABBqKAACgCAEF+IAdBAZcTYCAAsgBkEQQQgQlwFPBEAgASAFELoBIQQgASAFEIIBIAQgBhCCASAEIAYQIQwBCyABIAgQggELIAENAwsgAxALIgVFDQEgBSAAIAMgARCvAUFQXwgARClARtqIgEgASADSxsQuQEgABAVDwsgAiAAIAMgASABIANLGxCARogABAVCyACDwsgARClARogARCAQvbBQIKfwd+IwBBMGsiAiQAIABBGGooAgBBAkEEIABBHGooAgAbIgNJBEAgAiAAQRBqIAMgABAMCyACQSBqIAFBGGopAgAAwAgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACQoCAgIDAADcDKCACIAEpAgAAwggAEEQaiEJQQAhAyAAQRRqIQoDQCAAKAIQIgQgAkEIaiADQQNaikCACIQQv////PgyIMIABBCGopAwAiDYVCrRyeMbLwAIUiDkIQiSAOIAApAwAiDLhJXzuzZvOwAhXwiDoUiESANQuekfOWzNyACFIggDLysDzbt/MAhXwiDIgiXwiEiAMQoCAgICAgICABISFIAgDUINiSAPhSIMfCINIAxCEYmFIgxIggDEINiYUiDCARQhWJIBKFIggDUIgiUL/AYVIgIhEgDEIRiYUiDEINiSAMIACEIkgDYUiDSAOQiCJfCIOfCIMhSIPQhGJIAgDUIViSAOhSINIBFCIIlIgIg+FIhFCDYkgESANQhCJIAFIggDEIgiXwiDHyFIggDUIViSAMhSIMIACIIlIgIggDEIQiSANhUIViYUgDkIRiYUgDIgiYUiDKdxIQEgDEIZiEL/AINCgYKEiJCgwIABfiEOIANBAWohAyAKKAIAIQUgEKchBiAQQiCIpyEHQQAhCAJAAkADQCABIAVqKQAAIggDoUiEEJ/hSAQQv/+/fv//fnyDQoCBgoSIkKDAgH+DIRADQCAQUARAIAgDUIBhoNCgIGChIiQoMCAfNQRQDIAEgCEEIaiIIaiAEcSEBDAILIBBIQgEEJ/fCAQgyEQIAUgDdBAYgAWogBHFBARrIgtBeGooAgAgBkcNAAsLIAtBfGogBzYCAAwBCyAJIAwgBiAHIAAQJgsgAEERwACyACQTBqJAALmAUBBCQAJ/AkAgACABayACSQRAIAEgAmohBSAAIAJqIQMgACACQQNDQIaIANBfHEhAEEAIANBAEiBmshByAGBEAgASACakF/aiEEAAgAF/aiIDIAQtAAAAAAgBEF/aiEEIAAgAkNAAsLIAAgAiAGayIGQXxxIgJrIQNBACACayECIAUgBoiBUEDcQRAIAJBfoNAiAFQQNIgRBGHEhByAFQXxxIghBfGohAUEAIARrQRhxIQkgCCgCACEEAAgAEFaiIAIAQgCXQgASgCACIEIAdcjYCACABQXxqIQEgACADSwACwwCCyACQXKDQEgASAGakFaiEBAAgAEFaiIAIAEoAgAAgAgAUFaiEBIAAgAsNAAsMAQsCQCACQQNBEAgACEDDAELIABBACAAaEDcSIFaiEEIAUEQCAAIQMgASEAAAgAyAALQAAOgAAIABBAWohACADQQFqIgMgBEkNAAsLIAQgAiAFayICQXxxIgZqIQMCQCABIAVqIgVBAEEQCAGQQFIDQEgBUEDdCIAQRhxIQcgBUFcSIIQQRqIQFBACAAaEYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkNAAsMAQsgBkEBSAAIAUhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIANJDQALCyACQQNxIQIgBSAGaiEBCyACRQCIAIgAohAANAIAMgASAADoAACABQQFqIQEgAEBaiIDIABJDQALDAILIAZBAEiAEUNASACIAVqIQUgAyAAawshACAFQXqIQEDQCADQXqIgMgASAADoAACABQXqIQEgACADSQACwsLwwUCAXCfiMAQfAAayIFJAAgBSADNgIkIAUgAjYCICAFIAFBBGoAiggBUHQAGogBUEgahANIAVBABqQQRyIQICQAJAAkAgBSgCUEUEQCAFQThqIAJBCGooAgAiAzYCACAFIAIpAgAiBjcDMCAFQdgAaiADNgIAIAUgBjcDUCAFQUBrIAVBIGogBUHQAGoQESAFQSEAmQgBUGwhAAQQIQATYCaCAFIAUoAkAiAiAFKAJIEAEAmwgBUEYaiABIAVBABqIAVBABqIAVBABqEGYgBSgCHCEBAkAgBSgCGEUEQCAFKAJsIgNBJEEQCADEAALIAUoAmgiAEkTwRAIAMQAAsgBSgCZCIDQSRPBEAgAxAACyAFIAEAmwgBUEhNgJQIAVBCGogBUHsAGogBUHQAGogBBBpIAUoAgwhASAFKAIIRQDIABCgYCAgBAAgAgAUEkTwRAIAEQAAsgBSgCUCIAQSRPBEAgABAACyAFKAJsIgBBJEkNASAAEAAMAQsgBSABNgJQIAVBEGogBUHQAGooAgAQBSIBEAIgBSgCECIERQDIAUoAhQhAyABQSNLBEAgARAACyAAQgEAgAgAEEQaiADNgIAIABBDGogAzYCACAAQQhqIAQAgAgBSgCUCIAQSRPBEAgABAACyAFKAJsIgBBJEEQCAAEAALIAUoAmgiAEEkTwRAIAAQAAsgBSgCZCIAQSRJDQAgABAACyAFKAJERQDIAIQFQwDCyAFQcgAaiACQQhqKQIAIgYAwAgBSACKQIAIgcAAgAEEMaiAGNwIAIAAgBzcCBCAAQQEAgAMAgsgBSgCUCIDQSRPBEAgAxAACyAAQQAAgAgACABNgIEIAUoAmwiAEEkTwRAIAAQAAsgBSgCREUNASACEBUMAQtBgIHAAEGhAAEGACyAFQfAAaiQACwFAQN/IwBBgAFrIgUkACAFQfAAakEKNgIAIAVBABqQoqAgIAQNwMAIAVBABqIAIAgAgBUHgAGpBADYCACAFQdwAaiACNgIAIAUgAzYCeCAFQQAAXQgBSABNgJYIAUgAjYCVCAFQQAAlACQCADBEAgBUEANgJIANBfoiBgRAAAgBUEQaiAFQdAAahAdIAUoAhBFDQMgBkF/aiIGDQALCyAFQQhqIAVBABqEBgBSgCCEUNAQsgBSAFQdAAahAdIAUoAgAiBkUNACAFKAIEIQcgBSAGNgIYIAUgBzYCHCAFQfAAakEKNgIAIAVBABqQoqAgIAQNwMAIAVBABqIAIAgBBACEHIAVBABqQQAAgAgBUHcAGogAjYCACAFIAMAnggBUEBOwFIAUgATYCWCAFIAIAlQgBUEANgJQIAUgBCAFQdAAahAPayIBNgIkIAVBADYCMCAFQgEAygCQCABQXqIgIEQCAFQShqQQAgAhBBIAUoAjAhBgNAIAUoAiwgBkYEfyAFQShqIAYQQCAFKAIwBSAGCyAFKAIoakEgOgAAIAUgBSgCMEEBaiIGNgIwIAJBfoiAgACyAFKAIsIgcgBkcNAQsgBUEoaiAHQQEQQSAFKAIwIQYLIAUoAiggBmpBgAAAAgBSAGQQFqNgIwIAVBABqQQEAgAgBUHkAGpBAjYCACAFQdwAakEDNgIAIAVBAzYCVCAFIANBAWoAjQgBSAFQShqNgJoIAUgBUEYajYCYCAFIAVBJGoAlggBSAFQTRqNgJQIAVBzABqQQQAgAgBUIENwIIAVBxILAADYCOCAFIAVBABqNgJIIAAgBUEahAjIAUoAiwEQCAFKAIoEBULIAVBgAFqJAAPCGAgcAAQaSCwAAQbwALwAQBDXjAEEQayIFJAACQCABLQAlDQAgASgCCCEIAnCQCABQRRqKAIAIgYgAUEQaigCACIDSQAIAYgAUEMaigCACIMSwAIAFBHGooAgAiByABQSBqIgqQXqIQCQCAHQQRNBEADQCADIAhqIQkgDSAACEKAngBiADayIEQQhPBEAgBUEIaiAKIAkgBBAxIAUoAgwhAiAFKAIIDAELQQAhAkEAIARFDQAaABBASAKIAIgCWotAABGDQEaIAQgAkEBaiICRwACyAEIQJBAAtBAUcNAiABIAIgApBAWoiAzYCEAJAIAMgBkgAyAMSINACAIIAMgBsiBGogDiAHELgBDQAgASgCACECIAEgAzYCACAEIAJrDAULIAYgANAAwDCwALAAgAyAIaiEJIAtAAAhCgJ/IAYgAsiBEEITwRAIAUgCiAJIAQQMSAFKAIEIQIgBSgCAAwBCEAIQJBACAERQAGgNAQQEgCiACIAlqLQAARgBGiAEIAJBAWoiAkcNAAsgBCECQQALQQFHDQEgASACIANqQQFqIgMAhAgAyAHTEAIAMgDEbRQRAIAYgANAQwDCwsgBEEELUBAAsgASAGNgIQCyABLQAkIAEoAgAiAiABKAIEIgRHckUNASABQQEACUgBCACawshAyAIRQAIAIgCGohCyADRQRAQQAhAgwBCyADQXqIgEgAyABIAtqLQAAQQGGyECCyAAIAIAgQgACALNgIAIAVBEGokAAv+BAEKfyMAQTBrIgMkACADQSRqIAEAgAgAEDOgAoIANCgICAgIAENwMIIAMgADYCICADQQAAhggAEANgIQAkACQAJAIAIoAggiCkUEQCACQRRqKAIAIgRFDQEgAigCACEBIAIoAhAhACAEQXqQf////BcUEBaiIHIQQDQCABQQRqKAIAIgUEQCADKAIgIAEoAgAgBSADKAIkKAIMEQMADQQLIAAoAgAgAEIaiAAQQRqKAIAEQEADQMgAEEIaiEAIAFBCGohASAEQXqIgQNAAsMAQsgAkEMaigCACIARQAIABBBXQhCyAAQXqQf///zxQQFqIQcgAigCACEBAAgAUEEaigCACIABEAgAygCICABKAIAIAAgAygCJCgCDBEDAADCyADIAQgCmoiBUEcaiAADoAKCADIAVBBGopAgBCIIkAwggBUEYaigCACEGIAIoAhAhCEEAIQlBACEAAkACQAJAIAVBFGooAgBBAWsOAgACAQsgBkEDdCAIaiIMKAIEQTdHDQEgDCgCACgCACEGCEBIQALIAMgBjYCFCADIAAAhAgBUEQaigCACEAAkACQAJAIAVBDGooAgBBAWsOAgACAQsgAEEDdCAIaiIGKAIEQTdHDQEgBigCACgCACEACEBIQkLIAMgADYCHCADIAkAhggCCAFKAIAQQNaiIAKAIAIANBCGogACgCBBEBAACIAFBCGohASALIARBIGoiBEcNAAsLQQAhACAHIAIoAgRJIgFFDQEgAygCICACKAIAIAdBARqQQAgARsiASgCACABKAIEIAMoAiQoAgwRAwBFDQELQQEhAAsgAEwaiQAIAALwgQBCHjAEHQAGsiBCQAIARBEGogASACIAMoAgAgAEIaigCABAOAkACQAJAAkACQAJAIAQoAhBFBEAgBEEeaiAAAEIARBxABqKAIAIQYgBCgCQCEHIARBHGotAABFIQggBCgCFCEDAACQCADRQAIAYgAEQCADIAZGDQEMCQsgAyAHaiwAAEFASAICyADIAZGDQICfyADIAdqIgksAAAiBUF/TARAIAktAAFBPEiCiAFQRxIgtBBnRyIAVBYEkNARogCSAAkE/cSAKQQZciIKIAtBDHRyIAVBcEkNARogCESdEGAgPAAcSAJLQADQTxIApBBnRycgwBCyAFQfBcQshBSAIRQRAIAMhBgwECyAFQYCAxABGDQQCfEBIAVBgAFJDQAaQQIgBUGAEEkNABpBAEEIAVBgIAESRsLIANqIQNBACEIDAALAAsgBEEYaiEDIARBzABqKAIAIQYgBEHEAGooAgAhBSAEKAJIIQcgBCgCQCEIIARBNGooAgBBfcEQCAEIAMgCCAFIAcgBkEAECQMBQsgBCADIAggBSAHIAZBARAkDAQLIAgNAQsgBEEIaiAGNgIAIAQgBjYCBCAEQQEAgAMAgsgBEEBOgAeCyAEQQAAgALAkAgBCgCAARAIAQoAgQhAyAAQQxqIAIgBEEIaigCACICazYCACAAQQhqIAEgAmoAgAgACADNgIEIAAgATYCAAwBCyAAQQAAgALIARBABqJAAPCyAHIAYgAyAGEHsACQEAQ/IwBBsAFrIgEkAAJAAkAgAARAIAAoAgANASAAQQAAgAgAUGIAWoiAiAAQRBqKQIANwMAIAFBgAFqIgMgAEEIaikCADcDACABQZABaiIEIABBGGopAgAAwAgAUGYAWoiBSAAQSBqKQIANwMAIAFBoAFqIgYgAEEoaikCADcDACABQagBaiIHIABBMGopAgAAwAgAUEQaiIIIAFBhAFqKQIANwMAIAFBGGoiCSABQYwBaikCADcDACABQSBqIgogAUGUAWopAgAAwAgAUEoaiILIAFBnAFqKQIANwMAIAFBMGoiDCABQaQBaikCADcDACABQThqIggAUGsAWooAgAAgAgASAAKQIANwNIAEgASkCfDcDCCAAEBUgAUHwAGogDSgCADYCACABQegAaiAMKQMANwMAIAFBABqIAspAwAAwAgAUHYAGogCikDADcDACABQdAAaiAJKQMANwMAIAFByABqIAgpAwAAwAgASABKQMINwNAIAFB+ABqIAFBQGsQOkEQQQQngEiAEUNAiAAQQAAgAgACABKQNNwIEIABBDGogAykDADcCACAAQRRqIAIpAwAAgAgAEEcaiAEKQMANwIAIABBJGogBSkDADcCACAAQSxqIAYpAwAAgAgAEEaiAHKQMANwIAIAFBsAFqJAAgAALEKBAAsQrgEACEQQQQswEACcEAQR/IAAgARCASECAkACQAJAIAAQsAENACAAKAIAIQMCQCAAEKUBRQRAIAEgAohASAAIAMQuwEiAEHAscAAKAIARwBIAIoAgRBAFBAcNAkGscAAIAEAgAgACABIAIQhgEPCyABIANqQRBqIQAMAgsgAGAAkEQCAAEDUMAQsgAEEMaigCACIEIABBCGooAgAiBUcEQCAFIAQAgwgBCAFNgIIDAELQaiuwABBqKAACgCAEF+IANBAZcTYCAAsgAhCiAQRAIAAgASACEIYBDAILAkBBxLHAACgCACACRwRAIAJBwLHAACgCAEcNAUHAscAAIAAAgBBuLHAAEGscAAKAIAIAFqIgEAgAgACABEJQBDwtBxLHAACAANgIAQbyxwABBvLHAACgCACABaiIBNgIAIAAgAUEBcjYCBCAAQcCxwAAoAgBHDQFBuLHAAEEANgIAQcCxwABBADYCAALIAIQrwEiAyABaiEBAkAgAGAAkEQCACEDUMAQsgAkEMaigCACIEIAJBCGooAgAiAkcEQCACIAQAgwgBCACNgIIDAELQaiuwABBqKAACgCAEF+IANBAZcTYCAAsgACABEJQBIABBwLHAACgCAEcNAUGscAAIAEAgALDwsgAUGAAkEQCAAIAEQNALIAFBAYiAkEDdEGwrsAAaiEBAnBqKAACgCACIDQQEgAnQiAnEEQCABKAIIDAELQaiuwAAgAiADcjYCACABCyECIAEgADYCCCACIAAAgwgACABNgIMIAAgAjYCCAuYBAIDfwZ+IABBHGooAgBFBEBBAALIABBEGooAgAiAiAAQQhqKQMAIgUgASgCACIErUKAgICAgICAgASEIgaFQvPKcunjNmyACFIgdCEIkgByAAKQMAIghCeSVbsbzsAIVIgeFIgkgBULtpHzlszct+QAhSIFIAhCcrNgesfzAIVIghCIIlIgogBoUgByAFQgJIAiFIgVIgYgBUIRiYUiBXwiByAFQgJhSIFIAlCFYkgCoUiCCAGQiCJQvBhXwiBnwiCSAFQhGJhSIFQgJIAUgCEIQiSAGhSIGIAdCIIlIgdIgWFIghCEYkgCCAGQhWJIAeFIgYgCUIgiXwiBwiCIUiCUINiSAJIAZCEIkgBUiBiAFQiCJfCIFfIUiByAGQhWJIAWFIgUgCEIgiXwiBnwiCCAFQhCJIAaFQhWJhSAHQhGJhSAIQiCIhSIFpEhASAFQhmIQvAgKBgoSIkKDAgAF+IQcgAEEUaigCACEAAAgACABaikAACIGIAeFIgVCfUgBUL//fv+//gKAgYKEiJCgwIB/gyEFAkADQCAFUARAIAYgBkIBhoNCgIGChIiQoMCAfNQDQJBAALIAVIQggBUJ/fCAFgyEFIAAgCKdBAYgAWogAnFBARrQXhqKAIAIARHDQALQQEPCyABIANBCGoiAogAnEhAQwACwALQMBCHjAEEgayIEJAAgAUEUaigCACEJIAEoAgAhBQJAIAFBBGooAgAiBEDdEUEQAwBCyAHQXqQf////BcSICQQFqIgNBBEhBgJ/IAJBBkEQEEAIQMgBQwBCyAFQTxqIQIgAH////AEhCEEAIQMDQCACKAIAIAJBeGooAgAgAkFwaigCACACQWhqKAIAIAJBYGooAgAgAkFYaigCACACQVBqKAIAIAJBSGooAgAgApqampqampqIQMgAkFAayECIAhBeGoiCAACyACQURqCyAGRQAQQRqIQIDQCACKAIAIANqIQMgAkEIaiECIAZBfoiBgACwsCQAJAAkAgCUUEQCADIQIMAQsCQCAHRQAIAUoAgQNACADQRBJDQILIAMgAoiAiADSQBCyACRQAAkAgAkF/SgRAIAJBARCeASIDRQBDAMLEHMACyACQQEQswEACEBIQNBACECCyAAQQAAgggACACNgIEIAAgAzYCACAEIAAAgQgBEEYaiABQRBqKQIANwMAIARBEGogAUEIaikCADcDACAEIAEpAgAAwggBEEEakGkcAAIARBCGoQHkUEQCAEQSBqJAAPCGkksAAQTMgBEEIakHMkcAAQfCSwAAQUgALzwMCDXBfgJAIAVBfoiDSABKAIUIghqIgcgAkEQEEAIAEoAggiCmshDiAFIAEoAhAiDshECABKAIcIQsgASkDACEUAACQAJAAkAgFCACIAdqMQAAiEIBgBFBEAgCiAKIAsgCiALSxsgBhsiCSAFIAkgBUsbIQwgAiAIaiERIAkhBwJAAAgByAMRgRAQQAgCyAGGyEMIAohBwJAAkACQANAIAwgBEQCABIAUgCGoiAjYCFCAGRQCDALIAdBfoiByAFTwCIAcgCGoiCSADTwDIAQgBotAAAgAiAJaiAAEYNAAsgASAIIAqIggAhQgECEHIAZFDQgMCQsgAUEANgIcDAsLIAcgBUHggMAAEFsACyAJIANBIDAABBbAAsgByAIaiADTwBIAcgEWohEiAEIAdqIAdBAWohByAACASLQAARgACyAIIAqIAdqIQgMAgsgAyAIIAlqIgAgAyAASxsgAHQgMAAEFsACyABIAUgCGoiCDYCFAtBACEHIAYNAQsgASAHNgIcIAchCwsgCCANaiIHIANJDQALCyABIAMAhQgAEEANgIADwsgACAINgIEIABBCGogAjYCACAAQQEAgALqwQCBXBfkEBIQMCQCABKAIYIgRBJyABQRxqKAIAKAIQIgURAQANAEECIQFBMCECAkACfgJAAkACQAJAAkACQAJAIAAoAgAiAAoCAEBAQEBAQEBAgQBAQMBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBBQALIABBABGDQQLIAAQKUNBCAAQQFyZECdkEHcCgICAgNAAhAwFCHACECDAULQfIAIQIMBAtBgAhAgwDCyAAIQIMAgsgABABEBBASEBIAAhAgwCCyAAQQFyZECdkEHcCgICAgNAAhAshBEDIQEgACECCwNAIAEhBkEAIQEgAiEAAkACQAJAAkACQCAGQQFrDgMEAgABCwJAAkACQAJAAkAgBIgiKdB/wFxQQFrDgUABAECAwULIAdC/////ggyEHQfAIQBBAyEBDAcLIAdC/////ggKAgICAIIQhBHACEAQQMhAQwGCyAHQv////+PYINCgICAgDCEIQdBQAhAEEDIQEMBQsgBL/////jCDQoCAgIDAAIQhBHcACEAQQMhAQwECEwQdcAIAIgBciAUECdHZBDEiAEEKSRsgAGohACABRQCIAdCfxC/////w+DIAdCgICAgHCDhCEHQQMhAQwDCyAEQScgBREBACEDDAQLQdwAIQBBASEBDAELIAdC/////ggKAgICAEIQhBEDIQELIAQgACAFEQEARQACwsgAwuAwEGfyMAQRBrIgkkACAAQQRqKAIAIgYgACgCACIIIAGnIgpxIgdqKQAAQoCBgoSIkKDAgH+DIgFQBEBBCCEFAAgBSAHaiEHIAVBCGohBSAGIAcgCHEiBopAABCgIGChIiQoMCAfMiAVANAAsLAkAgACgCCCAGIAFpEDdiAHaiAIcSIFaiwAACIHQXKBHgBiAGKQMAQoCBgoSIkKDAgH+DeqdBAYiBWotAAAFIAcLQQFxIgdFcgAIAlBCGogAEEBIAQQDCAAQQRqKAIAIgYgACgCACIIIApxIgRqKQAAQoCBgoSIkKDAgH+DIgFQBEBBCCEFAAgBCAFaiEEIAVBCGohBSAGIAQgCHEiBGopAABCgIGChIiQoMCAfMiAVANAAsLIAYgAXqnQQNIARqIAhxIgVqLAAAQXMDQAgBikDAEKAgYKEiJCgwIB/gqnQQNIQULIAUgBmogCkEZdiIEOgAAIAVBeGogCHEgBmpBCGogBDoAACAAIAAoAgggBsAgggACAAKAIMQQFqNgIMIAYgBUEDdGsiAEFaiACNgIAIABBfGogAzYCACAJQRBqJAALgwMBACQAJAAkACQCABQQlPBEBBEEEIEJcBIAFLDQEMAgsgABALIQMMAgtBEEEIEJcBIQELQYCAfEEIQQgQlwFBFEEIEJcBakEQQQgQlwFqaFcUFaiIEQQBBEEEIEJcBQQJayICIAIgBEsbIAFrIABNDQAgAUEQIABBBGpBEEEIEJcBQXtqIABLGEIEJcBIgRqQRBBCBCXAWpBfGoQCyICRQAIAIQvQEhAAJAIAFBfoiAyACcUUEQCAAIQEMAQsgAiADakEAIAFrcRCASECQRBBCBCXASEDIAAQrwEgAkEAIAEgAiAAayADSxtqIgEgAGsiAmshAyAAEKUBRQRAIAEgAxCCASAAIAIQggEgACACECEMAQsgACgCACEAIAEgAzYCBCABIAAgAmoAgALIAEQpQENASABEKBIgJBEEEIEJcBIARqTQBIAEgBBCASEAIAEgBBCCASAAIAIgBGsiBBCCASAAIAQQIQwBCyADDwsgARCASABEKUBGgvAgEEfyMAQRBrIgMkACAAIAFHBEAgAkEIaiEEAAgAEEEagJAAnCQAJAIAAoAgAiAEGAAUEQCADQQAAgwgAEGAEEkNASAAQYCABENAiADIABBPFBgAFyOgAOIAMgAEEMdkHgAXIAAwgAyAAQQZQTxQYABcjoADUEDDAMLIAQoAgAiBSACQQRqKAIARgR/IAIgBRBAIAQoAgAFIAULIAIoAgBqIAAAAAgBCAEKAIAQQFqNgIADAMLIAMgAEE/cUGAAXIAAgAyAAQQZQcABcjoADEECDAELIAMgAEE/cUGAAXIAAgAyAAQQZQTxQYABcjoADiADIABBDHZBPFBgAFyOgANIAMgAEESdkEHcUHwAXIAAxBBAshACACQQRqKAIAIAQoAgAiBWsgAEkEQCACIAUgABBBIAQoAgAhBQsgAigCACAFaiADQQxqIAAQuQEaIAQgACAFajYCAAsiACABRwACwsgAEQaiQACQCAQd/QQEhCQJAAkAgAkUNACABIAJBAXRqIQogAEGA/gNxQQhIQsgAEH/AXEhDQJAAAgAUECaiEMIAcgASAASICaiEIIAsgASAACIBRwRAIAEgCsNAyAIIQcgDCIBIApHDQEMAwsgCCAHTwRAIAggBEsNAiADIAdqIQECQANAIAJFDQEgAkF/aiECIAEtAAAgAUEBaiEBIAHDQALQQAhCQwFCyAIIQcgDCIBIApHDQEMAwsLIAcgCBCAQALIAggBBCAQALIAZFDQAgBSAGaiEDIABB//DcSEBAACQCAFQQFqIQACfyAAIAUtAAAiAkEYdEEYdSIEQQBODQAaIAAgAYNASAFLQABIARB/wBxQQhciECIAVBAmoLIQUgASACayIBQQBIDQIgCUEBcyEJIAMgBUcNAQwCCwtBJPAAEGMmAAEGACyAJQQFxC+ICAQN/IwBBEGsiAiQAIAAoAgAhAAJAAnCQAJAIAFBgAFPBEAgAkEANgIMIAFBgBBJDQEgAUGAgARPDQIgAiABQTxQYABcjoADiACIAFBDHZBAFyOgAMIAIgAUEGdkE/cUGAAXIAABAwwDCyAAKAIIIgMgAEEEaigCAEYEfyAAIAMQQCAAKAIIBSADCyAAKAIAaiABOgAAIAAgACgCCEEBajYCCAwDCyACIAFBPFBgAFyOgANIAIgAUEGdkHAAXIAAxBAgwBCyACIAFBPFBgAFyOgAPIAIgAUEGdkE/cUGAAXIAAgAiABQQxQTxQYABcjoADSACIAFBEnZBBFBAFyOgAMQQQLIQEgAEEEaigCACAAQQhqIgQoAgAiAsgAUkEQCAAIAMgARBBIAQoAgAhAwsgACgCACADaiACQQxqIAEQuQEaIAQgASADajYCAAsgAkEQaiQAQQALQIBBXgAEELdCEEQSAhAkEgIQMCQANAAkACQCACQQFIAFqIgJBAnRBKbAAGooAgBBCQiBSAETwRAIAQgBUYNAiACIQMMAQsgAkEBaiEBCyADIAFrIQIgAyABSwBDAILCyACQQFqIQELAkACQCABQRNBEAgAUECdCEEQcMFIQMgAUEfRwRAIARBKbAAGooAgBBFXYhAwtBACEFIAFBfoiAiABTQRAIAJBIENAiACQQJQeimwABqKAIAQf///wBxIQULAkAgAyAEQeimwABqKAIAQRVIgFBfNqRQAIAAgBWshBCABQcMFIAFBwwVLGyECIANBfohAEEAIQMDQCABIAJGDQQgAyABQeinwABqLQAAaiIDIARLDQEgACABQQFqIgFHDQALIAAhAQsgAUEBcQLIAFBIEGwpsAAEFsACyACQSBBKbAABBbAAsgAkHDBUHApsAAEFsACCAQV/IABBCQhBEEEIQJBBCEDAkADQAJAAkAgAkEBdiABaiICQQJQaytwABqKAIAQQtIgUgBEEQCAEIAVGDQIgAiEDDAELIAJBAWohAQsgAyABayECIAMgAUsNAQwCCwsgAkEBaiEBCwJAAkAgAUEDTQRAIAFBAnQhBEEVIQMgAUEDRwRAIARBsKAAGooAgBBFXYhAwtBACEFIAFBfoiAiABTQRAIAJBBENAiACQQJQaytwABqKAIAQf///wBxIQULAkAgAyAEQaytwABqKAIAQRVIgFBfNqRQAIAAgBWshBCABQRUgAUEVSxshAiADQXqIQBBACEDAAgASACRgEIAMgAUGrcAAaiAAGoiAyAESwBIAAgAUEBaiIBRwACyAAIQELIAFBAXEPCyABQQRBsKbAABBbAAsgAkEEQdCmwAAQWwALIAJBFUHApsAAEFsACsCAQN/IwBBEGsiAiQAAkACfwJAAkAgAUGAAUEQCACQQAAgwgAUGAEEkNASABQYCABENAiACIAFBPFBgAFyOgAOIAIgAUEMdkHgAXIAAwgAiABQQZQTxQYABcjoADUEDDAMLIAAoAggiAyAAQQRqKAIARgR/IAAgAxBAIAAoAggFIAMLIAAoAgBqIAEAAAgACAAKAIIQQFqNgIIDAMLIAIgAUE/cUGAAXIAAgAiABQQZQcABcjoADEECDAELIAIgAUE/cUGAAXIAAgAiABQQZQTxQYABcjoADiACIAFBDHZBPFBgAFyOgANIAIgAUESdkEHcUHwAXIAAxBBAshASAAQQRqKAIAIABBCGoiBCgCACIDayABSQRAIAAgAyABEEEgBCgCACEDCyAAKAIAIANqIAJBDGogARCARogBCABIANqNgIACyACQRBqJABBAAvVAgEDfyMAQRBrIgIkAAJAAnCQCABQYABTwRAIAJBADYCDCABQYAQTwBIAIgAUE/cUGAAXIAAgAiABQQZQcABcjoADEECDAILIAAoAggiAyAAQQRqKAIARgRAIAAgAxBDIAAoAgghAwsgACADQQFqNgIIIAAoAgAgAogAToAAAwCCyABQYCABEEQCACIAFBPFBgAFyOgAPIAIgAUEGdkE/cUGAAXIAAgAiABQQxQTxQYABcjoADSACIAFBEnZBBFBAFyOgAMQQQMAQsgAiABQTxQYABcjoADiACIAFBDHZBAFyOgAMIAIgAUEGdkE/cUGAAXIAABAwshASAAQQRqKAIAIABBCGoiBCgCACIDayABSQRAIAAgAyABEEIgBCgCACEDCyAAKAIAIANqIAJBDGogARCARogBCABIANqNgIACyACQRBqJAALwIBAjAEEQayICJAACQAJ/AkACQCABQYABTwRAIAJBADYCDCABQYAQSQBIAFBgIAETwCIAIgAUE/cUGAAXIAAgAiABQQxQeABcjoADCACIAFBBnZBPFBgAFyOgANQQMMAwsgACgCCCIDIABBBGooAgBGBEAgACADEEMgACgCCCEDCyAAIANBAWoAgggACgCACADaiABOgAADAMLIAIgAUE/cUGAAXIAAgAiABQQZQcABcjoADEECDAELIAIgAUE/cUGAAXIAAgAiABQQZQTxQYABcjoADiACIAFBDHZBPFBgAFyOgANIAIgAUESdkEHcUHwAXIAAxBBAshASAAQQRqKAIAIABBCGoiBCgCACIDayABSQRAIAAgAyABEEIgBCgCACEDCyAAKAIAIANqIAJBDGogARCARogBCABIANqNgIACyACQRBqJAALtgIBBCQCACQQNBEAgACEDDAELIABBACAAaEDcSIEaiEFIAQEQCAAIQMgASEGAAgAyAGLQAAOgAAIAZBAWohBiADQQFqIgMgBUkNAAsLIAUgAiAEayIIQXxxIgdqIQMCQCABIARqIgRBAEEQCAHQQFIDQEgBEEDdCICQRhxIQkgBEFcSIGQQRqIQFBACACaEYcSECIAYoAgAhBgNAIAUgBiAJdiABKAIAIgYgAnRyNgIAIAFBBGohASAFQQRqIgUgAkNAAsMAQsgBEBSAAIAQhAQNAIAUgASgCADYCACABQQRqIQEgBUEEaiIFIANJDQALCyAIQQNxIQIgBCAHaiEBCyACBEAgAiADaiECAAgAyABLQAAOgAAIAFBAWohASADQQFqIgMgAkkNAAsLIAALvgIBBXCQAJAAkACQCACQQNqQXxxIAJrIgRFDQAgAyAEIAQgAsbIgRFDQAgAUH/AXEhBEBIQYDQCACIAVqLQAAIAdGDQQgBCAFQQFqIgVHDQALIAQgAFaiIGSwCDAELIANBeGohBkEAIQQLIAFB/wFxQYGChAhsIQUDQCACIARqIgcoAgAgBXMiCEF/cyAIQf/+dqcSAHQQRqKAIAIAVzIgdBfMgBH//ftanFyQYCBgoRcUUEQCAEQQhqIgQgBkNAQsLIAQgANACAEIAMQtAEACwJAIAMgBEYNACAEIANrIQMgAiAEaiECQQAhBSABQfBcSEBAAgASACIAVqLQAARwRAIAMgBUEBaiIFagBDAILCyAEIAVqIQVBASEGDAELQQAhBgsgACAFNgIEIAAgBjYCAAu+AgIFfwF+IwBBMGsiBCQAQSchAgJAIABCkMAVARAIAAhBwwBCwNAIARBCWogAmoiAFaiAAIABCkMAgCIHQpDOAHpyIFQf//AFBABuIgZBAXRBpZTAAGovAAAAAAgAF+aiAFIAZBABsaH//wNxQQFQaWUwABqLwAAOwAAIAJBfGohAiAAQv/ByWIAchAAACwsgBciAHjAEsEQCACQXqIgIgBEEJamogBciAyADQf//AFBABuIgNBABsaH//wNxQQFQaWUwABqLwAAOwAACwJAIANBCkEQCACQXqIgIgBEEJamogAEBdEGllMAAaiAADsAAAwBCyACQXqIgIgBEEJamogAEwajoAAAsgAUGAkAAQQAgBEEJaiACakEnIAJrEBcgBEEwaiQACECAQN/IwBBgAFrIgQkAAJAAkACQAJAIAEoAgAiAkEQcUUEQCACQSBxDQEgADUCACABEDIhAAwECyAAKAIAIQBBACECAAgAiAEakH/AGpBMEHXACAAQQxIgNBCkkbIANqOgAAIAJBfohAiAAQQLIABBBHYhAAACyACQYABaiIAQYEBTwBIAFBoTAAEECIAIgBGpBgAFqQQAgAmsQFyEADAMLIAAoAgAhAEEAIQIDQCACIARqQfAakEwQTcgAEEPcSIDQQpJGyADajoAACACQXqIQIgAEEPSyAAQQRIQANAAsgAkGAAWoiAEGBAUNASABQaOUwABBAiACIARqQYABakEAIAJrEBchAAwCCyAAQYABELQBAAsgAEGAARCAQALIARBgAFqJAAgAAunAgEFfyAAQgAAhAgAAJ/QQAgAUGAAkkNABpBHyABQf///wdLDQAaIAFBBiABQQhZyICaZBAXEgAkEBdGtBPmoLIgIAhwgAkECdEGsMAAaiEDIAAhBAJAAkACQAJAQayuwAAoAgAiBUEBIAJIgZxBEAgAygCACEDIAIQkwEhAiADEKBIAFHDQEgAyECDAILQayuwAAgBSAGcjYCACADIAAAgAMAwsgASACdCEFAAgAyAFQRQQRxakEQaiIGKAIAIgJFDQIgBUEBdCEFIAIiAxCvASABRwACwsgAigCCCIBIAQAgwgAiAENgIIIAQgAjYCDCAEIAEAgggAEEANgIYDwsgBiAANgIACyAAIAMAhggBCAENgIIIAQgBDYCDAuAgEFfyAAKAIYIQQCQAJAIAAgACgCDEYEQCAAQRRBECAAQRRqIgEoAgAiAxtqKAIAIgINAUEAIQEMAgsgACgCCCICIAAoAgwiATYCDCABIAIAggMAQsgASAAQRBqIAMbIQMDQCADIQUgAiIBQRRqIgMoAgAiAkUEQCABQRBqIQMgASgCECECCyACDQALIAVBADYCAAsCQCAERQAAkAgACAAKAIcQQJQbiwwABqIgIoAgBHBEAgBEEQQRQgBCgCECAARhtqIAEAgAgAQBDAILIAIgATYCACABDQBBrKAAEGsrsAAKAIAQXgACgCHHdxNgIADwsgASAENgIYIAAoAhAiAgRAIAEgAjYCECACIAEAhgLIABBFGooAgAiAEUNACABQRRqIAAAgAgACABNgIYCwvAAgEBfyMAQTBrIgIkAAJ/AkACQAJAAkAgACgCAEEBawDAQIDAAsgAkEcakEBNgIAIAJCATcCDCACQYSKwAAAgggAkEKNgIkIAIgAEEEajYCLCACIAJBIGoAhggAiACQSxqNgIgIAEgAkEIahBcDAMLIAJBHGpBADYCACACQfCIwAAAhggAkIBNwIMIAJBInAADYCCCABIAJBCGoQXAwCCyACQRxqQQEAgAgAkIBNwIMIAJBwInAADYCCCACQQoAiQgAiAAQQRqNgIsIAIgAkEgajYCGCACIAJBLGoAiAgASACQQhqEFwMAQsgAkEcakEBNgIAIAJCATcCDCACQaCJwAAAgggAkEKNgIkIAIgAEEEajYCLCACIAJBIGoAhggAiACQSxqNgIgIAEgAkEIahBcCyACQTBqJAALbwEMfHYscAAKAIAIgJFBEBBLHAAEH/HzYCAEEADwtBLHAACEGAAgAiIBKAIIIQIgASgCBCEDIAEoAgAhBCABQQxqKAIAGiABIQYgBUEBaiEFIAINAAtBLHAACAFQffIAVB/xLGzYCACAICsCAgR/AXjAEEwayICJAAgAUEEaiEEIAEoAgRFBEAgASgCACEDIAJBEGoiBUEANgIAIAJCATcDCCACIAJBCGoAhQgAkEoaiADQRBqKQIANwMAIAJBIGogAEIaikCADcDACACIAMpAgAAxggAkEUakGAjsAAIAJBGGoQHhogBEEIaiAFKAIANgIAIAQgAikDCDcCAAsgAkEgaiIDIARBCGooAgAAgAgAUEMakEANgIAIAQpAgAhBiABQgEAgQgAiAGNwMYQQxBBBCeASIBRQRAQQxBBBCzAQALIAEgAikDGDcCACABQQhqIAMoAgAAgAgAEHojAANgIEIAAgATYCACACQTBqJAALAEBAnjAEEwayIFJAACQCABBEAgASgCACIGQXGDQEgASAGQQFqNgIAIAUgBDYCFCAFQRhqIAFBBGogAiADIAVBFGoQGyAFQRBqIAVBKGooAgAAgAgBSAFQSBqKQMANwMIIAUoAhwhBCAFKAIYIQYgAwRAIAIQFQsgASABKAIAQXqNgIAAngBkUEQEEAIQNBAAwBCyAFQSRqIAVBEGooAgAAgAgBSAENgIYIAUgBSkDCDcCHEEBIQMgBUEYahBNCyEBIAAgAzYCCCAAIAEAgQgACAENgIAIAVBMGokAALEKBAAsQrgEACUCAQN/IwBBIGsiAiQAIAJBIbAAEEGQfaGwABBJxAGNgIUIAJBITYCGCACQQhqIAJBFGogAkEYahBtIAIoAgwhAyACKAIIRQRAIAIoAhgiBEEkTwRAIAQQAAsgACADNgIAIAAgASkCADcCBCAAQTRqIAFBMGooAgAAgAgAEEsaiABQShqKQIANwIAIABBJGogAUEgaikCADcCACAAQRxqIAFBGGopAgAAgAgAEEUaiABQRBqKQIANwIAIABBDGogAUEIaikCADcCACACKAIUIgBBJEEQCAAEAALIAJBIGokAALIAIgAzYCHEGrgcAAQSsgAkEcakHogcAAQaCHwAAQUgALgEAAkAgAEEgSQAAkACfEBIABB/wBJDQAaIABBgIAESQBAkAgAEGAgAhPBEAgAEGXNqQbXbKkgAEHiiRqQeILSXINBCAAQZ+odGpBnxhJIABBuJakEOSXINBCAAQXxQZwCkYNBCAAQWBxQeDNCkcNAQwECyAAQbugwABBKkGPocAAQcABQc+iwABBtgMQKQLQQAgAEHHkXVqQQdJDQAaIABBgICfpBINSQsPCyAAQZybwABBKEHsmAAQaACQYyewABBrwIQKQLQQALwwEBAgACgCBCIDIAAoAgBGBEBBgIDEAALIAAgAF/aiIBNgIEIAEtAAAiAUEYdEEYdSICQXMBHgACADQXqIgEAgQgAkE/cQJ/IAEtAAAiAUEYdEEYdSICQUBOBEAgAUEfcQwBCyAAIANBfWoiATYCBCACQTxAngASAACIBQRhQRhIgJBQEEQCABQQxDAELIAAgAFaiIANgIEIAJBPEgACAAEEHcUEGdHILQQZcgtBBnRyBSABCwvTAQEFfyMAQSBrIgIkAAJAIAFBAWoiAyABSQAQQQhBCAAQQRqKAIAIgVBAXQiASADIAEgAsbIgFBBCABQQRLGyIBQf////AcSABRkECdCEDIAFBBHQhBgJAIAVFBEBBACEEDAELIAIgBUEEdDYCFCACIAAoAgAAhALIAIgBDYCGCACIAYgAyACQRBqEEsgAigCAARAIAJBCGooAgAiAEUNASACKAIEIAAQswEACyACKAIEIQMgAEEEaiABNgIAIAAgAzYCACACQSBqJAAPCxBzAAvTAQEFfyMAQSBrIgIkAAJAIAFBAWoiAyABSQAQQQhBCAAQQRqKAIAIgVBAXQiASADIAEgAsbIgFBBCABQQRLGyIBQf////DcSABRkECdCEDIAFBAnQhBgJAIAVFBEBBACEEDAELIAIgBUECdDYCFCACIAAoAgAAhALIAIgBDYCGCACIAYgAyACQRBqEEsgAigCAARAIAJBCGooAgAiAEUNASACKAIEIAAQswEACyACKAIEIQMgAEEEaiABNgIAIAAgAzYCACACQSBqJAAPCxBzAAuAQEEfyAAKAIAIgEgACgCBEYEQEGAgMQADwsgACABQQFqNgIAIAEtAAAiAEYdEEYdUF/TAR/IAAgAUECajYCACABLQABQTxIQIgAEfcSEEIANBwFNBEAgBEEGdCACcgLIAAgAUEDajYCACABLQACQTxIAJBBnRyIQIgAHwAUkEQCACIARBDHRyDwsgACABQQRqNgIAIARBEnRBgIDwAHEgASAAE/cSACQQZcnIFIAMLCBAQN/IwBBIGsiAiQAAkAgAUEBaiIDIAFJDQAgAEEEaigCACIBQQFIgQgAyAEIANLGyIDQQggAEISxshAyACIAEEfyACIAEAhQgAiAAKAIANgIQQQEFQQALNgIYIAIgAEBIAJBEGoQSyACKAIABEAgAkEIaigCACIARQBIAIoAgQgABCzAQALIAIoAgQhASAAQQRqIAMAgAgACABNgIAIAJBIGokAALEHMACBAQJ/IwBBIGsiAyQAAkAgASACaiICIAFJDQAgAEEEaigCACIBQQFIgQgAiAEIAJLGyICQQggAkEISxshBCADIAEEfyADIAEAhQgAyAAKAIANgIQQQEFQQALNgIYIAMgBEEBIANBEGoQSyADKAIABEAgAEIaigCACIARQBIAMoAgQgABCzAQALIAMoAgQhASAAQQRqIAQAgAgACABNgIAIANBIGokAALEHMACBAQJ/IwBBIGsiAyQAAkAgASACaiICIAFJDQAgAEEEaigCACIBQQFIgQgAiAEIAJLGyICQQggAkEISxshBCADIAEEfyADIAEAhQgAyAAKAIANgIQQQEFQQALNgIYIAMgBCADQRBqEEogAygCAARAIANBCGooAgAiAEUNASADKAIEIAAQswEACyADKAIEIQEgAEEEaiAENgIAIAAgATYCACADQSBqJAAPCxBzAAutAQEDfyMAQSBrIgIkAAJAIAFBAWoiAyABSQAIABBBGooAgAiAUEBdCIEIAMgBCADSxsiAEIIANBCEsbIQMgAiABBHgAiABNgIUIAIgACgCADYCEEEBBUEACzYCGCACIAMgAkEQahBKIAIoAgAEQCACQQhqKAIAIgBFDQEgAigCBCAAELMBAAsgAigCBCEBIABBBGogAzYCACAAIAEAgAgAkEgaiQADwsQcwALwEBAjAEEgayIFJABBjKAAEGMrsAAKAIAIgdBAWoAgBBLHAAEHsscAAKAIAQQFqIgYAgACQAJAIAdBAEggBkECSINACAFIAQABggBSADNgIUIAUgAjYCEEGArsAAKAIAIgJBfwNAEGArsAAIAJBAWoiAjYCAEGArsAAQYiuwAAoAgAiAwR/QYSuwAAoAgAgBSAAIAEoAhARAAAgBSAFKQMANwMIIAVBCGogAygCFBEAAEGArsAAKAIABSACCF/ajYCACAGQQFLDQAgBABCwALIwBBEGsiAiQAIAIgATYCDCACIAAAggACBAQN/AkAgAUEPTQRAIAAhAgwBCyAAQQAgAGtBAEiBGohAyAEBEAgACECAAgAkH/AToAACACQQFqIgIgAkNAAsLIAMgASAEayIBQXxxIgRqIQIgBEEBTgRAAAgAF/NgIAIANBBGoiAyACSQACwsgAUEDcSEBCyABBEAgASACaiEBAAgAkH/AToAACACQQFqIgIgAUkNAAsLIAALrAEBAjAEEQayIDJAACQAJAIAEEQCABKAIAIgJBfYNASABIAJBAWoAgAgAyABQQRqEGEgASABKAIAQXqNgIAIAMoAgAhAQJAIAMoAgQiAiADKAIIIgRNBEAgASECDAELIARFBEBBASECIAEQFQwBCyABIAJBASAEEJkBIgJFDQMLIAAgBDYCBCAAIAIAgAgAEQaiQADwsQrQEACxCuAQALIARBARCzAQALrAEBAjAEEQayIDJAACQAJAIAEEQCABKAIAIgJBfYNASABIAJBAWoAgAgAyABQRBqEGEgASABKAIAQXqNgIAIAMoAgAhAQJAIAMoAgQiAiADKAIIIgRNBEAgASECDAELIARFBEBBASECIAEQFQwBCyABIAJBASAEEJkBIgJFDQMLIAAgBDYCBCAAIAIAgAgAEQaiQADwsQrQEACxCuAQALIARBARCzAQALrAEBAjAEEQayIDJAACQAJAIAEEQCABKAIAIgJBfYNASABIAJBAWoAgAgAyABQSxqEGEgASABKAIAQXqNgIAIAMoAgAhAQJAIAMoAgQiAiADKAIIIgRNBEAgASECDAELIARFBEBBASECIAEQFQwBCyABIAJBASAEEJkBIgJFDQMLIAAgBDYCBCAAIAIAgAgAEQaiQADwsQrQEACxCuAQALIARBARCzAQALrAEBAjAEEwayICJAAgAUEEaiEDIAEoAgRFBEAgASgCACEBIAJBEGoiBEEANgIAIAJCATcDCCACIAJBCGoAhQgAkEoaiABQRBqKQIANwMAIAJBIGogAUEIaikCADcDACACIAEpAgAAxggAkEUakGAjsAAIAJBGGoQHhogAEIaiAEKAIANgIAIAMgAikDCDcCAAsgAEHojAANgIEIAAgAzYCACACQTBqJAALkAEBAnCQAJ/AkACQAJAAnBASIDIAFBAEgNABogAigCCEUNAiACKAIEIgQNASABDQNBAQwECyEDQQAhAQwECyACKAIAIARBASABEJkBDAILIAENAEEBDAELIAFBARCeAQsiAgRAIAAgAjYCBEEAIQMMAQsgACABNgIEQQEhAQsgACADNgIAIABBCGogATYCAAunAQECfwJAAkACQAJAAkACQAJAAngAgRAQQEiBCABQQBIDQEaIAMoAghFDQMgAygCBCIFDQIgAQEDAYLIAAgATYCBEEBCyEEQQAhAQwGCyADKAIAIAUgAiABEJkBIgNFDQIMBAsgAUUNAgsgASACEJBIgMNAgsgACABNgIEIAIhAQwCCyACIQMLIAAgAzYCBEEAIQQLIAAgBDYCACAAQQhqIAEAgALlwEBAXjAEEQayIGJAAgAQRAIAYgASADIAQgBSACKAIQEQYAIAYoAgAhAQJAIAYoAgQiAyAGKAIIIgJNBEAgASEDDAELIANBAnQhAyACQQJIgQEQCABIANBBCAEEJkBIgMNASAEQQQQswEACEEIQMgARAVCyAAIAIAgQgACADNgIAIAZBEGokAALQciMwABBMBCsAQALjAEBAnjAEFAaiIBJAAgAUEANgIIIAFCATcDACABQRBqIAEQfCAAIAFBEGoQNkUEQCABKAIAIAEoAggQBCABKAIEBEAgASgCABAVCwJAIAAoAgBBAUYNACAAQQhqKAIARQAIAAoAgQQFQsgAUFAayQADwtBIfAAEEIAFBOGpBIjAAEHgiMAAEFIACYBAQF/IwBBQGoiAiQAIAAoAgAhACACQgAAzggAkEaiAAEAkgAkEcakEBNgIAIAIgAigCPCIANgIwIAIgADYCLCACIAIoAjgAiggAkEiNgIkIAJCAjcCDCACQYSNwAAAgggAiACQShqNgIgIAIgAkEgajYCGCABIAJBCGoQXCACKAIsBEAgAigCKBAVCyACQUBrJAALewEHfwJAIAAEQCAAKAIADQEgAEEANgIAIAAoAgghAiAAKAIMIAAoAhQhBCAAKAIYIQUgACgCMCEGIAAoAjQhByAAKAIEIQEgABAVIAFBJEEQCABEAALBEAgAhAVCyAFBEAgBBAVCyAHBEAgBhAVCwLEKBAAsQrgEACBAQJ/IwBBEGsiAyQAIABBFGooAgAhBAJAAnCQAJAIABBBGooAgAOAgABAwsgBACQQAhAEGYjsAADAELIAQNASAAKAIAIgQoAgQhACAEKAIACyEEIAMgADYCBCADIAQAgAgAGckMAAIAEoAgggAiABLQAQEEQACyADQQAAgQgAyAANgIAIANBiJDAACABKAIIIAIgASAEBBEAAtoAQZ/AkAgAARAIAAoAgANASAAQQAAgAgACgCBCEBIAAoAgggACgCECEDIAAoAhQhBCAAKAIsIQUgACgCMCEGIAAQFQRAIAEQFQsgBARAIAMQFQsgBgRAIAUQFQsPCxCtAQALEKBAAtAQF/IwBBQGoiBSQAIAUgATYCDCAFIAAAgggBSADNgIUIAUgAjYCECAFQSxqQQIAgAgBUEakENgIAIAVCAjcCHCAFQZCUwAAAhggBUENgIIAUgBUEwajYCKCAFIAVBEGoAjggBSAFQQhqNgIwIAVBGGogBBBAAtAQF/IAAtAAQhASAALQAFBEAgAUH/AXEhASAAAnBASABDQAaIAAoAgAiASAAEEEcUUEQCABKAIYQaGUwABBAiABQRxqKAIAKAIMEQMADAELIAEoAhhBoJTAAEEBIAFBHGooAgAoAgwRAwALIgEAAQLIAFB/wFxQQBHCCAXBfiMAQRBrIgAkAEGQrsAAKQMAUARAIABCAjcDCCAAQgEAwAgACkDACEBQaCuwAAgACkDCDcDAEGYrsAAIAEAwBBkKAAEIBNwMACyAAQRBqJABBmKAAAtAQF/QThBBBCeASIKRQRAQThBBBCzAQALIAogCTYCNCAKIAkAjAgCiAINgIsIAogBzYCKCAKIAYAiQgCiAFNgIgIAogBDYCHCAKIAMAhggCiADNgIUIAogAjYCECAKIAEAgwgCiABNgIIIAogADYCBCAKQQAAgAgCgtAQN/IAAgABCASIAQQgQlwEgAGsiAhCASEAQbyxwAAgASACayIBNgIAQcSxwAAgADYCACAAIAFBAXIAgRBCEEIEJcBIQJBFEEIEJcBIQNBEEEIEJcBIQQgACABELoBIAQgAyACQQhramoAgRBLHAAEGAgIABNgIACBBHjAEEgayICJABBASEDAkAgACABEDMNACABQRxqKAIAIQQgASgCGCACQRxqQQAAgAgAkGAkAANgIYIAJCATcCDCACQYSTwAAAgggBCACQQhqEBNACAAQQRqIAEQMyEDCyACQSBqJAAgAwtvAQF/IwBBMGsiAiQAIAIgATYCBCACIAAAgAgAkEcakECNgIAIAJBLGpBAzYCACACQgIAgwgAkGklsAANgIIIAJBAzYCJCACIAJBIGoAhggAiACQQRqNgIoIAIgAjYCICACQQhqQdSWwAAQdAALbwEBfyMAQTBrIgIkACACIAEAgQgAiAANgIAIAJBHGpBAjYCACACQSxqQQMAgAgAkICNwIMIAJBuJfAADYCCCACQQMAiQgAiACQSBqNgIYIAIgAkEEajYCKCACIAIAiAgAkEIakHIlAAEHQACBAXjAEEwayICJAAgAiABNgIEIAIgADYCACACQRxqQQIAgAgAkEsakEDNgIAIAJCAjcCDCACQfSWwAAAgggAkEDNgIkIAIgAkEgajYCGCACIAJBBGoAiggAiACNgIgIAJBCGpBhJfAABBAAtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAAAgAgAEcakECNgIAIANBLGpBAzYCACADQgIAgwgAHAkAANgIIIANBAzYCJCADIANBIGoAhggAyADNgIoIAMgAEEajYCICADQQhqIAIQdAALVgECfyMAQSBrIgIkACAAQRxqKAIAIQMgACgCGCACQRhqIAFBEGopAgAAwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCADIAJBCGoQHiACQSBqJAALWQEBfyMAQSBrIgIkACACIAAoAgAAgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgAAwggAkEEakGYisAAIAJBCGoQHiACQSBqJAALWQEBfyMAQSBrIgIkACACIAAoAgAAgQgAkEYaiABQRBqKQIANwMAIAJBEGogAUEIaikCADcDACACIAEpAgAAwggAkEEakGAjsAAIAJBCGoQHiACQSBqJAALZwAjAEEwayIBJABBKAACAAARAIAFBHGpBATYCACABQgIAgwgAUHjsAANgIIIAFBAzYCJCABIAAAiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQZyPwAAQdAALIAFBMGokAAtZAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgAAwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqQbSRwAAgAkEIahAeIAJBIGokAAtnAQJ/IAEoAgAhAwJAAkACQCABQQhqKAIAIgFFBEBBASECDAELIAFBfwNASABQQEQngEiAkUNAgsgAiADIAEQuQEhAiAAIAEAgggACABNgIEIAAgAjYCAALEHMACyABQQEQswEACYBAXjAEEgayICJAAgAiAANgIEIAJBGGogAUEQaikCADcDACACQRBqIAFBCGopAgAAwAgAiABKQIANwMIIAJBBGpBmIrAACACQQhqEBgAkEgaiQACYBAXCQCAABEAgACgCAABIABBfzYCACAAQQhqIgMoAgAEQCAAKAIEEBULIAAgATYCBCAAQQAAgAgAEEMaiACNgIAIAMgAjYCAALEKBAAsQrgEACYBAXCQCAABEAgACgCAABIABBfzYCACAAQRRqIgMoAgAEQCAAKAIQEBULIAAgATYCECAAQQAAgAgAEEYaiACNgIAIAMgAjYCAALEKBAAsQrgEACYBAXCQCAABEAgACgCAABIABBfzYCACAAQTBqIgMoAgAEQCAAKAIsEBULIAAgATYCLCAAQQAAgAgAEEaiACNgIAIAMgAjYCAALEKBAAsQrgEACYBAXjAEEQayIFJAAgASgCACACKAIAIAMoAgAgBCgCABAIIQEgBUEIahCDASAFKAIMIQIgACAFKAIIIgNBAEcAgAgACACIAEgAxsAgQgBUEQaiQACBAngACgCACIDQQRqKAIAIANBCGoiBCgCACIAayACSQRAIAMgACACEEEgBCgCACEACyADKAIAIABqIAEgAhCARogBCAAIAJqNgIAQQALTwECfyAAKAIAIgNBBGooAgAgAEIaiIEKAIAIgBrIAJJBEAgAyAAIAIQQiAEKAIAIQALIAMoAgAgAGogASACELkBGiAEIAAgAmoAgBBAAtRAQF/IwBBEGsiBCQAIAEoAgAgAigCACADKAIAEAchASAEQQhqEIMBIAQoAgwhAiAAIAQoAggiAEARzYCACAAIAIgASADGzYCBCAEQRBqJAALSgECfyAAQQRqKAIAIABBCGoiBCgCACIDayACSQRAIAAgAyACEEEgBCgCACEDCyAAKAIAIANqIAEgAhCARogBCACIANqNgIAQQALPwEBfyMAQSBrIgAkACAAQRxqQQAAgAgAEGwkMAANgIYIABCATcCDCAAQcyQwAAAgggAEEIakGkkcAAEHQACMBACQCACRQAAAgACAACIEIAEtAAAiBUYEQCAAQQFqIQAgAUEBaiEBIAJBfoiAgBDAILCyAEIAVrIQMLIAMLTAECfyMAQRBrIgMkACABKAIAIAIoAgAQAyEBIANBCGoQgwEgAygCDCECIAAgAygCCCIEQQBHNgIAIAAgAiABIAQbNgIEIANBEGokAAtLAAJAAngAUGAgMQARwRAQQEgACgCGCABIABBHGooAgAoAhARAQANARoLIAINAUEACwLIAAoAhggAiADIABBHGooAgAoAgwRAwALRwEBfyMAQSBrIgIkACACQRRqQQAAgAgAkGAkAANgIQIAJCATcCBCACQSsAhwgAiAANgIYIAIgAkEYajYCACACIAEQdAALRgECfyABKAIEIQIgASgCACEDQQhBBBCeASIBRQRAQQhBBBCzAQALIAEgAjYCBCABIAMAgAgAEHjAANgIEIAAgATYCAAsAQF/IAFBEHZAACECIABBADYCCCAAQQAgAUGAgHxxIAJBfYiARsAgQgAEEAIAJBEHQgARsAgALZAEDfyMAQRBrIgEkACAAKAIMIgJFBEBBmIAAEHIjAAEGACyAAKAIIIgNFBEBBmIAAEHYjAAEGACyABIAIAgggASAANgIEIAEgAzYCACABKAIAIAEoAgQgASgCCBBQAAs/AQF/IwBBIGsiACQAIABBHGpBADYCACAAQcyRwAAAhggAEIBNwIMIABBjJLAADYCCCAAQQhqQZSSwAAQdAALPgEBfyMAQSBrIgIkACACQQEABggAiABNgIUIAIgADYCECACQfyTwAAAgwgAkGAkAANgIIIAJBCGoQcgALKwACQCAAQXxLDQAgAEUEQEEEDwsgACAAQXJQQJEJBIgBFDQAgAALAAsiACMAQRBrIgAkACAAQQhqIAEQfSAAQQhqEFMgAEEQaiQACysAAkAgAARAIAAoAgANASAAQQAAgAgAEEcaiABNgIADwsQrQEACxCuAQALKwACQCAABEAgACgCAABIABBADYCACAAQSBqIAEAgAPCxCtAQALEKBAAsrAAJAIAAEQCAAKAIADQEgAEEANgIAIABBJGogATYCAALEKBAAsQrgEACysAAkAgAARAIAAoAgANASAAQQAAgAgAEEoaiABNgIADwsQrQEACxCuAQALQAEBfyMAQRBrIgQkACAEIAMAgwgBCACNgIIIAQgATYCBCAEIAAAgAgBCgCACAEKAIEIAQoAgggBCgCDBATAAsACAAQQMACAgAEKAgICAgAQAgAgACABNgIYIABBADYCECAAQQAAgggAEEcakHEhAANgIACzUBAXgASgCGEHDjsAAQQsgAUEcaigCACgCDBEDACECIABBADoABSAAIAIAAQgACABNgIACyUAAkAgAARAIAAoAgBBfYNASAAQRxqKAIADwsQrQEACxCuAQALJQACQCAABEAgACgCAEF/RgBIABBIGooAgAPCxCtAQALEKBAAslAAJAIAAEQCAAKAIAQXGDQEgAEEkaigCAALEKBAAsQrgEACyUAAkAgAARAIAAoAgBBfYNASAAQShqKAIADwsQrQEACxCuAQALJwAgACAAKAIEQQFxIAFyQQJyNgIEIAAgAWoiACAAKAIEQQFyNgIECzoBAnBKAACAACEBQdytwABBADoAAEHgrcAAKAIAIQJBKAAEEANgIAIAAgAjYCBCAAIAEAgALIAEBfwJAIAAoAgQiAUUNACAAQQhqKAIARQAIAEQFQsLHwACQCABQXxNBEAgACABQQQgAhCZASIADQELAAsgAAsjACACIAIoAgRBfnEAgQgACABQQFyNgIEIAAgAWogATYCAAslACAARQRAQciMwABBMBCsAQALIAAgAiADIAQgBSABKAIQEQoACyMAIABFBEBByIzAAEEwEKwBAAsgACACIAMgBCABKAIQEQgACyMAIABFBEBByIzAAEEwEKwBAAsgACACIAMgBCABKAIQEQcACyMAIABFBEBByIzAAEEwEKwBAAsgACACIAMgBCABKAIQERUACyMAIABFBEBByIzAAEEwEKwBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBByIzAAEEwEKwBAAsgACACIAMgBCABKAIQERQACxAIAAgAUEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsUACAAQQRqKAIABEAgACgCABAVCwshACAARQRAQciMwABBMBCsAQALIAAgAiADIAEoAhARBAALHwAgAEUEQEHIjMAAQTAQrAEACyAAIAIgASgCEBEBAAsZAQF/IAAoAhAiAQR/IAEFIABBFGooAgALCxkAIAAoAgAiACgCACAAQQhqKAIAIAEQtwELEgBBAEEZIABBAXZrIABBHYbCxYAIAAgAUEBcjYCBCAAIAFqIAEAgALHAAgASgCGEHgpsAAQQUgAUEcaigCACgCDBEDAAsTACAAKAIAIgBBJEEQCAAEAALCxAAIAAgAWpBfpBACABaELFAAgACgCACAAQQhqKAIAIAEQtwELDAAgACABIAIgAxAYCwsAIAEEQCAAEBULCwAIABBAXQiAEEAIABrcgsUACAAKAIAIAEgACgCBCgCDBEBAAsRACAAKAIAIAAoAgQgARCAQsIACAAIAEQJwsWAEHgrcAAIAAAgBBKAAEEBOgAACwAIAAoAgAgARAuQQALEwAgAEHjAANgIEIAAgATYCAAsNACAALQAEQQJxQQFCxAAIAEgACgCACAAKAIEEBYLCgBBACAAayAAcQsLACAALQAEQQNxRQsMACAAIAFBAIAgQLDQAgACgCACAAKAIEagsNACAAKAIAIAEQLEACwAIAAoAgAaAAMAAsACwsAIAAAgAgARAyCwsAIAAjAGokACMACwkAIAAgARAKAAsNAEGUjcAAQRsQrAEACwAQa+NwABBzwAQrAEACwoAIAAoAgRBeHELCgAgACgCBEEBcQsKACAAKAIMQQFxCwoAIAAoAgxBAXYLGQAgACABQfytwAAoAgAiAEEjIAAbEQAAAAsJACAAIAEQWAALCQAgACABEFoACwkAIAAgARBZAAsKACACIAAgARAWCwoAIAAgASACEGwLCgAgACABIAIQMAsHACAAIAFqCwcAIAAgAWsLBwAgAEEIagsHACAAQXhqCwAQovkXyuI/XuHLDQBC/LTdYySlWfwsNAEKksbTUvrpMMACwMAAQsLiBAEGAgMAACAtLJcRjLENWRkNzFkNWZiMGVjNWEYTNhOWUYzIYjIxMjdiYTQMWNlNTIvbGlicmFyeSjbJlLNyYyzdHIvcGFdGVybiycwAAABAATwAAAIwFAAAhAAAAAAAQAEAAACYBQAAFAAAAAAAEABPAAAAmAUAACEAAABjYWxsZWQgYEwdGlvbjodWcmFwKClgIGuIGEgYEvbmVgIHZhbHVlYFsbGVkIGBSZXNbHQOnVudJhcCgpYCBvbiBhbiBgRXJyYCBYWxZQAABgAAAAAAAAABAAAABwAAAAgAAAAEAAAABAAAAAkAAAAAABAATwAAABwEAAAXAAAAAAAQAEAAACAQAAJgAAAHNyYysaWIucnMAABgBEAAKAAAAfAAAAEYAAABsaWlICBjbwgOgoKCgAANAEQAAUAAAAARAABQAAADBEAADAAAAQQEQAAEAAAAYARAACgAAAJQAAAAWAAAAGAEQAAoAAACYAAAAFgAAABgBEAAKAAAAvAAAABYAAAAYARAACgAAANEAAAAwAAAAGAEQAAoAAAAAAQAAFgAAABgBEAAKAAAAAgEAABYAAAAYARAACgAAACkBAAAnAAAAbGVIFfcHJzIDgWCmxldCAgPSAnJzsKAOQBEAAEAAAAAEQAAcAAAAYARAACgAAAFABAAAAAAAAisJycCgAAABAAAAAAABECEAADAAAAFAIQAAMAAAAYARAACgAAAFBAABQAAAAOwoAAAAAEAAAAAAAQAIQAAIAAAAYARAACgAAAGkBAABRAAAAXwcnMucHVzaCgpOwoAAGQCEAALAAAAbwIQAAMAAAAYARAACgAAAGUBAABHAAAAckoySFYenhRZwAAlAIQAAoAAAAYARAACgAAAGcBAAAiAAAAGAEQAAoAAABxAQAARAAAAGNvbnNIFfcnNIDgYXdhaXQgUHJvbWlzZShbGwoXwcnMpOwogPSAucmVwbGFjZSgvLcsICgpID+IFfcnNLnNoaWZKCkpOwoAAAAQAAAAAADwAhAAAwAAAPMCEAAKAAAA/QIQABoAAAAYARAACgAAAHoBAAAKAAAAcmVdXJuIABIAxAABwAAAEACEAACAAAAGAEQAAoAAABAQAAOwAAAGJvZHksIHJldHVybiAoYXNbmMgZnVuYRpboKXtKSjbzdHJYRvcgAAABgBEAAKAAAAjAEAAEkAAABcAAAGAEQAAoAAACgAQAANQAAAAsAAAAMAAAABAAAAAwAAAANAAAADgAAAGEgRGlzcGxheSBpbXBsZWlbnRhdGlvbiByZXRcmlZCBhbiBlcnJvciBbmVcGVjdGVkbHkvcnVzdGMvYTUZGQMWQZmIwZWMYTZhMEZThjMjdiMjEyNJhNDkxYUMisaWJyYXJLFsbGjLNyYyzdHJpbmcucnMAABMEEABLAAAAugkAAAAAAAPAAAAAAAAAAEAAAAHAAAATWlzcluZyBjbGzaWnIGNvbWhbmQgdGFnIGFIACABBAAHwAAAEpcNpbmcgYtbWFuZCBeXBlIGFIKgEEAAYAAAAVGVtcGxhdGUgZnVuYRpbgYFsbCBlcnJvcsgEEAAcAAAAVGVtcGxhdGUgcludGFIGVycmyOiAAAQQABcAAAAAAAAA//////////QAAAABAAAAAQAAAARAAAAEgAAABMAAABjYWubQgYWNjZXNzIGEgVGhyZWFkIExvYFsIFNbJhZUgdmFsdWUgZHVyaWnIGyIGFmdGVyIGRlcRydWNaWuLJcRjLENWRkNzFkNWZiMGVjNWEYTNhOWUYzIYjIxMjdiYTQMWNlNTIvbGlicmFyeSzdGQvcJjLRocmVhZCsbNhbCycwAAAHYFEABPAAAApQEAABoAAAAUAAAAAAAAAAEAAAAVAAAALJcRjLENWRkNzFkNWZiMGVjNWEYTNhOWUYzIYjIxMjdiYTQMWNlNTIvbGlicmFyeSjbJlLNyYyzdHIvcGFdGVybiycwDoBRAATwAAALcBAAAmAAAAYxvcVyZSBpbnZvaVkIHJlYVyclZWxIGyIGRlcRybllZCBhbHJlYWRSnNWYWxZSgpAAAAeAYQAAgAAACABhAAAQAAAGbGwgcGpbnRlciBwYXNzZWQgdGgcnVzdHJlYVyclZSBcUgbYgYWgbJqZWNIGRldGVjdGVkIHdoaWNoIHdvdWxkIGxlYWQgdGgdWzYWZlIGFsaWFzaWnIGluIHJcQAACQAAAAEAAAABAAAACUAAAAmAAAAJwAAAGNhbGxlZCBgTBaWuOjpbndyYXAoKWAgbgYSBgTmuZWAgdmFsdWVBYNlcNFcnJvcmlbWyeSBhbGxvYFaWuIGmICBieXRlcyBmYWlsZWQKAAAATgcQABUAAABjBxAADgAAAGxpYnJhcnkvcRkLNyYyhbGxvYyycQHEAAYAAAAUgEAAAkAAABsaWJyYXJLNZCzcmMvcGFuaWNraWnLnJzrAcQABwAAABGAgAAHwAAAKwHEAAcAAAARwIAABAAAAoAAAADAAAAAQAAAApAAAAJAAAAAgAAAAEAAAAKgAAACsAAAAQAAAABAAAACwAAAAtAAAAJAAAAAgAAAAEAAAALgAAACAAABIYXNoIHRhYmxlIGNhcGFjaXRIGZXJmbGMAgQABwAAAAvYFyZvcmVnaXNcnkvcJjLdpdGhYijbtMWVjYzYyOTlkYjllYzgyMyoYXNoYnJvdtMCxMizLNyYyyYXcvbWkLnJzAFQIEABPAAAAWgAAACgAAAAwAAAABAAAAAQAAAAxAAAAMgAAADMAAAAwAAAAAAAAAAEAAAAHAAAAbGlicmFyeShbGxvYyzcmMvcmFXZlYyycNhcGFjaXRIGZXJmbGAAAA+AgQABEAAADcCBAAHAAAAAYCAAAFAAAAYSBmbJtYXRaWnIHRyYWlIGltcGxlbWVudGFaWuIHJldHVybmVkIGFuIGVycmybGlicmFyeShbGxvYyzcmMvZmLnJzAFcJEAAYAAAAZAIAACAAAAAuLgAAgAkQAAIAAABpbmRleCBvdXQgbYgYmbmRzOiBaGUgbGVuIGlzICBidXQgdGhlIGluZGVIGlzIAAAjAkQACAAAACsCRAAEgAAAGNhbGxlZCBgTBaWuOjpbndyYXAoKWAgbgYSBgTmuZWAgdmFsdWUAOQAAAAAAAAABAAAAOgAAAGAIACACRAAAAAAAAKEAACAAAAfSBMHgwMDAxMDIwMzAMDUwNjAMDgwOTEwMTExMjEzMTQxNTEMTcxODEMjAyMTIyMjMyNDIMjYyNzIMjkzMDMxMzIzMzMMzUzNjMMzgzOTQwNDEMjQzNDQNTQNDcODQNTAMTUyNTMNDUNTYNzUNTkMDYxNjIMzYNjUNjYNjgOTcwNzEMjczNzQNTcNzcODcODAMTgyODMNDgODYNzgODkMDkxOTIMzkOTUNjkOTgOXJhbmdlIHNYXJIGluZGVICBvdXQgbYgcmFuZUgZmyIHNsaWNlIGmIGxlbmdaCAAAADtChAAEgAAAPKEAAiAAAAbGlicmFyeSjbJlLNyYyzbGljZSpbmRleCycwACxAAHwAAADQAAAAFAAAAcmFuZUgZWkIGluZGVIGQLEAAQAAAA/woQACIAAAACxAAHwAAAEkAAAAFAAAAcxpYUgaWkZXggcRhcnRzIGFICBidXQgZWkcyBhdCAAlAsQABYAAACqCxAADQAAADQLEAAfAAAAXAAAAAUAAABsaWJyYXJLNvcmUvcJjLNciwYXRZXJuLnJzANgLEAAfAAAAGgYAABUAAADYCxAAHwAAAEgGAAAVAAAAAsQABAAABJBgAAFQAAAGxpYnJhcnkvYyZSzcmMvcRyLvZCycsuLidYnlZSBpbmRleCAgaXMgbVIGmIGJvdWkcyBvZiBgAAAASAwQAAsAAABTDBAAFgAAAAwKEAABAAAAKAwQABsAAABrAAAACQAAAGJlZluIDwIGVuZCAoIDwICkgdhlbiBzbGljaWnIGAAAJQMEAAOAAAAogwQAAQAAACmDBAAEAAAAAwKEAABAAAAKAwQABsAAABvAAAABQAAACgMEAAbAAAAfQAAACAAAAgaXMgbmIGEgYhhciBibVuZGFyeTsgaXQgaXMgaWzaWRlICAoYnlZXMgKSBvZiBgSAwQAAsAAADDBAAJgAAABNEAAIAAAAJgQAAYAAAAMChAAAQAAACgMEAAbAAAAfwAAAAUAAABsaWJyYXJLNvcmUvcJjLVuaWNvZGUvcHJpbnRhYmxlLnJzAAAAZAQACUAAAAaAAAANgAAAAABAwUFBgYCBwYIBwkRChwLGQwaDRAODQEEAMSEhMJFgEXBBgBGQMaBxsBHAIfFiADKwMtCyBMAMxAjIBpwKpAqoEqwjAvsF/QL+A/JrXhiiMFdYiyQHNODtM+/wuLzcXV/ihIOkZKpsbqxcbJytkfABBESKTENzoPUlKXYSOkqmxtLqxsrOz+TlAAQNDhESKTEOjtFRklKXmRlhJGbncnOzwRKToRUlXWxeXRljZGptLqxcnfOXwDRFFSWRlgISyvL/dfwYOFiSmvr/FxPttImLNxsPSUPVleXmOjGt/BxsfXERYXWz//gGxtOHvHBffXur+vBYXHhGRPWFpcXn/tcXUdzwfVycdZYmLi+nre/x/XpAlgwjx/SM/TkaWwcIDxAnL+vbmPTCRZCRUdyMnQdjZ//ACBfIoLfBIJECBsEBhGBrAAqwUfCYEbAxkIAQQvBDQEBwMBBwYHEQpQDxIHVQcDBBwKCQMIAwcDAgMDAwwEBQMLBgEOFQVOBxsHVwcCBhYNUARDAyDAQQRBgMOgQdJVgbQRqJYDIBYKwAxoGgvDWQcWCRgJFAwUDGoGCgYaBlkHKwVGCiwEDAQBAzELLAQaBgsDgKwGCgYvMUDgKQIPAMPAzwHOAgrBYL/ERgILxEtAyEPIQ+AjASClxkLFYiUBSFOwcCDhgJgLidAyAhoMBYD/BYDfDPKdAzcJgVwUgLgIgMsFChgAwoGOAhGCAwGdAseAoEWQmAgxgcChYJTASAigarpAwXBDGhBIHaJgcMBQWAphCBQcBICoGTASAjQSAvgMbAwNAAYBAQMBBAIFBwcCCAgJAgoFCwIOBBABEQISBRMRFAEVAhcCGQcBRIJAFqBGsCrwOAsCQLUDNUJgLXAtoBAXhAucEALuIPAE+ALAvsBDCcPkPjenuLkaisrqGsQYHCTYPlbzNEEFBgNZXfqurBKHiYeBAOERIpMTQRUZJSkPZGVctrcbHAcICgsUFzYOqipNkJNCRqAcKOzmaY+Sb+/uaYvT/qbLinKFWdoKGjpKeorbqxAYLDBUdOjFUaanzMgBxkaIiU+P+fs//FxgQgIyUmKDMOkhKTFBTVVZYWlxeYGNlZmtzeH/iqSqrDAKvbm+TXiJBQMELQNmAwEvLoCCHQMxDxwEJAkeBSsFRAQOKoCqBiQEJAQoCDQLTkOBNwkWCggYOUAMICTAWBSEDGwUBQDgESwUvBAoHCQdAICcEDAkAzoFGgcEDAdQSTczDTMHLggKgSZSTigIKhYaJhwUFwlOBCQJRAZBwoGSAgnCXULPEqBjsFCgZRBgEFEAMFgItiHkgICoCmXiJFCwoGDRMBgoLAQXgLkZFMMSAkKRkUbSAhTDUmBBYKHQNHSTcDDggKBjkHCoEGYCAQyDYObZnULgMSKTGMNhC+PYJHobmCOQcqBFwGJgpGCigFEKwWVLBDkHEUAFCwIOl/gIhNYqCaLngTMtAxEECIGMiQRrBQDCQcQkmBHCXQgPYKcwhwFUaAmhQMVwkZgIeBRwOFQgVhFAfgOErgNUtAxoEAoFAHxEBQGEIDKUwECgQCgxFETDAwjwGAQRVBRsAoEOLARkDFYKgKHQsBAkHAgGgJqDAUQAwDdAxZBwwEAQMBDgICgYoCCJOgVQMFQMFAwcJHQMLBQYKCgYICAcJgMslCoQGbGlicmFyeSjbJlLNyYybmljbRlLVuaWNvZGVfZGFYSycwAAAAUTEAAoAAAASwAAACgAAAAFExAAKAAAAFcAAAAWAAAABRMQACgAAABSAAAAPgAAAEVycmyAAAAAAMAAIMEIACRBWAAXROgABIXIBMIGAfyygKyowICxvpuAsAqhgLRYCA/iAnvgNvBTYBCiEJAhNsOYTkvGKEMBzhR/MeIUzwauFPThUJoVAAzFRZdGhUQDaIVIAOFTMOFhVaioVbQOFWIABuV/AB/cAcAAHACBAQECAQIBAUgLMBUQAWUHAgYCAgEEIwEeGsLOgkJARgEAQkBAwEFKwMCCoYASAAQEBBAgEAQMHCgIdAToBAQECBAgBCQEKAhoBAgIAQQCBAICAwMBHgIDAQsCOQEEBQECBAEUAhYGAQEAQECAQQIAQcDCgIeATsBAQEMAQkBKAEDATcBAQMFAwEEBwILAhBOgECAQIBAwEFAgcCCwIcAjkCAQECBAgBCQEKAhBSAEEAQIDAQEIAVEBAgcMCGIBAgkLBkoCGwEBAQEBNwBBQECBQsBJAkBZgQBBgECAgIZAgQDEAQNAQICBgEPAQADAAMdAhCHgJAAgEHCAECCwkBLQMBAXUCIgFAwQCCQEGAsCAgEAQEHAQEBAQIIBgoCATAfMQQwBwEBBQEoCQwCIAQCAgEDOAEBAgMBAQMCAICmAMBDQEHBAEGAQMCxkAAAcMhAAONAWAgAAZpAgAEAQogAlACAAEDAQQBGQIFAZcCGhINASYIGQsuAzABAgQCAicBQwYCAgICDAEIASBMwEBAwICBQIBASoCCAHuAQIBBAEAAQAQEBAAAgABgGVBQADAQIFBCgDBAGlAgAEAAKZCzEEewEDykBAgIKAzEEAgIHATDJAUBCDBDAICQoEAgFfAwIBAQIGAaABAwgVAjkCAQEBARYBDgcDBcMIAgMBARcBUQECBgEBAgEBAgECwECBAYCAQIbAlUIAgEBAmoBAQECBgEBZQMCBAEFAAkBAvUBCgIBAQQBkAQCAgQBIAooBgIECAEJBgIDLgBAgAHAQYBAVIWAgcBAgECegYDAQECAQcBAUgCAwEBAQACAAUBwABPwRRAQACACCFwABAQMEBQgIAgceBJQDADcEMggBDgEWBQEPAAcBEQIHAQIBBQAHAAEBAAHbQcAYIDwAACAFgAAACAgAQAwYAEBMHECCQUSAWQBGgEAAQALHQIFASBAAEAewlwcmkdWNlcnMCCGxhbmdYWdlAQRSdXNAAxwcmjZXNzZWQtYnkDBXJcRjHTEuNjQuMCAoYTUZGQMWQIDIwMjItMDktMTkpBndhbHJcwYwLjELjAMdFzbSiaWkZVuEjAuMiMyAoZWJhNjkxZjMKQ==");

// src/core/parser/Parser.ts
var Parser = class {
  async init() {
    await rusty_engine_default(rusty_engine_bg_default);
    const config = new ParserConfig("<%", "%>", "\", "", "-", "_", "tR");
    this.renderer = new Renderer(config);
  }
  async parse_commands(content, context) {
    return this.renderer.render_content(content, context);
  }
};

// src/core/Templater.ts
var RunMode;
(function(RunMode) {
  RunMode[RunMode["CreateNewFromTemplate"] = ] = "CreateNewFromTemplate";
  RunMode[RunMode["AppendActiveFile"] = ] = "AppendActiveFile";
  RunMode[RunMode["OverwriteFile"] = ] = "OverwriteFile";
  RunMode[RunMode["OverwriteActiveFile"] = ] = "OverwriteActiveFile";
  RunMode[RunMode["DynamicProcessor"] = ] = "DynamicProcessor";
  RunMode[RunMode["StartupTemplate"] = ] = "StartupTemplate";
})(RunMode || (RunMode = {}));
var Templater = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.functions_generator = new FunctionsGenerator(this.plugin);
    this.parser = new Parser();
  }
  async setup() {
    await this.parser.init();
    await this.functions_generator.init();
    this.plugin.registerMarkdownPostProcessor((el, ctx) => this.process_dynamic_templates(el, ctx));
  }
  create_running_config(template_file, target_file, run_mode) {
    const active_file = app.workspace.getActiveFile();
    return {
      template_file,
      target_file,
      run_mode,
      active_file
    };
  }
  async read_and_parse_template(config) {
    const template_content = await app.vault.read(config.template_file);
    return this.parse_template(config, template_content);
  }
  async parse_template(config, template_content) {
    const functions_object = await this.functions_generator.generate_object(config, FunctionsMode.USER_INTERNAL);
    this.current_functions_object = functions_object;
    const content = await this.parser.parse_commands(template_content, functions_object);
    return content;
  }
  async create_new_note_from_template(template, folder, filename, open_new_note = true) {
    if (!folder) {
      const new_file_location = app.vault.getConfig("newFileLocation");
      switch (new_file_location) {
        case "current": {
          const active_file = app.workspace.getActiveFile();
          if (active_file) {
            folder = active_file.parent;
          }
          break;
        }
        case "folder":
          folder = app.fileManager.getNewFileParent("");
          break;
        case "root":
          folder = app.vault.getRoot();
          break;
        default:
          break;
      }
    }
    const created_note = await app.fileManager.createNewMarkdownFile(folder, filename ?? "Untitled");
    let running_config;
    let output_content;
    if (template instanceof import_obsidian.TFile) {
      running_config = this.create_running_config(template, created_note, );
      output_content = await errorWrapper(async () => this.read_and_parse_template(running_config), "Template parsing error, aborting.");
    } else {
      running_config = this.create_running_config(void , created_note, );
      output_content = await errorWrapper(async () => this.parse_template(running_config, template), "Template parsing error, aborting.");
    }
    if (output_content == null) {
      await app.vault.delete(created_note);
      return;
    }
    await app.vault.modify(created_note, output_content);
    app.workspace.trigger("templater:new-note-from-template", {
      file: created_note,
      content: output_content
    });
    if (open_new_note) {
      const active_leaf = app.workspace.getLeaf(false);
      if (!active_leaf) {
        log_error(new TemplaterError("No active leaf"));
        return;
      }
      await active_leaf.openFile(created_note, {
        state: { mode: "source" }
      });
      await this.plugin.editor_handler.jump_to_next_cursor_location(created_note, true);
      active_leaf.setEphemeralState({
        rename: "all"
      });
    }
    return created_note;
  }
  async append_template_to_active_file(template_file) {
    const active_view = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (active_view === null) {
      log_error(new TemplaterError("No active view, can't append templates."));
      return;
    }
    const running_config = this.create_running_config(template_file, active_view.file, );
    const output_content = await errorWrapper(async () => this.read_and_parse_template(running_config), "Template parsing error, aborting.");
    if (output_content == null) {
      return;
    }
    const editor = active_view.editor;
    const doc = editor.getDoc();
    const oldSelections = doc.listSelections();
    doc.replaceSelection(output_content);
    app.workspace.trigger("templater:template-appended", {
      view: active_view,
      content: output_content,
      oldSelections,
      newSelections: doc.listSelections()
    });
    await this.plugin.editor_handler.jump_to_next_cursor_location(active_view.file, true);
  }
  async write_template_to_file(template_file, file) {
    const running_config = this.create_running_config(template_file, file, );
    const output_content = await errorWrapper(async () => this.read_and_parse_template(running_config), "Template parsing error, aborting.");
    if (output_content == null) {
      return;
    }
    await app.vault.modify(file, output_content);
    app.workspace.trigger("templater:new-note-from-template", {
      file,
      content: output_content
    });
    await this.plugin.editor_handler.jump_to_next_cursor_location(file, true);
  }
  overwrite_active_file_commands() {
    const active_view = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (active_view === null) {
      log_error(new TemplaterError("Active view is null, can't overwrite content"));
      return;
    }
    this.overwrite_file_commands(active_view.file, true);
  }
  async overwrite_file_commands(file, active_file = false) {
    const running_config = this.create_running_config(file, file, active_file ?  : );
    const output_content = await errorWrapper(async () => this.read_and_parse_template(running_config), "Template parsing error, aborting.");
    if (output_content == null) {
      return;
    }
    await app.vault.modify(file, output_content);
    app.workspace.trigger("templater:overwrite-file", {
      file,
      content: output_content
    });
    await this.plugin.editor_handler.jump_to_next_cursor_location(file, true);
  }
  async process_dynamic_templates(el, ctx) {
    const dynamic_command_regex = generate_dynamic_command_regex();
    const walker = document.createNodeIterator(el, NodeFilter.SHOW_TEXT);
    let node;
    let pass = false;
    let functions_object;
    while (node = walker.nextNode()) {
      let content = node.nodeValue;
      if (content !== null) {
        let match = dynamic_command_regex.exec(content);
        if (match !== null) {
          const file = app.metadataCache.getFirstLinkpathDest("", ctx.sourcePath);
          if (!file || !(file instanceof import_obsidian.TFile)) {
            return;
          }
          if (!pass) {
            pass = true;
            const config = this.create_running_config(file, file, );
            functions_object = await this.functions_generator.generate_object(config, FunctionsMode.USER_INTERNAL);
            this.current_functions_object = functions_object;
          }
        }
        while (match != null) {
          const complete_command = match[] + match[];
          const command_output = await errorWrapper(async () => {
            return await this.parser.parse_commands(complete_command, functions_object);
          }, `Command Parsing error in dynamic command '${complete_command}'`);
          if (command_output == null) {
            return;
          }
          const start = dynamic_command_regex.lastIndex - match[].length;
          const end = dynamic_command_regex.lastIndex;
          content = content.substring(, start) + command_output + content.substring(end);
          dynamic_command_regex.lastIndex += command_output.length - match[].length;
          match = dynamic_command_regex.exec(content);
        }
        node.nodeValue = content;
      }
    }
  }
  get_new_file_template_for_folder(folder) {
    do {
      const match = this.plugin.settings.folder_templates.find((e) => e.folder == folder.path);
      if (match && match.template) {
        return match.template;
      }
      folder = folder.parent;
    } while (folder);
  }
  static async on_file_creation(templater, file) {
    if (!(file instanceof import_obsidian.TFile) || file.extension !== "md") {
      return;
    }
    const template_folder = (, import_obsidian.normalizePath)(templater.plugin.settings.templates_folder);
    if (file.path.includes(template_folder) && template_folder !== "/") {
      return;
    }
    await delay();
    if (file.stat.size ==  && templater.plugin.settings.enable_folder_templates) {
      const folder_template_match = templater.get_new_file_template_for_folder(file.parent);
      if (!folder_template_match) {
        return;
      }
      const template_file = await errorWrapper(async () => {
        return resolve_tfile(folder_template_match);
      }, `Couldn't find template ${folder_template_match}`);
      if (template_file == null) {
        return;
      }
      await templater.write_template_to_file(template_file, file);
    } else {
      if (file.stat.size <= e) {
        await templater.overwrite_file_commands(file);
      } else {
        console.log(`Templater skipped parsing ${file.path} because file size exceeds `);
      }
    }
  }
  async execute_startup_scripts() {
    for (const template of this.plugin.settings.startup_templates) {
      if (!template) {
        continue;
      }
      const file = errorWrapperSync(() => resolve_tfile(template), `Couldn't find startup template "${template}"`);
      if (!file) {
        continue;
      }
      const running_config = this.create_running_config(file, file, );
      await errorWrapper(async () => this.read_and_parse_template(running_config), `Startup Template parsing error, aborting.`);
    }
  }
};

// src/handlers/EventHandler.ts
var import_obsidian = __toModule(require("obsidian"));
var EventHandler = class {
  constructor(plugin, templater, settings) {
    this.plugin = plugin;
    this.templater = templater;
    this.settings = settings;
  }
  setup() {
    app.workspace.onLayoutReady(() => {
      this.update_trigger_file_on_creation();
    });
    this.update_syntax_highlighting();
    this.update_file_menu();
  }
  update_syntax_highlighting() {
    if (this.plugin.settings.syntax_highlighting) {
      this.syntax_highlighting_event = app.workspace.on("codemirror", (cm) => {
        cm.setOption("mode", "templater");
      });
      app.workspace.iterateCodeMirrors((cm) => {
        cm.setOption("mode", "templater");
      });
      this.plugin.registerEvent(this.syntax_highlighting_event);
    } else {
      if (this.syntax_highlighting_event) {
        app.vault.offref(this.syntax_highlighting_event);
      }
      app.workspace.iterateCodeMirrors((cm) => {
        cm.setOption("mode", "hypermd");
      });
    }
  }
  update_trigger_file_on_creation() {
    if (this.settings.trigger_on_file_creation) {
      this.trigger_on_file_creation_event = app.vault.on("create", (file) => Templater.on_file_creation(this.templater, file));
      this.plugin.registerEvent(this.trigger_on_file_creation_event);
    } else {
      if (this.trigger_on_file_creation_event) {
        app.vault.offref(this.trigger_on_file_creation_event);
        this.trigger_on_file_creation_event = void ;
      }
    }
  }
  update_file_menu() {
    this.plugin.registerEvent(app.workspace.on("file-menu", (menu, file) => {
      if (file instanceof import_obsidian.TFolder) {
        menu.addItem((item) => {
          item.setTitle("Create new note from template").setIcon("templater-icon").onClick(() => {
            this.plugin.fuzzy_suggester.create_new_note_from_template(file);
          });
        });
      }
    }));
  }
};

// src/handlers/CommandHandler.ts
var CommandHandler = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  setup() {
    this.plugin.addCommand({
      id: "insert-templater",
      name: "Open Insert Template modal",
      hotkeys: [
        {
          modifiers: ["Alt"],
          key: "e"
        }
      ],
      callback: () => {
        this.plugin.fuzzy_suggester.insert_template();
      }
    });
    this.plugin.addCommand({
      id: "replace-in-file-templater",
      name: "Replace templates in the active file",
      hotkeys: [
        {
          modifiers: ["Alt"],
          key: "r"
        }
      ],
      callback: () => {
        this.plugin.templater.overwrite_active_file_commands();
      }
    });
    this.plugin.addCommand({
      id: "jump-to-next-cursor-location",
      name: "Jump to next cursor location",
      hotkeys: [
        {
          modifiers: ["Alt"],
          key: "Tab"
        }
      ],
      callback: () => {
        this.plugin.editor_handler.jump_to_next_cursor_location();
      }
    });
    this.plugin.addCommand({
      id: "create-new-note-from-template",
      name: "Create new note from template",
      hotkeys: [
        {
          modifiers: ["Alt"],
          key: "n"
        }
      ],
      callback: () => {
        this.plugin.fuzzy_suggester.create_new_note_from_template();
      }
    });
    this.register_templates_hotkeys();
  }
  register_templates_hotkeys() {
    this.plugin.settings.enabled_templates_hotkeys.forEach((template) => {
      if (template) {
        this.add_template_hotkey(null, template);
      }
    });
  }
  add_template_hotkey(old_template, new_template) {
    this.remove_template_hotkey(old_template);
    if (new_template) {
      this.plugin.addCommand({
        id: new_template,
        name: `Insert ${new_template}`,
        callback: () => {
          const template = errorWrapperSync(() => resolve_tfile(new_template), `Couldn't find the template file associated with this hotkey`);
          if (!template) {
            return;
          }
          this.plugin.templater.append_template_to_active_file(template);
        }
      });
    }
  }
  remove_template_hotkey(template) {
    if (template) {
      app.commands.removeCommand(`${this.plugin.manifest.id}:${template}`);
    }
  }
};

// src/editor/Editor.ts
var import_obsidian = __toModule(require("obsidian"));

// src/editor/CursorJumper.ts
var import_obsidian = __toModule(require("obsidian"));
var CursorJumper = class {
  constructor() {
  }
  async jump_to_next_cursor_location() {
    const active_view = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!active_view) {
      return;
    }
    const active_file = active_view.file;
    await active_view.save();
    const content = await app.vault.read(active_file);
    const { new_content, positions } = this.replace_and_get_cursor_positions(content);
    if (positions) {
      await app.vault.modify(active_file, new_content);
      this.set_cursor_location(positions);
    }
    if (app.vault.getConfig("vimMode")) {
      const cm = active_view.editor.cm.cm;
      window.CodeMirrorAdapter.Vim.handleKey(cm, "i", "mapping");
    }
  }
  get_editor_position_from_index(content, index) {
    const substr = content.slice(, index);
    let l = ;
    let offset = -;
    let r = -;
    for (; (r = substr.indexOf("\n", r + )) !== -; l++, offset = r)
      ;
    offset += ;
    const ch = content.slice(offset, index).length;
    return { line: l, ch };
  }
  replace_and_get_cursor_positions(content) {
    let cursor_matches = [];
    let match;
    const cursor_regex = new RegExp("<%\\stp.file.cursor\\((?<order>[-]{,})\\)\\s%>", "g");
    while ((match = cursor_regex.exec(content)) != null) {
      cursor_matches.push(match);
    }
    if (cursor_matches.length === ) {
      return {};
    }
    cursor_matches.sort((m, m) => {
      return Number(m.groups && m.groups["order"]) - Number(m.groups && m.groups["order"]);
    });
    const match_str = cursor_matches[][];
    cursor_matches = cursor_matches.filter((m) => {
      return m[] === match_str;
    });
    const positions = [];
    let index_offset = ;
    for (const match of cursor_matches) {
      const index = match.index - index_offset;
      positions.push(this.get_editor_position_from_index(content, index));
      content = content.replace(new RegExp(escape_RegExp(match[])), "");
      index_offset += match[].length;
      if (match[] === "") {
        break;
      }
    }
    return { new_content: content, positions };
  }
  set_cursor_location(positions) {
    const active_view = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!active_view) {
      return;
    }
    const editor = active_view.editor;
    const selections = [];
    for (const pos of positions) {
      selections.push({ from: pos });
    }
    const transaction = {
      selections
    };
    editor.transaction(transaction);
  }
};

// src/editor/Autocomplete.ts
var import_obsidian = __toModule(require("obsidian"));

// toml:/home/runner/work/Templater/Templater/docs/documentation.toml
var tp = { config: { name: "config", description: "This module exposes Templater's running configuration.\n\nThis is mostly useful when writing scripts requiring some context information.\n", functions: { template_file: { name: "template_file", description: "The `TFile` object representing the template file.", definition: "tp.file.template_file" }, target_file: { name: "target_file", description: "The `TFile` object representing the target file where the template will be inserted.", definition: "tp.config.target_file" }, run_mode: { name: "run_mode", description: "The `RunMode`, representing the way Templater was launched (Create new from template, Append to active file, ...)", definition: "tp.config.run_mode" }, active_file: { name: "active_file", description: "The active file (if existing) when launching Templater.", definition: "tp.config.active_file?" } } }, date: { name: "date", description: "This module contains every internal function related to dates.", functions: { now: { name: "now", description: "Retrieves the date.", definition: 'tp.date.now(format: string = "YYYY-MM-DD", offset?: number\uAEstring, reference?: string, reference_format?: string)', args: { format: { name: "format", description: "Format for the date, refer to [format reference](https://momentjs.com/docs//displaying/format/)" }, offset: { name: "offset", description: "Offset for the day, e.g. set this to `-` to get last week's date. You can also specify the offset as a string using the ISO  format" }, reference: { name: "reference", description: "The date referential, e.g. set this to the note's title" }, reference_format: { name: "reference_format", description: "The date reference format." } } }, tomorrow: { name: "tomorrow", description: "Retrieves tomorrow's date.", definition: 'tp.date.tomorrow(format: string = "YYYY-MM-DD")', args: { format: { name: "format", description: "Format for the date, refer to [format reference](https://momentjs.com/docs//displaying/format/)" } } }, yesterday: { name: "yesterday", description: "Retrieves yesterday's date.", definition: 'tp.date.yesterday(format: string = "YYYY-MM-DD")', args: { format: { name: "format", description: "Format for the date, refer to [format reference](https://momentjs.com/docs//displaying/format/)" } } }, weekday: { name: "weekday", description: "", definition: 'tp.date.weekday(format: string = "YYYY-MM-DD", weekday: number, reference?: string, reference_format?: string)', args: { format: { name: "format", description: "Format for the date, refer to [format reference](https://momentjs.com/docs//displaying/format/)" }, weekday: { name: "weekday", description: "Week day number. If the locale assigns Monday as the first day of the week, `` will be Monday, `-` will be last week's day." }, reference: { name: "reference", description: "The date referential, e.g. set this to the note's title" }, reference_format: { name: "reference_format", description: "The date reference format." } } } } }, file: { name: "file", description: "This module contains every internal function related to files.", functions: { content: { name: "content", description: "Retrieves the file's content", definition: "tp.file.content" }, create_new: { name: "create_new", description: "Creates a new file using a specified template or with a specified content.", definition: "tp.file.create_new(template: TFile \uAE string, filename?: string, open_new: boolean = false, folder?: TFolder)", args: { template: { name: "template", description: "Either the template used for the new file content, or the file content as a string. If it is the template to use, you retrieve it with `tp.file.find_tfile(TEMPLATENAME)`" }, filename: { name: "filename", description: 'The filename of the new file, defaults to "Untitled".' }, open_new: { name: "open_new", description: "Whether to open or not the newly created file. Warning: if you use this option, since commands are executed asynchronously, the file can be opened first and then other commands are appended to that new file and not the previous file." }, folder: { name: "folder", description: 'The folder to put the new file in, defaults to obsidian\'s default location. If you want the file to appear in a different folder, specify it with `app.vault.getAbstractFileByPath("FOLDERNAME")`' } } }, creation_date: { name: "creation_date", description: "Retrieves the file's creation date.", definition: 'tp.file.creation_date(format: string = "YYYY-MM-DD HH:mm")', args: { format: { name: "format", description: "Format for the date, refer to format reference" } } }, cursor: { name: "cursor", description: "Sets the cursor to this location after the template has been inserted. \n\nYou can navigate between the different tp.file.cursor using the configured hotkey in obsidian settings.\n", definition: "tp.file.cursor(order?: number)", args: { order: { name: "order", description: "The order of the different cursors jump, e.g. it will jump from  to  to , and so on.\nIf you specify multiple tp.file.cursor with the same order, the editor will switch to multi-cursor.\n" } } }, cursor_append: { name: "cursor_append", description: "Appends some content after the active cursor in the file.", definition: "tp.file.cursor_append(content: string)", args: { content: { name: "content", description: "The content to append after the active cursor" } } }, exists: { name: "exists", description: "The filename of the file we want to check existence. The fullpath to the file, relative to the Vault and containing the extension, must be provided. e.g. MyFolder/SubFolder/MyFile.", definition: "tp.file.exists(filename: string)", args: { filename: { name: "filename", description: "The filename of the file we want to check existence, e.g. MyFile." } } }, find_tfile: { name: "find_tfile", description: "Search for a file and returns its `TFile` instance", definition: "tp.file.find_tfile(filename: string)", args: { filename: { name: "filename", description: "The filename we want to search and resolve as a `TFile`" } } }, folder: { name: "folder", description: "Retrieves the file's folder name.", definition: "tp.file.folder(relative: boolean = false)", args: { relative: { name: "relative", description: "If set to true, appends the vault relative path to the folder name." } } }, include: { name: "include", description: "Includes the file's link content. Templates in the included content will be resolved.", definition: "tp.file.include(include_link: string \uAE TFile)", args: { include_link: { name: "include_link", description: "The link to the file to include, e.g. [[MyFile]], or a TFile object. Also supports sections or blocks inclusions, e.g. [[MyFileSection]]" } } }, last_modified_date: { name: "last_modified_date", description: "Retrieves the file's last modification date.", definition: 'tp.file.last_modified_date(format: string = "YYYY-MM-DD HH:mm")', args: { format: { name: "format", description: "Format for the date, refer to format reference." } } }, move: { name: "functions.move", description: "Moves the file to the desired vault location.", definition: "tp.file.move(new_path: string, file_to_move?: TFile)", args: { new_path: { name: "new_path", description: "The new vault relative path of the file, without the file extension. Note: the new path needs to include the folder and the filename, e.g. /Notes/MyNote" } } }, path: { name: "path", description: "Retrieves the file's absolute path on the system.", definition: "tp.file.path(relative: boolean = false)", args: { relative: { name: "relative", description: "If set to true, only retrieves the vault's relative path." } } }, rename: { name: "rename", description: "Renames the file (keeps the same file extension).", definition: "tp.file.rename(new_title: string)", args: { new_title: { name: "new_title", description: "The new file title." } } }, selection: { name: "selection", description: "Retrieves the active file's text selection.", definition: "tp.file.selection()" }, tags: { name: "tags", description: "Retrieves the file's tags (array of string)", definition: "tp.file.tags" }, title: { name: "title", definition: "tp.file.title", description: "Retrieves the file's title." } } }, frontmatter: { name: "frontmatter", description: "This modules exposes all the frontmatter variables of a file as variables." }, obsidian: { name: "obsidian", description: "This module exposes all the functions and classes from the obsidian API." }, system: { name: "system", description: "This module contains system related functions.", functions: { clipboard: { name: "clipboard", description: "Retrieves the clipboard's content", definition: "tp.system.clipboard()" }, prompt: { name: "prompt", description: "Spawns a prompt modal and returns the user's input.", definition: "tp.system.prompt(prompt_text?: string, default_value?: string, throw_on_cancel: boolean = false, multiline?: boolean = false)", args: { prompt_text: { name: "prompt_text", description: "Text placed above the input field" }, default_value: { name: "default_value", description: "A default value for the input field" }, throw_on_cancel: { name: "throw_on_cancel", description: "Throws an error if the prompt is canceled, instead of returning a `null` value" }, multiline: { name: "multiline", description: "If set to true, the input field will be a multiline textarea" } } }, suggester: { name: "suggester", description: "Spawns a suggester prompt and returns the user's chosen item.", definition: 'tp.system.suggester(text_items: string[] \uAE ((item: T) => string), items: T[], throw_on_cancel: boolean = false, placeholder: string = "", limit?: number = undefined)', args: { text_items: { name: "text_items", description: "Array of strings representing the text that will be displayed for each item in the suggester prompt. This can also be a function that maps an item to its text representation." }, items: { name: "items", description: "Array containing the values of each item in the correct order." }, throw_on_cancel: { name: "throw_on_cancel", description: "Throws an error if the prompt is canceled, instead of returning a `null` value" }, placeholder: { name: "placeholder", description: "Placeholder string of the prompt" }, limit: { name: "limit", description: "Limit the number of items rendered at once (useful to improve performance when displaying large lists)" } } } } }, web: { name: "web", description: "This modules contains every internal function related to the web (making web requests).", functions: { daily_quote: { name: "daily_quote", description: "Retrieves and parses the daily quote from the API https://api.quotable.io", definition: "tp.web.daily_quote()" }, random_picture: { name: "random_picture", description: "Gets a random image from https://unsplash.com/", definition: "tp.web.random_picture(size?: string, query?: string, include_size?: boolean)", args: { size: { name: "size", description: "Image size in the format `<width>x<height>`" }, query: { name: "query", description: "Limits selection to photos matching a search term. Multiple search terms can be passed separated by a comma `,`" }, include_dimensions: { name: "include_size", description: "Optional argument to include the specified size in the image link markdown. Defaults to false" } } } } } };
var documentation_default = { tp };

// src/editor/TpDocumentation.ts
var module_names = [
  "config",
  "date",
  "file",
  "frontmatter",
  "obsidian",
  "system",
  "user",
  "web"
];
var module_names_checker = new Set(module_names);
function is_module_name(x) {
  return typeof x === "string" && module_names_checker.has(x);
}
function is_function_documentation(x) {
  if (x.definition) {
    return true;
  }
  return false;
}
var Documentation = class {
  constructor() {
    this.documentation = documentation_default;
  }
  get_all_modules_documentation() {
    return Object.values(this.documentation.tp);
  }
  get_all_functions_documentation(module_name) {
    if (!this.documentation.tp[module_name].functions) {
      return;
    }
    return Object.values(this.documentation.tp[module_name].functions);
  }
  get_module_documentation(module_name) {
    return this.documentation.tp[module_name];
  }
  get_function_documentation(module_name, function_name) {
    return this.documentation.tp[module_name].functions[function_name];
  }
  get_argument_documentation(module_name, function_name, argument_name) {
    const function_doc = this.get_function_documentation(module_name, function_name);
    if (!function_doc || !function_doc.args) {
      return null;
    }
    return function_doc.args[argument_name];
  }
};

// src/editor/Autocomplete.ts
var Autocomplete = class extends import_obsidian.EditorSuggest {
  constructor() {
    super(app);
    this.tp_keyword_regex = /tp\.(?<module>[a-z])?(?<fn_trigger>\.(?<fn>[a-z_])?)?$/;
    this.documentation = new Documentation();
  }
  onTrigger(cursor, editor, _file) {
    const range = editor.getRange({ line: cursor.line, ch:  }, { line: cursor.line, ch: cursor.ch });
    const match = this.tp_keyword_regex.exec(range);
    if (!match) {
      return null;
    }
    let query;
    const module_name = match.groups && match.groups["module"] || "";
    this.module_name = module_name;
    if (match.groups && match.groups["fn_trigger"]) {
      if (module_name == "" || !is_module_name(module_name)) {
        return null;
      }
      this.function_trigger = true;
      this.function_name = match.groups["fn"] || "";
      query = this.function_name;
    } else {
      this.function_trigger = false;
      query = this.module_name;
    }
    const trigger_info = {
      start: { line: cursor.line, ch: cursor.ch - query.length },
      end: { line: cursor.line, ch: cursor.ch },
      query
    };
    this.latest_trigger_info = trigger_info;
    return trigger_info;
  }
  getSuggestions(context) {
    let suggestions;
    if (this.module_name && this.function_trigger) {
      suggestions = this.documentation.get_all_functions_documentation(this.module_name);
    } else {
      suggestions = this.documentation.get_all_modules_documentation();
    }
    if (!suggestions) {
      return [];
    }
    return suggestions.filter((s) => s.name.startsWith(context.query));
  }
  renderSuggestion(value, el) {
    el.createEl("b", { text: value.name });
    el.createEl("br");
    if (this.function_trigger && is_function_documentation(value)) {
      el.createEl("code", { text: value.definition });
    }
    if (value.description) {
      el.createEl("div", { text: value.description });
    }
  }
  selectSuggestion(value, _evt) {
    const active_view = app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!active_view) {
      return;
    }
    active_view.editor.replaceRange(value.name, this.latest_trigger_info.start, this.latest_trigger_info.end);
    if (this.latest_trigger_info.start.ch == this.latest_trigger_info.end.ch) {
      const cursor_pos = this.latest_trigger_info.end;
      cursor_pos.ch += value.name.length;
      active_view.editor.setCursor(cursor_pos);
    }
  }
};

// src/editor/mode/javascript.js
(function(mod) {
  mod(window.CodeMirror);
})(function(CodeMirror) {
  "use strict";
  CodeMirror.defineMode("javascript", function(config, parserConfig) {
    var indentUnit = config.indentUnit;
    var statementIndent = parserConfig.statementIndent;
    var jsonldMode = parserConfig.jsonld;
    var jsonMode = parserConfig.json || jsonldMode;
    var trackScope = parserConfig.trackScope !== false;
    var isTS = parserConfig.typescript;
    var wordRE = parserConfig.wordCharacters || /[\w$\xa-\uffff]/;
    var keywords = function() {
      function kw(type) {
        return { type: type, style: "keyword" };
      }
      var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
      var operator = kw("operator"), atom = { type: "atom", style: "atom" };
      return {
        if: kw("if"),
        while: A,
        with: A,
        else: B,
        do: B,
        try: B,
        finally: B,
        return: D,
        break: D,
        continue: D,
        new: kw("new"),
        delete: C,
        void: C,
        throw: C,
        debugger: kw("debugger"),
        var: kw("var"),
        const: kw("var"),
        let: kw("var"),
        function: kw("function"),
        catch: kw("catch"),
        for: kw("for"),
        switch: kw("switch"),
        case: kw("case"),
        default: kw("default"),
        in: operator,
        typeof: operator,
        instanceof: operator,
        true: atom,
        false: atom,
        null: atom,
        undefined: atom,
        NaN: atom,
        Infinity: atom,
        this: kw("this"),
        class: kw("class"),
        super: kw("atom"),
        yield: C,
        export: kw("export"),
        import: kw("import"),
        extends: C,
        await: C
      };
    }();
    var isOperatorChar = /[+\-&%=<>!?|~^@]/;
    var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
    function readRegexp(stream) {
      var escaped = false, next, inSet = false;
      while ((next = stream.next()) != null) {
        if (!escaped) {
          if (next == "/" && !inSet)
            return;
          if (next == "[")
            inSet = true;
          else if (inSet && next == "]")
            inSet = false;
        }
        escaped = !escaped && next == "\\";
      }
    }
    var type, content;
    function ret(tp, style, cont) {
      type = tp;
      content = cont;
      return style;
    }
    function tokenBase(stream, state) {
      var ch = stream.next();
      if (ch == '"' || ch == "'") {
        state.tokenize = tokenString(ch);
        return state.tokenize(stream, state);
      } else if (ch == "." && stream.match(/^\d[\d_](?:[eE][+\-]?[\d_]+)?/)) {
        return ret("number", "number");
      } else if (ch == "." && stream.match("..")) {
        return ret("spread", "meta");
      } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
        return ret(ch);
      } else if (ch == "=" && stream.eat(">")) {
        return ret("=>", "operator");
      } else if (ch == "" && stream.match(/^(?:x[\dA-Fa-f_]+|o[-_]+|b[_]+)n?/)) {
        return ret("number", "number");
      } else if (/\d/.test(ch)) {
        stream.match(/^[\d_](?:n|(?:\.[\d_])?(?:[eE][+\-]?[\d_]+)?)?/);
        return ret("number", "number");
      } else if (ch == "/") {
        if (stream.eat("")) {
          state.tokenize = tokenComment;
          return tokenComment(stream, state);
        } else if (stream.eat("/")) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (expressionAllowed(stream, state, )) {
          readRegexp(stream);
          stream.match(/^\b(([gimyus])(?![gimyus]\))+\b/);
          return ret("regexp", "string-");
        } else {
          stream.eat("=");
          return ret("operator", "operator", stream.current());
        }
      } else if (ch == "`") {
        state.tokenize = tokenQuasi;
        return tokenQuasi(stream, state);
      } else if (ch == "" && stream.peek() == "!") {
        stream.skipToEnd();
        return ret("meta", "meta");
      } else if (ch == "" && stream.eatWhile(wordRE)) {
        return ret("variable", "property");
      } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(, stream.start))) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (isOperatorChar.test(ch)) {
        if (ch != ">" || !state.lexical || state.lexical.type != ">") {
          if (stream.eat("=")) {
            if (ch == "!" || ch == "=")
              stream.eat("=");
          } else if (/[<>+\-|&?]/.test(ch)) {
            stream.eat(ch);
            if (ch == ">")
              stream.eat(ch);
          }
        }
        if (ch == "?" && stream.eat("."))
          return ret(".");
        return ret("operator", "operator", stream.current());
      } else if (wordRE.test(ch)) {
        stream.eatWhile(wordRE);
        var word = stream.current();
        if (state.lastType != ".") {
          if (keywords.propertyIsEnumerable(word)) {
            var kw = keywords[word];
            return ret(kw.type, kw.style, word);
          }
          if (word == "async" && stream.match(/^(\s|\/\([^]|\(?!\/))?\\/)[\[\(\w]/, false))
            return ret("async", "keyword", word);
        }
        return ret("variable", "variable", word);
      }
    }
    function tokenString(quote) {
      return function(stream, state) {
        var escaped = false, next;
        if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
          state.tokenize = tokenBase;
          return ret("jsonld-keyword", "meta");
        }
        while ((next = stream.next()) != null) {
          if (next == quote && !escaped)
            break;
          escaped = !escaped && next == "\\";
        }
        if (!escaped)
          state.tokenize = tokenBase;
        return ret("string", "string");
      };
    }
    function tokenComment(stream, state) {
      var maybeEnd = false, ch;
      while (ch = stream.next()) {
        if (ch == "/" && maybeEnd) {
          state.tokenize = tokenBase;
          break;
        }
        maybeEnd = ch == "";
      }
      return ret("comment", "comment");
    }
    function tokenQuasi(stream, state) {
      var escaped = false, next;
      while ((next = stream.next()) != null) {
        if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
          state.tokenize = tokenBase;
          break;
        }
        escaped = !escaped && next == "\\";
      }
      return ret("quasi", "string-", stream.current());
    }
    var brackets = "([{}])";
    function findFatArrow(stream, state) {
      if (state.fatArrowAt)
        state.fatArrowAt = null;
      var arrow = stream.string.indexOf("=>", stream.start);
      if (arrow < )
        return;
      if (isTS) {
        var m = /:\s(?:\w+(?:<[^>]>|\[\])?|\{[^}]\})\s$/.exec(stream.string.slice(stream.start, arrow));
        if (m)
          arrow = m.index;
      }
      var depth = , sawSomething = false;
      for (var pos = arrow - ; pos >= ; --pos) {
        var ch = stream.string.charAt(pos);
        var bracket = brackets.indexOf(ch);
        if (bracket >=  && bracket < ) {
          if (!depth) {
            ++pos;
            break;
          }
          if (--depth == ) {
            if (ch == "(")
              sawSomething = true;
            break;
          }
        } else if (bracket >=  && bracket < ) {
          ++depth;
        } else if (wordRE.test(ch)) {
          sawSomething = true;
        } else if (/["'\/`]/.test(ch)) {
          for (; ; --pos) {
            if (pos == )
              return;
            var next = stream.string.charAt(pos - );
            if (next == ch && stream.string.charAt(pos - ) != "\\") {
              pos--;
              break;
            }
          }
        } else if (sawSomething && !depth) {
          ++pos;
          break;
        }
      }
      if (sawSomething && !depth)
        state.fatArrowAt = pos;
    }
    var atomicTypes = {
      atom: true,
      number: true,
      variable: true,
      string: true,
      regexp: true,
      this: true,
      import: true,
      "jsonld-keyword": true
    };
    function JSLexical(indented, column, type, align, prev, info) {
      this.indented = indented;
      this.column = column;
      this.type = type;
      this.prev = prev;
      this.info = info;
      if (align != null)
        this.align = align;
    }
    function inScope(state, varname) {
      if (!trackScope)
        return false;
      for (var v = state.localVars; v; v = v.next)
        if (v.name == varname)
          return true;
      for (var cx = state.context; cx; cx = cx.prev) {
        for (var v = cx.vars; v; v = v.next)
          if (v.name == varname)
            return true;
      }
    }
    function parseJS(state, style, type, content, stream) {
      var cc = state.cc;
      cx.state = state;
      cx.stream = stream;
      cx.marked = null, cx.cc = cc;
      cx.style = style;
      if (!state.lexical.hasOwnProperty("align"))
        state.lexical.align = true;
      while (true) {
        var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
        if (combinator(type, content)) {
          while (cc.length && cc[cc.length - ].lex)
            cc.pop()();
          if (cx.marked)
            return cx.marked;
          if (type == "variable" && inScope(state, content))
            return "variable-";
          return style;
        }
      }
    }
    var cx = { state: null, column: null, marked: null, cc: null };
    function pass() {
      for (var i = arguments.length - ; i >= ; i--)
        cx.cc.push(arguments[i]);
    }
    function cont() {
      pass.apply(null, arguments);
      return true;
    }
    function inList(name, list) {
      for (var v = list; v; v = v.next)
        if (v.name == name)
          return true;
      return false;
    }
    function register(varname) {
      var state = cx.state;
      cx.marked = "def";
      if (!trackScope)
        return;
      if (state.context) {
        if (state.lexical.info == "var" && state.context && state.context.block) {
          var newContext = registerVarScoped(varname, state.context);
          if (newContext != null) {
            state.context = newContext;
            return;
          }
        } else if (!inList(varname, state.localVars)) {
          state.localVars = new Var(varname, state.localVars);
          return;
        }
      }
      if (parserConfig.globalVars && !inList(varname, state.globalVars))
        state.globalVars = new Var(varname, state.globalVars);
    }
    function registerVarScoped(varname, context) {
      if (!context) {
        return null;
      } else if (context.block) {
        var inner = registerVarScoped(varname, context.prev);
        if (!inner)
          return null;
        if (inner == context.prev)
          return context;
        return new Context(inner, context.vars, true);
      } else if (inList(varname, context.vars)) {
        return context;
      } else {
        return new Context(context.prev, new Var(varname, context.vars), false);
      }
    }
    function isModifier(name) {
      return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly";
    }
    function Context(prev, vars, block) {
      this.prev = prev;
      this.vars = vars;
      this.block = block;
    }
    function Var(name, next) {
      this.name = name;
      this.next = next;
    }
    var defaultVars = new Var("this", new Var("arguments", null));
    function pushcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
      cx.state.localVars = defaultVars;
    }
    function pushblockcontext() {
      cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
      cx.state.localVars = null;
    }
    function popcontext() {
      cx.state.localVars = cx.state.context.vars;
      cx.state.context = cx.state.context.prev;
    }
    popcontext.lex = true;
    function pushlex(type, info) {
      var result = function() {
        var state = cx.state, indent = state.indented;
        if (state.lexical.type == "stat")
          indent = state.lexical.indented;
        else
          for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
            indent = outer.indented;
        state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
      };
      result.lex = true;
      return result;
    }
    function poplex() {
      var state = cx.state;
      if (state.lexical.prev) {
        if (state.lexical.type == ")")
          state.indented = state.lexical.indented;
        state.lexical = state.lexical.prev;
      }
    }
    poplex.lex = true;
    function expect(wanted) {
      function exp(type) {
        if (type == wanted)
          return cont();
        else if (wanted == ";" || type == "}" || type == ")" || type == "]")
          return pass();
        else
          return cont(exp);
      }
      return exp;
    }
    function statement(type, value) {
      if (type == "var")
        return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
      if (type == "keyword a")
        return cont(pushlex("form"), parenExpr, statement, poplex);
      if (type == "keyword b")
        return cont(pushlex("form"), statement, poplex);
      if (type == "keyword d")
        return cx.stream.match(/^\s$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
      if (type == "debugger")
        return cont(expect(";"));
      if (type == "{")
        return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
      if (type == ";")
        return cont();
      if (type == "if") {
        if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - ] == poplex)
          cx.state.cc.pop()();
        return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
      }
      if (type == "function")
        return cont(functiondef);
      if (type == "for")
        return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
      if (type == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form", type == "class" ? type : value), className, poplex);
      }
      if (type == "variable") {
        if (isTS && value == "declare") {
          cx.marked = "keyword";
          return cont(statement);
        } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s\w/, false)) {
          cx.marked = "keyword";
          if (value == "enum")
            return cont(enumdef);
          else if (value == "type")
            return cont(typename, expect("operator"), typeexpr, expect(";"));
          else
            return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex);
        } else if (isTS && value == "namespace") {
          cx.marked = "keyword";
          return cont(pushlex("form"), expression, statement, poplex);
        } else if (isTS && value == "abstract") {
          cx.marked = "keyword";
          return cont(statement);
        } else {
          return cont(pushlex("stat"), maybelabel);
        }
      }
      if (type == "switch")
        return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block, poplex, poplex, popcontext);
      if (type == "case")
        return cont(expression, expect(":"));
      if (type == "default")
        return cont(expect(":"));
      if (type == "catch")
        return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
      if (type == "export")
        return cont(pushlex("stat"), afterExport, poplex);
      if (type == "import")
        return cont(pushlex("stat"), afterImport, poplex);
      if (type == "async")
        return cont(statement);
      if (value == "@")
        return cont(expression, statement);
      return pass(pushlex("stat"), expression, expect(";"), poplex);
    }
    function maybeCatchBinding(type) {
      if (type == "(")
        return cont(funarg, expect(")"));
    }
    function expression(type, value) {
      return expressionInner(type, value, false);
    }
    function expressionNoComma(type, value) {
      return expressionInner(type, value, true);
    }
    function parenExpr(type) {
      if (type != "(")
        return pass();
      return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
    }
    function expressionInner(type, value, noComma) {
      if (cx.state.fatArrowAt == cx.stream.start) {
        var body = noComma ? arrowBodyNoComma : arrowBody;
        if (type == "(")
          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
        else if (type == "variable")
          return pass(pushcontext, pattern, expect("=>"), body, popcontext);
      }
      var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
      if (atomicTypes.hasOwnProperty(type))
        return cont(maybeop);
      if (type == "function")
        return cont(functiondef, maybeop);
      if (type == "class" || isTS && value == "interface") {
        cx.marked = "keyword";
        return cont(pushlex("form"), classExpression, poplex);
      }
      if (type == "keyword c" || type == "async")
        return cont(noComma ? expressionNoComma : expression);
      if (type == "(")
        return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
      if (type == "operator" || type == "spread")
        return cont(noComma ? expressionNoComma : expression);
      if (type == "[")
        return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
      if (type == "{")
        return contCommasep(objprop, "}", null, maybeop);
      if (type == "quasi")
        return pass(quasi, maybeop);
      if (type == "new")
        return cont(maybeTarget(noComma));
      return cont();
    }
    function maybeexpression(type) {
      if (type.match(/[;\}\)\],]/))
        return pass();
      return pass(expression);
    }
    function maybeoperatorComma(type, value) {
      if (type == ",")
        return cont(maybeexpression);
      return maybeoperatorNoComma(type, value, false);
    }
    function maybeoperatorNoComma(type, value, noComma) {
      var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
      var expr = noComma == false ? expression : expressionNoComma;
      if (type == "=>")
        return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
      if (type == "operator") {
        if (/\+\+|--/.test(value) || isTS && value == "!")
          return cont(me);
        if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]>)>\s\(/, false))
          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
        if (value == "?")
          return cont(expression, expect(":"), expr);
        return cont(expr);
      }
      if (type == "quasi") {
        return pass(quasi, me);
      }
      if (type == ";")
        return;
      if (type == "(")
        return contCommasep(expressionNoComma, ")", "call", me);
      if (type == ".")
        return cont(property, me);
      if (type == "[")
        return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
      if (isTS && value == "as") {
        cx.marked = "keyword";
        return cont(typeexpr, me);
      }
      if (type == "regexp") {
        cx.state.lastType = cx.marked = "operator";
        cx.stream.backUp(cx.stream.pos - cx.stream.start - );
        return cont(expr);
      }
    }
    function quasi(type, value) {
      if (type != "quasi")
        return pass();
      if (value.slice(value.length - ) != "${")
        return cont(quasi);
      return cont(maybeexpression, continueQuasi);
    }
    function continueQuasi(type) {
      if (type == "}") {
        cx.marked = "string-";
        cx.state.tokenize = tokenQuasi;
        return cont(quasi);
      }
    }
    function arrowBody(type) {
      findFatArrow(cx.stream, cx.state);
      return pass(type == "{" ? statement : expression);
    }
    function arrowBodyNoComma(type) {
      findFatArrow(cx.stream, cx.state);
      return pass(type == "{" ? statement : expressionNoComma);
    }
    function maybeTarget(noComma) {
      return function(type) {
        if (type == ".")
          return cont(noComma ? targetNoComma : target);
        else if (type == "variable" && isTS)
          return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
        else
          return pass(noComma ? expressionNoComma : expression);
      };
    }
    function target(_, value) {
      if (value == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorComma);
      }
    }
    function targetNoComma(_, value) {
      if (value == "target") {
        cx.marked = "keyword";
        return cont(maybeoperatorNoComma);
      }
    }
    function maybelabel(type) {
      if (type == ":")
        return cont(poplex, statement);
      return pass(maybeoperatorComma, expect(";"), poplex);
    }
    function property(type) {
      if (type == "variable") {
        cx.marked = "property";
        return cont();
      }
    }
    function objprop(type, value) {
      if (type == "async") {
        cx.marked = "property";
        return cont(objprop);
      } else if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        if (value == "get" || value == "set")
          return cont(getterSetter);
        var m;
        if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s:\s/, false)))
          cx.state.fatArrowAt = cx.stream.pos + m[].length;
        return cont(afterprop);
      } else if (type == "number" || type == "string") {
        cx.marked = jsonldMode ? "property" : cx.style + " property";
        return cont(afterprop);
      } else if (type == "jsonld-keyword") {
        return cont(afterprop);
      } else if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type == "[") {
        return cont(expression, maybetype, expect("]"), afterprop);
      } else if (type == "spread") {
        return cont(expressionNoComma, afterprop);
      } else if (value == "") {
        cx.marked = "keyword";
        return cont(objprop);
      } else if (type == ":") {
        return pass(afterprop);
      }
    }
    function getterSetter(type) {
      if (type != "variable")
        return pass(afterprop);
      cx.marked = "property";
      return cont(functiondef);
    }
    function afterprop(type) {
      if (type == ":")
        return cont(expressionNoComma);
      if (type == "(")
        return pass(functiondef);
    }
    function commasep(what, end, sep) {
      function proceed(type, value) {
        if (sep ? sep.indexOf(type) > - : type == ",") {
          var lex = cx.state.lexical;
          if (lex.info == "call")
            lex.pos = (lex.pos || ) + ;
          return cont(function(type, value) {
            if (type == end || value == end)
              return pass();
            return pass(what);
          }, proceed);
        }
        if (type == end || value == end)
          return cont();
        if (sep && sep.indexOf(";") > -)
          return pass(what);
        return cont(expect(end));
      }
      return function(type, value) {
        if (type == end || value == end)
          return cont();
        return pass(what, proceed);
      };
    }
    function contCommasep(what, end, info) {
      for (var i = ; i < arguments.length; i++)
        cx.cc.push(arguments[i]);
      return cont(pushlex(end, info), commasep(what, end), poplex);
    }
    function block(type) {
      if (type == "}")
        return cont();
      return pass(statement, block);
    }
    function maybetype(type, value) {
      if (isTS) {
        if (type == ":")
          return cont(typeexpr);
        if (value == "?")
          return cont(maybetype);
      }
    }
    function maybetypeOrIn(type, value) {
      if (isTS && (type == ":" || value == "in"))
        return cont(typeexpr);
    }
    function mayberettype(type) {
      if (isTS && type == ":") {
        if (cx.stream.match(/^\s\w+\s+is\b/, false))
          return cont(expression, isKW, typeexpr);
        else
          return cont(typeexpr);
      }
    }
    function isKW(_, value) {
      if (value == "is") {
        cx.marked = "keyword";
        return cont();
      }
    }
    function typeexpr(type, value) {
      if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
        cx.marked = "keyword";
        return cont(value == "typeof" ? expressionNoComma : typeexpr);
      }
      if (type == "variable" || value == "void") {
        cx.marked = "type";
        return cont(afterType);
      }
      if (value == "|" || value == "&")
        return cont(typeexpr);
      if (type == "string" || type == "number" || type == "atom")
        return cont(afterType);
      if (type == "[")
        return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
      if (type == "{")
        return cont(pushlex("}"), typeprops, poplex, afterType);
      if (type == "(")
        return cont(commasep(typearg, ")"), maybeReturnType, afterType);
      if (type == "<")
        return cont(commasep(typeexpr, ">"), typeexpr);
      if (type == "quasi") {
        return pass(quasiType, afterType);
      }
    }
    function maybeReturnType(type) {
      if (type == "=>")
        return cont(typeexpr);
    }
    function typeprops(type) {
      if (type.match(/[\}\)\]]/))
        return cont();
      if (type == "," || type == ";")
        return cont(typeprops);
      return pass(typeprop, typeprops);
    }
    function typeprop(type, value) {
      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(typeprop);
      } else if (value == "?" || type == "number" || type == "string") {
        return cont(typeprop);
      } else if (type == ":") {
        return cont(typeexpr);
      } else if (type == "[") {
        return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
      } else if (type == "(") {
        return pass(functiondecl, typeprop);
      } else if (!type.match(/[;\}\)\],]/)) {
        return cont();
      }
    }
    function quasiType(type, value) {
      if (type != "quasi")
        return pass();
      if (value.slice(value.length - ) != "${")
        return cont(quasiType);
      return cont(typeexpr, continueQuasiType);
    }
    function continueQuasiType(type) {
      if (type == "}") {
        cx.marked = "string-";
        cx.state.tokenize = tokenQuasi;
        return cont(quasiType);
      }
    }
    function typearg(type, value) {
      if (type == "variable" && cx.stream.match(/^\s[?:]/, false) || value == "?")
        return cont(typearg);
      if (type == ":")
        return cont(typeexpr);
      if (type == "spread")
        return cont(typearg);
      return pass(typeexpr);
    }
    function afterType(type, value) {
      if (value == "<")
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
      if (value == "|" || type == "." || value == "&")
        return cont(typeexpr);
      if (type == "[")
        return cont(typeexpr, expect("]"), afterType);
      if (value == "extends" || value == "implements") {
        cx.marked = "keyword";
        return cont(typeexpr);
      }
      if (value == "?")
        return cont(typeexpr, expect(":"), typeexpr);
    }
    function maybeTypeArgs(_, value) {
      if (value == "<")
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
    }
    function typeparam() {
      return pass(typeexpr, maybeTypeDefault);
    }
    function maybeTypeDefault(_, value) {
      if (value == "=")
        return cont(typeexpr);
    }
    function vardef(_, value) {
      if (value == "enum") {
        cx.marked = "keyword";
        return cont(enumdef);
      }
      return pass(pattern, maybetype, maybeAssign, vardefCont);
    }
    function pattern(type, value) {
      if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(pattern);
      }
      if (type == "variable") {
        register(value);
        return cont();
      }
      if (type == "spread")
        return cont(pattern);
      if (type == "[")
        return contCommasep(eltpattern, "]");
      if (type == "{")
        return contCommasep(proppattern, "}");
    }
    function proppattern(type, value) {
      if (type == "variable" && !cx.stream.match(/^\s:/, false)) {
        register(value);
        return cont(maybeAssign);
      }
      if (type == "variable")
        cx.marked = "property";
      if (type == "spread")
        return cont(pattern);
      if (type == "}")
        return pass();
      if (type == "[")
        return cont(expression, expect("]"), expect(":"), proppattern);
      return cont(expect(":"), pattern, maybeAssign);
    }
    function eltpattern() {
      return pass(pattern, maybeAssign);
    }
    function maybeAssign(_type, value) {
      if (value == "=")
        return cont(expressionNoComma);
    }
    function vardefCont(type) {
      if (type == ",")
        return cont(vardef);
    }
    function maybeelse(type, value) {
      if (type == "keyword b" && value == "else")
        return cont(pushlex("form", "else"), statement, poplex);
    }
    function forspec(type, value) {
      if (value == "await")
        return cont(forspec);
      if (type == "(")
        return cont(pushlex(")"), forspec, poplex);
    }
    function forspec(type) {
      if (type == "var")
        return cont(vardef, forspec);
      if (type == "variable")
        return cont(forspec);
      return pass(forspec);
    }
    function forspec(type, value) {
      if (type == ")")
        return cont();
      if (type == ";")
        return cont(forspec);
      if (value == "in" || value == "of") {
        cx.marked = "keyword";
        return cont(expression, forspec);
      }
      return pass(expression, forspec);
    }
    function functiondef(type, value) {
      if (value == "") {
        cx.marked = "keyword";
        return cont(functiondef);
      }
      if (type == "variable") {
        register(value);
        return cont(functiondef);
      }
      if (type == "(")
        return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
      if (isTS && value == "<")
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
    }
    function functiondecl(type, value) {
      if (value == "") {
        cx.marked = "keyword";
        return cont(functiondecl);
      }
      if (type == "variable") {
        register(value);
        return cont(functiondecl);
      }
      if (type == "(")
        return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
      if (isTS && value == "<")
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
    }
    function typename(type, value) {
      if (type == "keyword" || type == "variable") {
        cx.marked = "type";
        return cont(typename);
      } else if (value == "<") {
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
      }
    }
    function funarg(type, value) {
      if (value == "@")
        cont(expression, funarg);
      if (type == "spread")
        return cont(funarg);
      if (isTS && isModifier(value)) {
        cx.marked = "keyword";
        return cont(funarg);
      }
      if (isTS && type == "this")
        return cont(maybetype, maybeAssign);
      return pass(pattern, maybetype, maybeAssign);
    }
    function classExpression(type, value) {
      if (type == "variable")
        return className(type, value);
      return classNameAfter(type, value);
    }
    function className(type, value) {
      if (type == "variable") {
        register(value);
        return cont(classNameAfter);
      }
    }
    function classNameAfter(type, value) {
      if (value == "<")
        return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
      if (value == "extends" || value == "implements" || isTS && type == ",") {
        if (value == "implements")
          cx.marked = "keyword";
        return cont(isTS ? typeexpr : expression, classNameAfter);
      }
      if (type == "{")
        return cont(pushlex("}"), classBody, poplex);
    }
    function classBody(type, value) {
      if (type == "async" || type == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa-\uffff]/, false)) {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (type == "variable" || cx.style == "keyword") {
        cx.marked = "property";
        return cont(classfield, classBody);
      }
      if (type == "number" || type == "string")
        return cont(classfield, classBody);
      if (type == "[")
        return cont(expression, maybetype, expect("]"), classfield, classBody);
      if (value == "") {
        cx.marked = "keyword";
        return cont(classBody);
      }
      if (isTS && type == "(")
        return pass(functiondecl, classBody);
      if (type == ";" || type == ",")
        return cont(classBody);
      if (type == "}")
        return cont();
      if (value == "@")
        return cont(expression, classBody);
    }
    function classfield(type, value) {
      if (value == "!")
        return cont(classfield);
      if (value == "?")
        return cont(classfield);
      if (type == ":")
        return cont(typeexpr, maybeAssign);
      if (value == "=")
        return cont(expressionNoComma);
      var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
      return pass(isInterface ? functiondecl : functiondef);
    }
    function afterExport(type, value) {
      if (value == "") {
        cx.marked = "keyword";
        return cont(maybeFrom, expect(";"));
      }
      if (value == "default") {
        cx.marked = "keyword";
        return cont(expression, expect(";"));
      }
      if (type == "{")
        return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
      return pass(statement);
    }
    function exportField(type, value) {
      if (value == "as") {
        cx.marked = "keyword";
        return cont(expect("variable"));
      }
      if (type == "variable")
        return pass(expressionNoComma, exportField);
    }
    function afterImport(type) {
      if (type == "string")
        return cont();
      if (type == "(")
        return pass(expression);
      if (type == ".")
        return pass(maybeoperatorComma);
      return pass(importSpec, maybeMoreImports, maybeFrom);
    }
    function importSpec(type, value) {
      if (type == "{")
        return contCommasep(importSpec, "}");
      if (type == "variable")
        register(value);
      if (value == "")
        cx.marked = "keyword";
      return cont(maybeAs);
    }
    function maybeMoreImports(type) {
      if (type == ",")
        return cont(importSpec, maybeMoreImports);
    }
    function maybeAs(_type, value) {
      if (value == "as") {
        cx.marked = "keyword";
        return cont(importSpec);
      }
    }
    function maybeFrom(_type, value) {
      if (value == "from") {
        cx.marked = "keyword";
        return cont(expression);
      }
    }
    function arrayLiteral(type) {
      if (type == "]")
        return cont();
      return pass(commasep(expressionNoComma, "]"));
    }
    function enumdef() {
      return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
    }
    function enummember() {
      return pass(pattern, maybeAssign);
    }
    function isContinuedStatement(state, textAfter) {
      return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt()) || /[,.]/.test(textAfter.charAt());
    }
    function expressionAllowed(stream, state, backUp) {
      return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s$/.test(stream.string.slice(, stream.pos - (backUp || )));
    }
    return {
      startState: function(basecolumn) {
        var state = {
          tokenize: tokenBase,
          lastType: "sof",
          cc: [],
          lexical: new JSLexical((basecolumn || ) - indentUnit, , "block", false),
          localVars: parserConfig.localVars,
          context: parserConfig.localVars && new Context(null, null, false),
          indented: basecolumn || 
        };
        if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
          state.globalVars = parserConfig.globalVars;
        return state;
      },
      token: function(stream, state) {
        if (stream.sol()) {
          if (!state.lexical.hasOwnProperty("align"))
            state.lexical.align = false;
          state.indented = stream.indentation();
          findFatArrow(stream, state);
        }
        if (state.tokenize != tokenComment && stream.eatSpace())
          return null;
        var style = state.tokenize(stream, state);
        if (type == "comment")
          return style;
        state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
        return parseJS(state, style, type, content, stream);
      },
      indent: function(state, textAfter) {
        if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)
          return CodeMirror.Pass;
        if (state.tokenize != tokenBase)
          return ;
        var firstChar = textAfter && textAfter.charAt(), lexical = state.lexical, top;
        if (!/^\selse\b/.test(textAfter))
          for (var i = state.cc.length - ; i >= ; --i) {
            var c = state.cc[i];
            if (c == poplex)
              lexical = lexical.prev;
            else if (c != maybeelse && c != popcontext)
              break;
          }
        while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - ]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-:?[\(]/.test(textAfter)))
          lexical = lexical.prev;
        if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
          lexical = lexical.prev;
        var type = lexical.type, closing = firstChar == type;
        if (type == "vardef")
          return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length +  : );
        else if (type == "form" && firstChar == "{")
          return lexical.indented;
        else if (type == "form")
          return lexical.indented + indentUnit;
        else if (type == "stat")
          return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : );
        else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
          return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit :   indentUnit);
        else if (lexical.align)
          return lexical.column + (closing ?  : );
        else
          return lexical.indented + (closing ?  : indentUnit);
      },
      electricInput: /^\s(?:case .?:|default:|\{|\})$/,
      blockCommentStart: jsonMode ? null : "/",
      blockCommentEnd: jsonMode ? null : "/",
      blockCommentContinue: jsonMode ? null : "  ",
      lineComment: jsonMode ? null : "//",
      fold: "brace",
      closeBrackets: "()[]{}''\"\"``",
      helperType: jsonMode ? "json" : "javascript",
      jsonldMode,
      jsonMode,
      expressionAllowed,
      skipExpression: function(state) {
        parseJS(state, "atom", "atom", "true", new CodeMirror.StringStream("", , null));
      }
    };
  });
  CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);
  CodeMirror.defineMIME("text/javascript", "javascript");
  CodeMirror.defineMIME("text/ecmascript", "javascript");
  CodeMirror.defineMIME("application/javascript", "javascript");
  CodeMirror.defineMIME("application/x-javascript", "javascript");
  CodeMirror.defineMIME("application/ecmascript", "javascript");
  CodeMirror.defineMIME("application/json", {
    name: "javascript",
    json: true
  });
  CodeMirror.defineMIME("application/x-json", {
    name: "javascript",
    json: true
  });
  CodeMirror.defineMIME("application/manifest+json", {
    name: "javascript",
    json: true
  });
  CodeMirror.defineMIME("application/ld+json", {
    name: "javascript",
    jsonld: true
  });
  CodeMirror.defineMIME("text/typescript", {
    name: "javascript",
    typescript: true
  });
  CodeMirror.defineMIME("application/typescript", {
    name: "javascript",
    typescript: true
  });
});

// src/editor/mode/custom_overlay.js
(function(mod) {
  mod(window.CodeMirror);
})(function(CodeMirror) {
  "use strict";
  CodeMirror.customOverlayMode = function(base, overlay, combine) {
    return {
      startState: function() {
        return {
          base: CodeMirror.startState(base),
          overlay: CodeMirror.startState(overlay),
          basePos: ,
          baseCur: null,
          overlayPos: ,
          overlayCur: null,
          streamSeen: null
        };
      },
      copyState: function(state) {
        return {
          base: CodeMirror.copyState(base, state.base),
          overlay: CodeMirror.copyState(overlay, state.overlay),
          basePos: state.basePos,
          baseCur: null,
          overlayPos: state.overlayPos,
          overlayCur: null
        };
      },
      token: function(stream, state) {
        if (stream != state.streamSeen || Math.min(state.basePos, state.overlayPos) < stream.start) {
          state.streamSeen = stream;
          state.basePos = state.overlayPos = stream.start;
        }
        if (stream.start == state.basePos) {
          state.baseCur = base.token(stream, state.base);
          state.basePos = stream.pos;
        }
        if (stream.start == state.overlayPos) {
          stream.pos = stream.start;
          state.overlayCur = overlay.token(stream, state.overlay);
          state.overlayPos = stream.pos;
        }
        stream.pos = Math.min(state.basePos, state.overlayPos);
        if (state.baseCur && state.overlayCur && state.baseCur.contains("line-HyperMD-codeblock")) {
          state.overlayCur = state.overlayCur.replace("line-templater-inline", "");
          state.overlayCur += ` line-background-HyperMD-codeblock-bg`;
        }
        if (state.overlayCur == null)
          return state.baseCur;
        else if (state.baseCur != null && state.overlay.combineTokens || combine && state.overlay.combineTokens == null)
          return state.baseCur + " " + state.overlayCur;
        else
          return state.overlayCur;
      },
      indent: base.indent && function(state, textAfter, line) {
        return base.indent(state.base, textAfter, line);
      },
      electricChars: base.electricChars,
      innerMode: function(state) {
        return { state: state.base, mode: base };
      },
      blankLine: function(state) {
        var baseToken, overlayToken;
        if (base.blankLine)
          baseToken = base.blankLine(state.base);
        if (overlay.blankLine)
          overlayToken = overlay.blankLine(state.overlay);
        return overlayToken == null ? baseToken : combine && baseToken != null ? baseToken + " " + overlayToken : overlayToken;
      }
    };
  };
});

// src/editor/Editor.ts
var import_language = __toModule(require("@codemirror/language"));
var TP_CMD_TOKEN_CLASS = "templater-command";
var TP_INLINE_CLASS = "templater-inline";
var TP_OPENING_TAG_TOKEN_CLASS = "templater-opening-tag";
var TP_CLOSING_TAG_TOKEN_CLASS = "templater-closing-tag";
var TP_INTERPOLATION_TAG_TOKEN_CLASS = "templater-interpolation-tag";
var TP_EXEC_TAG_TOKEN_CLASS = "templater-execution-tag";
var Editor = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.cursor_jumper = new CursorJumper();
  }
  async setup() {
    await this.registerCodeMirrorMode();
    this.plugin.registerEditorSuggest(new Autocomplete());
    if (import_obsidian.Platform.isDesktopApp && this.plugin.settings.syntax_highlighting) {
      this.plugin.registerEditorExtension(import_language.StreamLanguage.define(window.CodeMirror.getMode({}, { name: "templater" })));
    }
  }
  async jump_to_next_cursor_location(file = null, auto_jump = false) {
    if (auto_jump && !this.plugin.settings.auto_jump_to_cursor) {
      return;
    }
    if (file && app.workspace.getActiveFile() !== file) {
      return;
    }
    await this.cursor_jumper.jump_to_next_cursor_location();
  }
  async registerCodeMirrorMode() {
    if (!this.plugin.settings.syntax_highlighting) {
      return;
    }
    if (import_obsidian.Platform.isMobileApp) {
      return;
    }
    const js_mode = window.CodeMirror.getMode({}, "javascript");
    if (js_mode.name === "null") {
      log_error(new TemplaterError("Javascript syntax mode couldn't be found, can't enable syntax highlighting."));
      return;
    }
    const overlay_mode = window.CodeMirror.customOverlayMode;
    if (overlay_mode == null) {
      log_error(new TemplaterError("Couldn't find customOverlayMode, can't enable syntax highlighting."));
      return;
    }
    window.CodeMirror.defineMode("templater", function(config) {
      const templaterOverlay = {
        startState: function() {
          const js_state = window.CodeMirror.startState(js_mode);
          return {
            ...js_state,
            inCommand: false,
            tag_class: "",
            freeLine: false
          };
        },
        copyState: function(state) {
          const js_state = window.CodeMirror.startState(js_mode);
          const new_state = {
            ...js_state,
            inCommand: state.inCommand,
            tag_class: state.tag_class,
            freeLine: state.freeLine
          };
          return new_state;
        },
        blankLine: function(state) {
          if (state.inCommand) {
            return `line-background-templater-command-bg`;
          }
          return null;
        },
        token: function(stream, state) {
          if (stream.sol() && state.inCommand) {
            state.freeLine = true;
          }
          if (state.inCommand) {
            let keywords = "";
            if (stream.match(/[-_]{,}%>/, true)) {
              state.inCommand = false;
              state.freeLine = false;
              const tag_class = state.tag_class;
              state.tag_class = "";
              return `line-${TP_INLINE_CLASS} ${TP_CMD_TOKEN_CLASS} ${TP_CLOSING_TAG_TOKEN_CLASS} ${tag_class}`;
            }
            const js_result = js_mode.token && js_mode.token(stream, state);
            if (stream.peek() == null && state.freeLine) {
              keywords += ` line-background-templater-command-bg`;
            }
            if (!state.freeLine) {
              keywords += ` line-${TP_INLINE_CLASS}`;
            }
            return `${keywords} ${TP_CMD_TOKEN_CLASS} ${js_result}`;
          }
          const match = stream.match(/<%[-_]{,}\s([+]{,})/, true);
          if (match != null) {
            switch (match[]) {
              case "":
                state.tag_class = TP_EXEC_TAG_TOKEN_CLASS;
                break;
              default:
                state.tag_class = TP_INTERPOLATION_TAG_TOKEN_CLASS;
                break;
            }
            state.inCommand = true;
            return `line-${TP_INLINE_CLASS} ${TP_CMD_TOKEN_CLASS} ${TP_OPENING_TAG_TOKEN_CLASS} ${state.tag_class}`;
          }
          while (stream.next() != null && !stream.match(/<%/, false))
            ;
          return null;
        }
      };
      return overlay_mode(window.CodeMirror.getMode(config, "hypermd"), templaterOverlay);
    });
  }
};

// src/main.ts
var TemplaterPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.load_settings();
    this.templater = new Templater(this);
    await this.templater.setup();
    this.editor_handler = new Editor(this);
    await this.editor_handler.setup();
    this.fuzzy_suggester = new FuzzySuggester(this);
    this.event_handler = new EventHandler(this, this.templater, this.settings);
    this.event_handler.setup();
    this.command_handler = new CommandHandler(this);
    this.command_handler.setup();
    (, import_obsidian.addIcon)("templater-icon", ICON_DATA);
    if (this.settings.enable_ribbon_icon) {
      this.addRibbonIcon("templater-icon", "Templater", async () => {
        this.fuzzy_suggester.insert_template();
      }).setAttribute("id", "rb-templater-icon");
    }
    this.addSettingTab(new TemplaterSettingTab(this));
    app.workspace.onLayoutReady(() => {
      this.templater.execute_startup_scripts();
    });
  }
  async save_settings() {
    await this.saveData(this.settings);
  }
  async load_settings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
};
