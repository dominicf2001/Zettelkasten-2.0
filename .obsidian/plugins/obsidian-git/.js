/
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source visit the plugins github repository (https://github.com/denolehov/obsidian-git)
/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (, fn[__getOwnPropNames(fn)[]])(fn = )), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (, cb[__getOwnPropNames(cb)[]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/base-js@../node_modules/base-js/index.js
var require_base_js = __commonJS({
  "node_modules/.pnpm/base-js@../node_modules/base-js/index.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof UintArray !== "undefined" ? UintArray : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";
    for (i = , len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt()] = ;
    revLookup["_".charCodeAt()] = ;
    function getLens(b) {
      var len = b.length;
      if (len %  > ) {
        throw new Error("Invalid string. Length must be a multiple of ");
      }
      var validLen = b.indexOf("=");
      if (validLen === -)
        validLen = len;
      var placeHoldersLen = validLen === len ?  :  - validLen % ;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b) {
      var lens = getLens(b);
      var validLen = lens[];
      var placeHoldersLen = lens[];
      return (validLen + placeHoldersLen)   /  - placeHoldersLen;
    }
    function _byteLength(b, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen)   /  - placeHoldersLen;
    }
    function toByteArray(b) {
      var tmp;
      var lens = getLens(b);
      var validLen = lens[];
      var placeHoldersLen = lens[];
      var arr = new Arr(_byteLength(b, validLen, placeHoldersLen));
      var curByte = ;
      var len = placeHoldersLen >  ? validLen -  : validLen;
      var i;
      for (i = ; i < len; i += ) {
        tmp = revLookup[b.charCodeAt(i)] <<  | revLookup[b.charCodeAt(i + )] <<  | revLookup[b.charCodeAt(i + )] <<  | revLookup[b.charCodeAt(i + )];
        arr[curByte++] = tmp >>  & ;
        arr[curByte++] = tmp >>  & ;
        arr[curByte++] = tmp & ;
      }
      if (placeHoldersLen === ) {
        tmp = revLookup[b.charCodeAt(i)] <<  | revLookup[b.charCodeAt(i + )] >> ;
        arr[curByte++] = tmp & ;
      }
      if (placeHoldersLen === ) {
        tmp = revLookup[b.charCodeAt(i)] <<  | revLookup[b.charCodeAt(i + )] <<  | revLookup[b.charCodeAt(i + )] >> ;
        arr[curByte++] = tmp >>  & ;
        arr[curByte++] = tmp & ;
      }
      return arr;
    }
    function tripletToBase(num) {
      return lookup[num >>  & ] + lookup[num >>  & ] + lookup[num >>  & ] + lookup[num & ];
    }
    function encodeChunk(uint, start, end) {
      var tmp;
      var output = [];
      for (var i = start; i < end; i += ) {
        tmp = (uint[i] <<  & ) + (uint[i + ] <<  & ) + (uint[i + ] & );
        output.push(tripletToBase(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint) {
      var tmp;
      var len = uint.length;
      var extraBytes = len % ;
      var parts = [];
      var maxChunkLength = ;
      for (var i = , len = len - extraBytes; i < len; i += maxChunkLength) {
        parts.push(encodeChunk(uint, i, i + maxChunkLength > len ? len : i + maxChunkLength));
      }
      if (extraBytes === ) {
        tmp = uint[len - ];
        parts.push(
          lookup[tmp >> ] + lookup[tmp <<  & ] + "=="
        );
      } else if (extraBytes === ) {
        tmp = (uint[len - ] << ) + uint[len - ];
        parts.push(
          lookup[tmp >> ] + lookup[tmp >>  & ] + lookup[tmp <<  & ] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/.pnpm/ieee@../node_modules/ieee/index.js
var require_ieee = __commonJS({
  "node_modules/.pnpm/ieee@../node_modules/ieee/index.js"(exports) {
    init_polyfill_buffer();
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes   - mLen - ;
      var eMax = ( << eLen) - ;
      var eBias = eMax >> ;
      var nBits = -;
      var i = isLE ? nBytes -  : ;
      var d = isLE ? - : ;
      var s = buffer[offset + i];
      i += d;
      e = s & ( << -nBits) - ;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > ; e = e   + buffer[offset + i], i += d, nBits -= ) {
      }
      m = e & ( << -nBits) - ;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > ; m = m   + buffer[offset + i], i += d, nBits -= ) {
      }
      if (e === ) {
        e =  - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? - : )  Infinity;
      } else {
        m = m + Math.pow(, mLen);
        e = e - eBias;
      }
      return (s ? - : )  m  Math.pow(, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes   - mLen - ;
      var eMax = ( << eLen) - ;
      var eBias = eMax >> ;
      var rt = mLen ===  ? Math.pow(, -) - Math.pow(, -) : ;
      var i = isLE ?  : nBytes - ;
      var d = isLE ?  : -;
      var s = value <  || value ===  &&  / value <  ?  : ;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ?  : ;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN);
        if (value  (c = Math.pow(, -e)) < ) {
          e--;
          c = ;
        }
        if (e + eBias >= ) {
          value += rt / c;
        } else {
          value += rt  Math.pow(,  - eBias);
        }
        if (value  c >= ) {
          e++;
          c /= ;
        }
        if (e + eBias >= eMax) {
          m = ;
          e = eMax;
        } else if (e + eBias >= ) {
          m = (value  c - )  Math.pow(, mLen);
          e = e + eBias;
        } else {
          m = value  Math.pow(, eBias - )  Math.pow(, mLen);
          e = ;
        }
      }
      for (; mLen >= ; buffer[offset + i] = m & , i += d, m /= , mLen -= ) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > ; buffer[offset + i] = e & , i += d, e /= , eLen -= ) {
      }
      buffer[offset + i - d] |= s  ;
    };
  }
});

// node_modules/.pnpm/buffer@../node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/.pnpm/buffer@../node_modules/buffer/index.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    var base = require_base_js();
    var ieee = require_ieee();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = ;
    var K_MAX_LENGTH = ;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (UintArray) support which is required by `buffer` v.x. Use `buffer` v.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new UintArray();
        const proto = { foo: function() {
          return ;
        } };
        Object.setPrototypeOf(proto, UintArray.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === ;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this))
          return void ;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer.isBuffer(this))
          return void ;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new UintArray(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function Buffer(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer.poolSize = ;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer.prototype, UintArray.prototype);
    Object.setPrototypeOf(Buffer, UintArray);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < ) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= ) {
        return createBuffer(size);
      }
      if (fill !== void ) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size <  ?  : checked(size) | );
    }
    Buffer.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | ;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length <  ?  : checked(array.length) | ;
      const buf = createBuffer(length);
      for (let i = ; i < length; i += ) {
        buf[i] = array[i] & ;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, UintArray)) {
        const copy = new UintArray(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset <  || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || )) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void  && length === void ) {
        buf = new UintArray(array);
      } else if (length === void ) {
        buf = new UintArray(array, byteOffset);
      } else {
        buf = new UintArray(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | ;
        const buf = createBuffer(len);
        if (buf.length === ) {
          return buf;
        }
        obj.copy(buf, , , len);
        return buf;
      }
      if (obj.length !== void ) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer();
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: x" + K_MAX_LENGTH.toString() + " bytes");
      }
      return length | ;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = ;
      }
      return Buffer.alloc(+length);
    }
    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype;
    };
    Buffer.compare = function compare(a, b) {
      if (isInstance(a, UintArray))
        a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, UintArray))
        b = Buffer.from(b, b.offset, b.byteLength);
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError(
          'The "buf", "buf" arguments must be one of type Buffer or UintArray'
        );
      }
      if (a === b)
        return ;
      let x = a.length;
      let y = b.length;
      for (let i = , len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -;
      if (y < x)
        return ;
      return ;
    };
    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf":
        case "utf-":
        case "ascii":
        case "latin":
        case "binary":
        case "base":
        case "ucs":
        case "ucs-":
        case "utfle":
        case "utf-le":
          return true;
        default:
          return false;
      }
    };
    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === ) {
        return Buffer.alloc();
      }
      let i;
      if (length === void ) {
        length = ;
        for (i = ; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer.allocUnsafe(length);
      let pos = ;
      for (i = ; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, UintArray)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer.isBuffer(buf))
              buf = Buffer.from(buf);
            buf.copy(buffer, pos);
          } else {
            UintArray.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length >  && arguments[] === true;
      if (!mustMatch && len === )
        return ;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin":
          case "binary":
            return len;
          case "utf":
          case "utf-":
            return utfToBytes(string).length;
          case "ucs":
          case "ucs-":
          case "utfle":
          case "utf-le":
            return len  ;
          case "hex":
            return len >>> ;
          case "base":
            return baseToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? - : utfToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void  || start < ) {
        start = ;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void  || end > this.length) {
        end = this.length;
      }
      if (end <= ) {
        return "";
      }
      end >>>= ;
      start >>>= ;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf":
          case "utf-":
            return utfSlice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin":
          case "binary":
            return latinSlice(this, start, end);
          case "base":
            return baseSlice(this, start, end);
          case "ucs":
          case "ucs-":
          case "utfle":
          case "utf-le":
            return utfleSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer.prototype.swap = function swap() {
      const len = this.length;
      if (len %  !== ) {
        throw new RangeError("Buffer size must be a multiple of -bits");
      }
      for (let i = ; i < len; i += ) {
        swap(this, i, i + );
      }
      return this;
    };
    Buffer.prototype.swap = function swap() {
      const len = this.length;
      if (len %  !== ) {
        throw new RangeError("Buffer size must be a multiple of -bits");
      }
      for (let i = ; i < len; i += ) {
        swap(this, i, i + );
        swap(this, i + , i + );
      }
      return this;
    };
    Buffer.prototype.swap = function swap() {
      const len = this.length;
      if (len %  !== ) {
        throw new RangeError("Buffer size must be a multiple of -bits");
      }
      for (let i = ; i < len; i += ) {
        swap(this, i, i + );
        swap(this, i + , i + );
        swap(this, i + , i + );
        swap(this, i + , i + );
      }
      return this;
    };
    Buffer.prototype.toString = function toString() {
      const length = this.length;
      if (length === )
        return "";
      if (arguments.length === )
        return utfSlice(this, , length);
      return slowToString.apply(this, arguments);
    };
    Buffer.prototype.toLocaleString = Buffer.prototype.toString;
    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer.compare(this, b) === ;
    };
    Buffer.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", , max).replace(/(.{})/g, "$ ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }
    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, UintArray)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }
      if (!Buffer.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or UintArray. Received type ' + typeof target
        );
      }
      if (start === void ) {
        start = ;
      }
      if (end === void ) {
        end = target ? target.length : ;
      }
      if (thisStart === void ) {
        thisStart = ;
      }
      if (thisEnd === void ) {
        thisEnd = this.length;
      }
      if (start <  || end > target.length || thisStart <  || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return ;
      }
      if (thisStart >= thisEnd) {
        return -;
      }
      if (start >= end) {
        return ;
      }
      start >>>= ;
      end >>>= ;
      thisStart >>>= ;
      thisEnd >>>= ;
      if (this === target)
        return ;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = ; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -;
      if (y < x)
        return ;
      return ;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === )
        return -;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = ;
      } else if (byteOffset > ) {
        byteOffset = ;
      } else if (byteOffset < -) {
        byteOffset = -;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ?  : buffer.length - ;
      }
      if (byteOffset < )
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -;
        else
          byteOffset = buffer.length - ;
      } else if (byteOffset < ) {
        if (dir)
          byteOffset = ;
        else
          return -;
      }
      if (typeof val === "string") {
        val = Buffer.from(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        if (val.length === ) {
          return -;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & ;
        if (typeof UintArray.prototype.indexOf === "function") {
          if (dir) {
            return UintArray.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return UintArray.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = ;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void ) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs" || encoding === "ucs-" || encoding === "utfle" || encoding === "utf-le") {
          if (arr.length <  || val.length < ) {
            return -;
          }
          indexSize = ;
          arrLength /= ;
          valLength /= ;
          byteOffset /= ;
        }
      }
      function read(buf, i) {
        if (indexSize === ) {
          return buf[i];
        } else {
          return buf.readUIntBE(i  indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === - ?  : i - foundIndex)) {
            if (foundIndex === -)
              foundIndex = i;
            if (i - foundIndex +  === valLength)
              return foundIndex  indexSize;
          } else {
            if (foundIndex !== -)
              i -= i - foundIndex;
            foundIndex = -;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= ; i--) {
          let found = true;
          for (let j = ; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -;
    }
    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -;
    };
    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || ;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / ) {
        length = strLen / ;
      }
      let i;
      for (i = ; i < length; ++i) {
        const parsed = parseInt(string.substr(i  , ), );
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utfWrite(buf, string, offset, length) {
      return blitBuffer(utfToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function baseWrite(buf, string, offset, length) {
      return blitBuffer(baseToBytes(string), buf, offset, length);
    }
    function ucsWrite(buf, string, offset, length) {
      return blitBuffer(utfleToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void ) {
        encoding = "utf";
        length = this.length;
        offset = ;
      } else if (length === void  && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = ;
      } else if (isFinite(offset)) {
        offset = offset >>> ;
        if (isFinite(length)) {
          length = length >>> ;
          if (encoding === void )
            encoding = "utf";
        } else {
          encoding = length;
          length = void ;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void  || length > remaining)
        length = remaining;
      if (string.length >  && (length <  || offset < ) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf":
          case "utf-":
            return utfWrite(this, string, offset, length);
          case "ascii":
          case "latin":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base":
            return baseWrite(this, string, offset, length);
          case "ucs":
          case "ucs-":
          case "utfle":
          case "utf-le":
            return ucsWrite(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, )
      };
    };
    function baseSlice(buf, start, end) {
      if (start ===  && end === buf.length) {
        return base.fromByteArray(buf);
      } else {
        return base.fromByteArray(buf.slice(start, end));
      }
    }
    function utfSlice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte >  ?  : firstByte >  ?  : firstByte >  ?  : ;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case :
              if (firstByte < ) {
                codePoint = firstByte;
              }
              break;
            case :
              secondByte = buf[i + ];
              if ((secondByte & ) === ) {
                tempCodePoint = (firstByte & ) <<  | secondByte & ;
                if (tempCodePoint > ) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case :
              secondByte = buf[i + ];
              thirdByte = buf[i + ];
              if ((secondByte & ) ===  && (thirdByte & ) === ) {
                tempCodePoint = (firstByte & ) <<  | (secondByte & ) <<  | thirdByte & ;
                if (tempCodePoint >  && (tempCodePoint <  || tempCodePoint > )) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case :
              secondByte = buf[i + ];
              thirdByte = buf[i + ];
              fourthByte = buf[i + ];
              if ((secondByte & ) ===  && (thirdByte & ) ===  && (fourthByte & ) === ) {
                tempCodePoint = (firstByte & ) <<  | (secondByte & ) <<  | (thirdByte & ) <<  | fourthByte & ;
                if (tempCodePoint >  && tempCodePoint < ) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = ;
          bytesPerSequence = ;
        } else if (codePoint > ) {
          codePoint -= ;
          res.push(codePoint >>>  &  | );
          codePoint =  | codePoint & ;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = ;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = ;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & );
      }
      return ret;
    }
    function latinSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < )
        start = ;
      if (!end || end <  || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utfleSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = ; i < bytes.length - ; i += ) {
        res += String.fromCharCode(bytes[i] + bytes[i + ]  );
      }
      return res;
    }
    Buffer.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void  ? len : ~~end;
      if (start < ) {
        start += len;
        if (start < )
          start = ;
      } else if (start > len) {
        start = len;
      }
      if (end < ) {
        end += len;
        if (end < )
          end = ;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset %  !==  || offset < )
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset >>> ;
      byteLength = byteLength >>> ;
      if (!noAssert)
        checkOffset(offset, byteLength, this.length);
      let val = this[offset];
      let mul = ;
      let i = ;
      while (++i < byteLength && (mul = )) {
        val += this[offset + i]  mul;
      }
      return val;
    };
    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset >>> ;
      byteLength = byteLength >>> ;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }
      let val = this[offset + --byteLength];
      let mul = ;
      while (byteLength >  && (mul = )) {
        val += this[offset + --byteLength]  mul;
      }
      return val;
    };
    Buffer.prototype.readUint = Buffer.prototype.readUInt = function readUInt(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return this[offset];
    };
    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return this[offset] | this[offset + ] << ;
    };
    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return this[offset] <<  | this[offset + ];
    };
    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return (this[offset] | this[offset + ] <<  | this[offset + ] << ) + this[offset + ]  ;
    };
    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return this[offset]   + (this[offset + ] <<  | this[offset + ] <<  | this[offset + ]);
    };
    Buffer.prototype.readBigUIntLE = defineBigIntMethod(function readBigUIntLE(offset) {
      offset = offset >>> ;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + ];
      if (first === void  || last === void ) {
        boundsError(offset, this.length - );
      }
      const lo = first + this[++offset]     + this[++offset]     + this[++offset]    ;
      const hi = this[++offset] + this[++offset]     + this[++offset]     + last    ;
      return BigInt(lo) + (BigInt(hi) << BigInt());
    });
    Buffer.prototype.readBigUIntBE = defineBigIntMethod(function readBigUIntBE(offset) {
      offset = offset >>> ;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + ];
      if (first === void  || last === void ) {
        boundsError(offset, this.length - );
      }
      const hi = first     + this[++offset]     + this[++offset]     + this[++offset];
      const lo = this[++offset]     + this[++offset]     + this[++offset]     + last;
      return (BigInt(hi) << BigInt()) + BigInt(lo);
    });
    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset >>> ;
      byteLength = byteLength >>> ;
      if (!noAssert)
        checkOffset(offset, byteLength, this.length);
      let val = this[offset];
      let mul = ;
      let i = ;
      while (++i < byteLength && (mul = )) {
        val += this[offset + i]  mul;
      }
      mul = ;
      if (val >= mul)
        val -= Math.pow(,   byteLength);
      return val;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset >>> ;
      byteLength = byteLength >>> ;
      if (!noAssert)
        checkOffset(offset, byteLength, this.length);
      let i = byteLength;
      let mul = ;
      let val = this[offset + --i];
      while (i >  && (mul = )) {
        val += this[offset + --i]  mul;
      }
      mul = ;
      if (val >= mul)
        val -= Math.pow(,   byteLength);
      return val;
    };
    Buffer.prototype.readInt = function readInt(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      if (!(this[offset] & ))
        return this[offset];
      return ( - this[offset] + )  -;
    };
    Buffer.prototype.readIntLE = function readIntLE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      const val = this[offset] | this[offset + ] << ;
      return val &  ? val |  : val;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      const val = this[offset + ] | this[offset] << ;
      return val &  ? val |  : val;
    };
    Buffer.prototype.readIntLE = function readIntLE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return this[offset] | this[offset + ] <<  | this[offset + ] <<  | this[offset + ] << ;
    };
    Buffer.prototype.readIntBE = function readIntBE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return this[offset] <<  | this[offset + ] <<  | this[offset + ] <<  | this[offset + ];
    };
    Buffer.prototype.readBigIntLE = defineBigIntMethod(function readBigIntLE(offset) {
      offset = offset >>> ;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + ];
      if (first === void  || last === void ) {
        boundsError(offset, this.length - );
      }
      const val = this[offset + ] + this[offset + ]     + this[offset + ]     + (last << );
      return (BigInt(val) << BigInt()) + BigInt(first + this[++offset]     + this[++offset]     + this[++offset]    );
    });
    Buffer.prototype.readBigIntBE = defineBigIntMethod(function readBigIntBE(offset) {
      offset = offset >>> ;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + ];
      if (first === void  || last === void ) {
        boundsError(offset, this.length - );
      }
      const val = (first << ) + // Overflow
      this[++offset]     + this[++offset]     + this[++offset];
      return (BigInt(val) << BigInt()) + BigInt(this[++offset]     + this[++offset]     + this[++offset]     + last);
    });
    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return ieee.read(this, offset, true, , );
    };
    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return ieee.read(this, offset, false, , );
    };
    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return ieee.read(this, offset, true, , );
    };
    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> ;
      if (!noAssert)
        checkOffset(offset, , this.length);
      return ieee.read(this, offset, false, , );
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> ;
      byteLength = byteLength >>> ;
      if (!noAssert) {
        const maxBytes = Math.pow(,   byteLength) - ;
        checkInt(this, value, offset, byteLength, maxBytes, );
      }
      let mul = ;
      let i = ;
      this[offset] = value & ;
      while (++i < byteLength && (mul = )) {
        this[offset + i] = value / mul & ;
      }
      return offset + byteLength;
    };
    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> ;
      byteLength = byteLength >>> ;
      if (!noAssert) {
        const maxBytes = Math.pow(,   byteLength) - ;
        checkInt(this, value, offset, byteLength, maxBytes, );
      }
      let i = byteLength - ;
      let mul = ;
      this[offset + i] = value & ;
      while (--i >=  && (mul = )) {
        this[offset + i] = value / mul & ;
      }
      return offset + byteLength;
    };
    Buffer.prototype.writeUint = Buffer.prototype.writeUInt = function writeUInt(value, offset, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert)
        checkInt(this, value, offset, , , );
      this[offset] = value & ;
      return offset + ;
    };
    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert)
        checkInt(this, value, offset, , , );
      this[offset] = value & ;
      this[offset + ] = value >>> ;
      return offset + ;
    };
    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert)
        checkInt(this, value, offset, , , );
      this[offset] = value >>> ;
      this[offset + ] = value & ;
      return offset + ;
    };
    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert)
        checkInt(this, value, offset, , , );
      this[offset + ] = value >>> ;
      this[offset + ] = value >>> ;
      this[offset + ] = value >>> ;
      this[offset] = value & ;
      return offset + ;
    };
    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert)
        checkInt(this, value, offset, , , );
      this[offset] = value >>> ;
      this[offset + ] = value >>> ;
      this[offset + ] = value >>> ;
      this[offset + ] = value & ;
      return offset + ;
    };
    function wrtBigUIntLE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, );
      let lo = Number(value & BigInt());
      buf[offset++] = lo;
      lo = lo >> ;
      buf[offset++] = lo;
      lo = lo >> ;
      buf[offset++] = lo;
      lo = lo >> ;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt() & BigInt());
      buf[offset++] = hi;
      hi = hi >> ;
      buf[offset++] = hi;
      hi = hi >> ;
      buf[offset++] = hi;
      hi = hi >> ;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUIntBE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, );
      let lo = Number(value & BigInt());
      buf[offset + ] = lo;
      lo = lo >> ;
      buf[offset + ] = lo;
      lo = lo >> ;
      buf[offset + ] = lo;
      lo = lo >> ;
      buf[offset + ] = lo;
      let hi = Number(value >> BigInt() & BigInt());
      buf[offset + ] = hi;
      hi = hi >> ;
      buf[offset + ] = hi;
      hi = hi >> ;
      buf[offset + ] = hi;
      hi = hi >> ;
      buf[offset] = hi;
      return offset + ;
    }
    Buffer.prototype.writeBigUIntLE = defineBigIntMethod(function writeBigUIntLE(value, offset = ) {
      return wrtBigUIntLE(this, value, offset, BigInt(), BigInt("xffffffffffffffff"));
    });
    Buffer.prototype.writeBigUIntBE = defineBigIntMethod(function writeBigUIntBE(value, offset = ) {
      return wrtBigUIntBE(this, value, offset, BigInt(), BigInt("xffffffffffffffff"));
    });
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert) {
        const limit = Math.pow(,   byteLength - );
        checkInt(this, value, offset, byteLength, limit - , -limit);
      }
      let i = ;
      let mul = ;
      let sub = ;
      this[offset] = value & ;
      while (++i < byteLength && (mul = )) {
        if (value <  && sub ===  && this[offset + i - ] !== ) {
          sub = ;
        }
        this[offset + i] = (value / mul >> ) - sub & ;
      }
      return offset + byteLength;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert) {
        const limit = Math.pow(,   byteLength - );
        checkInt(this, value, offset, byteLength, limit - , -limit);
      }
      let i = byteLength - ;
      let mul = ;
      let sub = ;
      this[offset + i] = value & ;
      while (--i >=  && (mul = )) {
        if (value <  && sub ===  && this[offset + i + ] !== ) {
          sub = ;
        }
        this[offset + i] = (value / mul >> ) - sub & ;
      }
      return offset + byteLength;
    };
    Buffer.prototype.writeInt = function writeInt(value, offset, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert)
        checkInt(this, value, offset, , , -);
      if (value < )
        value =  + value + ;
      this[offset] = value & ;
      return offset + ;
    };
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert)
        checkInt(this, value, offset, , , -);
      this[offset] = value & ;
      this[offset + ] = value >>> ;
      return offset + ;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert)
        checkInt(this, value, offset, , , -);
      this[offset] = value >>> ;
      this[offset + ] = value & ;
      return offset + ;
    };
    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert)
        checkInt(this, value, offset, , , -);
      this[offset] = value & ;
      this[offset + ] = value >>> ;
      this[offset + ] = value >>> ;
      this[offset + ] = value >>> ;
      return offset + ;
    };
    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert)
        checkInt(this, value, offset, , , -);
      if (value < )
        value =  + value + ;
      this[offset] = value >>> ;
      this[offset + ] = value >>> ;
      this[offset + ] = value >>> ;
      this[offset + ] = value & ;
      return offset + ;
    };
    Buffer.prototype.writeBigIntLE = defineBigIntMethod(function writeBigIntLE(value, offset = ) {
      return wrtBigUIntLE(this, value, offset, -BigInt("x"), BigInt("xfffffffffffffff"));
    });
    Buffer.prototype.writeBigIntBE = defineBigIntMethod(function writeBigIntBE(value, offset = ) {
      return wrtBigUIntBE(this, value, offset, -BigInt("x"), BigInt("xfffffffffffffff"));
    });
    function checkIEEE(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < )
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert) {
        checkIEEE(buf, value, offset, , e, -e);
      }
      ieee.write(buf, value, offset, littleEndian, , );
      return offset + ;
    }
    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> ;
      if (!noAssert) {
        checkIEEE(buf, value, offset, , e, -e);
      }
      ieee.write(buf, value, offset, littleEndian, , );
      return offset + ;
    }
    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = ;
      if (!end && end !== )
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = ;
      if (end >  && end < start)
        end = start;
      if (end === start)
        return ;
      if (target.length ===  || this.length === )
        return ;
      if (targetStart < ) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start <  || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < )
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof UintArray.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        UintArray.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = ;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void  && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === ) {
          const code = val.charCodeAt();
          if (encoding === "utf" && code <  || encoding === "latin") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & ;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start <  || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> ;
      end = end === void  ? this.length : end >>> ;
      if (!val)
        val = ;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === ) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = ; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) >   ) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt()  BigInt() || input < -(BigInt()  BigInt())) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[] === "-" ?  : ;
      for (; i >= start + ; i -= ) {
        res = `_${val.slice(i - , i)}${res}`;
      }
      return `${val.slice(, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength) {
      validateNumber(offset, "offset");
      if (buf[offset] === void  || buf[offset + byteLength] === void ) {
        boundsError(offset, buf.length - (byteLength + ));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > ) {
          if (min ===  || min === BigInt()) {
            range = `>= ${n} and < ${n}  ${(byteLength + )  }${n}`;
          } else {
            range = `>= -(${n}  ${(byteLength + )   - }${n}) and <   ${(byteLength + )   - }${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < ) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ?  : } and <= ${length}`,
        value
      );
    }
    var INVALID_BASE_RE = /[^+/-A-Za-z-_]/g;
    function baseclean(str) {
      str = str.split("=")[];
      str = str.trim().replace(INVALID_BASE_RE, "");
      if (str.length < )
        return "";
      while (str.length %  !== ) {
        str = str + "=";
      }
      return str;
    }
    function utfToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = ; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint >  && codePoint < ) {
          if (!leadSurrogate) {
            if (codePoint > ) {
              if ((units -= ) > -)
                bytes.push(, , );
              continue;
            } else if (i +  === length) {
              if ((units -= ) > -)
                bytes.push(, , );
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < ) {
            if ((units -= ) > -)
              bytes.push(, , );
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate -  <<  | codePoint - ) + ;
        } else if (leadSurrogate) {
          if ((units -= ) > -)
            bytes.push(, , );
        }
        leadSurrogate = null;
        if (codePoint < ) {
          if ((units -= ) < )
            break;
          bytes.push(codePoint);
        } else if (codePoint < ) {
          if ((units -= ) < )
            break;
          bytes.push(
            codePoint >>  | ,
            codePoint &  | 
          );
        } else if (codePoint < ) {
          if ((units -= ) < )
            break;
          bytes.push(
            codePoint >>  | ,
            codePoint >>  &  | ,
            codePoint &  | 
          );
        } else if (codePoint < ) {
          if ((units -= ) < )
            break;
          bytes.push(
            codePoint >>  | ,
            codePoint >>  &  | ,
            codePoint >>  &  | ,
            codePoint &  | 
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = ; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & );
      }
      return byteArray;
    }
    function utfleToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = ; i < str.length; ++i) {
        if ((units -= ) < )
          break;
        c = str.charCodeAt(i);
        hi = c >> ;
        lo = c % ;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function baseToBytes(str) {
      return base.toByteArray(baseclean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = ; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "abcdef";
      const table = new Array();
      for (let i = ; i < ; ++i) {
        const i = i  ;
        for (let j = ; j < ; ++j) {
          table[i + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// polyfill_buffer.js
var import_obsidian, buffer, Buffer;
var init_polyfill_buffer = __esm({
  "polyfill_buffer.js"() {
    import_obsidian = require("obsidian");
    if (import_obsidian.Platform.isMobileApp) {
      buffer = require_buffer().Buffer;
    } else {
      buffer = global.Buffer;
    }
    Buffer = buffer;
  }
});

// node_modules/.pnpm/async-lock@../node_modules/async-lock/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/async-lock@../node_modules/async-lock/lib/index.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    var AsyncLock = function(opts) {
      opts = opts || {};
      this.Promise = opts.Promise || Promise;
      this.queues = / @__PURE__ / Object.create(null);
      this.domainReentrant = opts.domainReentrant || false;
      if (this.domainReentrant) {
        if (typeof process === "undefined" || typeof process.domain === "undefined") {
          throw new Error(
            "Domain-reentrant locks require `process.domain` to exist. Please flip `opts.domainReentrant = false`, use a NodeJS version that still implements Domain, or install a browser polyfill."
          );
        }
        this.domains = / @__PURE__ / Object.create(null);
      }
      this.timeout = opts.timeout || AsyncLock.DEFAULT_TIMEOUT;
      this.maxOccupationTime = opts.maxOccupationTime || AsyncLock.DEFAULT_MAX_OCCUPATION_TIME;
      this.maxExecutionTime = opts.maxExecutionTime || AsyncLock.DEFAULT_MAX_EXECUTION_TIME;
      if (opts.maxPending === Infinity || Number.isInteger(opts.maxPending) && opts.maxPending >= ) {
        this.maxPending = opts.maxPending;
      } else {
        this.maxPending = AsyncLock.DEFAULT_MAX_PENDING;
      }
    };
    AsyncLock.DEFAULT_TIMEOUT = ;
    AsyncLock.DEFAULT_MAX_OCCUPATION_TIME = ;
    AsyncLock.DEFAULT_MAX_EXECUTION_TIME = ;
    AsyncLock.DEFAULT_MAX_PENDING = e;
    AsyncLock.prototype.acquire = function(key, fn, cb, opts) {
      if (Array.isArray(key)) {
        return this._acquireBatch(key, fn, cb, opts);
      }
      if (typeof fn !== "function") {
        throw new Error("You must pass a function to execute");
      }
      var deferredResolve = null;
      var deferredReject = null;
      var deferred = null;
      if (typeof cb !== "function") {
        opts = cb;
        cb = null;
        deferred = new this.Promise(function(resolve, reject) {
          deferredResolve = resolve;
          deferredReject = reject;
        });
      }
      opts = opts || {};
      var resolved = false;
      var timer = null;
      var occupationTimer = null;
      var executionTimer = null;
      var self = this;
      var done = function(locked, err, ret) {
        if (occupationTimer) {
          clearTimeout(occupationTimer);
          occupationTimer = null;
        }
        if (executionTimer) {
          clearTimeout(executionTimer);
          executionTimer = null;
        }
        if (locked) {
          if (!!self.queues[key] && self.queues[key].length === ) {
            delete self.queues[key];
          }
          if (self.domainReentrant) {
            delete self.domains[key];
          }
        }
        if (!resolved) {
          if (!deferred) {
            if (typeof cb === "function") {
              cb(err, ret);
            }
          } else {
            if (err) {
              deferredReject(err);
            } else {
              deferredResolve(ret);
            }
          }
          resolved = true;
        }
        if (locked) {
          if (!!self.queues[key] && self.queues[key].length > ) {
            self.queues[key].shift()();
          }
        }
      };
      var exec = function(locked) {
        if (resolved) {
          return done(locked);
        }
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        if (self.domainReentrant && locked) {
          self.domains[key] = process.domain;
        }
        var maxExecutionTime = opts.maxExecutionTime || self.maxExecutionTime;
        if (maxExecutionTime) {
          executionTimer = setTimeout(function() {
            if (!!self.queues[key]) {
              done(locked, new Error("Maximum execution time is exceeded " + key));
            }
          }, maxExecutionTime);
        }
        if (fn.length === ) {
          var called = false;
          try {
            fn(function(err, ret) {
              if (!called) {
                called = true;
                done(locked, err, ret);
              }
            });
          } catch (err) {
            if (!called) {
              called = true;
              done(locked, err);
            }
          }
        } else {
          self._promiseTry(function() {
            return fn();
          }).then(function(ret) {
            done(locked, void , ret);
          }, function(error) {
            done(locked, error);
          });
        }
      };
      if (self.domainReentrant && !!process.domain) {
        exec = process.domain.bind(exec);
      }
      if (!self.queues[key]) {
        self.queues[key] = [];
        exec(true);
      } else if (self.domainReentrant && !!process.domain && process.domain === self.domains[key]) {
        exec(false);
      } else if (self.queues[key].length >= self.maxPending) {
        done(false, new Error("Too many pending tasks in queue " + key));
      } else {
        var taskFn = function() {
          exec(true);
        };
        if (opts.skipQueue) {
          self.queues[key].unshift(taskFn);
        } else {
          self.queues[key].push(taskFn);
        }
        var timeout = opts.timeout || self.timeout;
        if (timeout) {
          timer = setTimeout(function() {
            timer = null;
            done(false, new Error("async-lock timed out in queue " + key));
          }, timeout);
        }
      }
      var maxOccupationTime = opts.maxOccupationTime || self.maxOccupationTime;
      if (maxOccupationTime) {
        occupationTimer = setTimeout(function() {
          if (!!self.queues[key]) {
            done(false, new Error("Maximum occupation time is exceeded in queue " + key));
          }
        }, maxOccupationTime);
      }
      if (deferred) {
        return deferred;
      }
    };
    AsyncLock.prototype._acquireBatch = function(keys, fn, cb, opts) {
      if (typeof cb !== "function") {
        opts = cb;
        cb = null;
      }
      var self = this;
      var getFn = function(key, fn) {
        return function(cb) {
          self.acquire(key, fn, cb, opts);
        };
      };
      var fnx = keys.reduceRight(function(prev, key) {
        return getFn(key, prev);
      }, fn);
      if (typeof cb === "function") {
        fnx(cb);
      } else {
        return new this.Promise(function(resolve, reject) {
          if (fnx.length === ) {
            fnx(function(err, ret) {
              if (err) {
                reject(err);
              } else {
                resolve(ret);
              }
            });
          } else {
            resolve(fnx());
          }
        });
      }
    };
    AsyncLock.prototype.isBusy = function(key) {
      if (!key) {
        return Object.keys(this.queues).length > ;
      } else {
        return !!this.queues[key];
      }
    };
    AsyncLock.prototype._promiseTry = function(fn) {
      try {
        return this.Promise.resolve(fn());
      } catch (e) {
        return this.Promise.reject(e);
      }
    };
    module.exports = AsyncLock;
  }
});

// node_modules/.pnpm/async-lock@../node_modules/async-lock/index.js
var require_async_lock = __commonJS({
  "node_modules/.pnpm/async-lock@../node_modules/async-lock/index.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    module.exports = require_lib();
  }
});

// node_modules/.pnpm/inherits@../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/.pnpm/inherits@../node_modules/inherits/inherits_browser.js"(exports, module) {
    init_polyfill_buffer();
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/.pnpm/safe-buffer@../node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/.pnpm/safe-buffer@../node_modules/safe-buffer/index.js"(exports, module) {
    init_polyfill_buffer();
    var buffer = require_buffer();
    var Buffer = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer.prototype);
    copyProps(Buffer, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer(size);
      if (fill !== void ) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill();
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/.pnpm/sha.js@../node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/.pnpm/sha.js@../node_modules/sha.js/hash.js"(exports, module) {
    init_polyfill_buffer();
    var Buffer = require_safe_buffer().Buffer;
    function Hash(blockSize, finalSize) {
      this._block = Buffer.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = ;
    }
    Hash.prototype.update = function(data, enc) {
      if (typeof data === "string") {
        enc = enc || "utf";
        data = Buffer.from(data, enc);
      }
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = ; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = ; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === ) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = ;
      this._block.fill(, rem + );
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill();
      }
      var bits = this._len  ;
      if (bits <= ) {
        this._block.writeUIntBE(bits, this._blockSize - );
      } else {
        var lowBits = (bits & ) >>> ;
        var highBits = (bits - lowBits) / ;
        this._block.writeUIntBE(highBits, this._blockSize - );
        this._block.writeUIntBE(lowBits, this._blockSize - );
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// node_modules/.pnpm/sha.js@../node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/.pnpm/sha.js@../node_modules/sha.js/sha.js"(exports, module) {
    init_polyfill_buffer();
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer = require_safe_buffer().Buffer;
    var K = [
      ,
      ,
       | ,
       | 
    ];
    var W = new Array();
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, , );
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = ;
      this._b = ;
      this._c = ;
      this._d = ;
      this._e = ;
      return this;
    };
    function rotl(num) {
      return num <<  | num >>> ;
    }
    function rotl(num) {
      return num <<  | num >>> ;
    }
    function rotl(num) {
      return num <<  | num >>> ;
    }
    function ft(s, b, c, d) {
      if (s === )
        return b & c | ~b & d;
      if (s === )
        return b & c | b & d | c & d;
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var W = this._w;
      var a = this._a | ;
      var b = this._b | ;
      var c = this._c | ;
      var d = this._d | ;
      var e = this._e | ;
      for (var i = ; i < ; ++i)
        W[i] = M.readIntBE(i  );
      for (; i < ; ++i)
        W[i] = rotl(W[i - ] ^ W[i - ] ^ W[i - ] ^ W[i - ]);
      for (var j = ; j < ; ++j) {
        var s = ~~(j / );
        var t = rotl(a) + ft(s, b, c, d) + e + W[j] + K[s] | ;
        e = d;
        d = c;
        c = rotl(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | ;
      this._b = b + this._b | ;
      this._c = c + this._c | ;
      this._d = d + this._d | ;
      this._e = e + this._e | ;
    };
    Sha.prototype._hash = function() {
      var H = Buffer.allocUnsafe();
      H.writeIntBE(this._a | , );
      H.writeIntBE(this._b | , );
      H.writeIntBE(this._c | , );
      H.writeIntBE(this._d | , );
      H.writeIntBE(this._e | , );
      return H;
    };
    module.exports = Sha;
  }
});

// node_modules/.pnpm/crc-@../node_modules/crc-/crc.js
var require_crc = __commonJS({
  "node_modules/.pnpm/crc-@../node_modules/crc-/crc.js"(exports) {
    init_polyfill_buffer();
    var CRC;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if ("object" === typeof exports) {
          factory(exports);
        } else if ("function" === typeof define && define.amd) {
          define(function() {
            var module = {};
            factory(module);
            return module;
          });
        } else {
          factory(CRC = {});
        }
      } else {
        factory(CRC = {});
      }
    })(function(CRC) {
      CRC.version = "..";
      function signed_crc_table() {
        var c = , table = new Array();
        for (var n = ; n != ; ++n) {
          c = n;
          c = c &  ? - ^ c >>>  : c >>> ;
          c = c &  ? - ^ c >>>  : c >>> ;
          c = c &  ? - ^ c >>>  : c >>> ;
          c = c &  ? - ^ c >>>  : c >>> ;
          c = c &  ? - ^ c >>>  : c >>> ;
          c = c &  ? - ^ c >>>  : c >>> ;
          c = c &  ? - ^ c >>>  : c >>> ;
          c = c &  ? - ^ c >>>  : c >>> ;
          table[n] = c;
        }
        return typeof IntArray !== "undefined" ? new IntArray(table) : table;
      }
      var T = signed_crc_table();
      function slice_by__tables(T) {
        var c = , v = , n = , table = typeof IntArray !== "undefined" ? new IntArray() : new Array();
        for (n = ; n != ; ++n)
          table[n] = T[n];
        for (n = ; n != ; ++n) {
          v = T[n];
          for (c =  + n; c < ; c += )
            v = table[c] = v >>>  ^ T[v & ];
        }
        var out = [];
        for (n = ; n != ; ++n)
          out[n - ] = typeof IntArray !== "undefined" ? table.subarray(n  , n   + ) : table.slice(n  , n   + );
        return out;
      }
      var TT = slice_by__tables(T);
      var T = TT[], T = TT[], T = TT[], T = TT[], T = TT[];
      var T = TT[], T = TT[], T = TT[], T = TT[], Ta = TT[];
      var Tb = TT[], Tc = TT[], Td = TT[], Te = TT[], Tf = TT[];
      function crc_bstr(bstr, seed) {
        var C = seed ^ -;
        for (var i = , L = bstr.length; i < L; )
          C = C >>>  ^ T[(C ^ bstr.charCodeAt(i++)) & ];
        return ~C;
      }
      function crc_buf(B, seed) {
        var C = seed ^ -, L = B.length - , i = ;
        for (; i < L; )
          C = Tf[B[i++] ^ C & ] ^ Te[B[i++] ^ C >>  & ] ^ Td[B[i++] ^ C >>  & ] ^ Tc[B[i++] ^ C >>> ] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T[B[i++]] ^ T[B[i++]] ^ T[B[i++]] ^ T[B[i++]] ^ T[B[i++]] ^ T[B[i++]] ^ T[B[i++]] ^ T[B[i++]] ^ T[B[i++]] ^ T[B[i++]];
        L += ;
        while (i < L)
          C = C >>>  ^ T[(C ^ B[i++]) & ];
        return ~C;
      }
      function crc_str(str, seed) {
        var C = seed ^ -;
        for (var i = , L = str.length, c = , d = ; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < ) {
            C = C >>>  ^ T[(C ^ c) & ];
          } else if (c < ) {
            C = C >>>  ^ T[(C ^ ( | c >>  & )) & ];
            C = C >>>  ^ T[(C ^ ( | c & )) & ];
          } else if (c >=  && c < ) {
            c = (c & ) + ;
            d = str.charCodeAt(i++) & ;
            C = C >>>  ^ T[(C ^ ( | c >>  & )) & ];
            C = C >>>  ^ T[(C ^ ( | c >>  & )) & ];
            C = C >>>  ^ T[(C ^ ( | d >>  &  | (c & ) << )) & ];
            C = C >>>  ^ T[(C ^ ( | d & )) & ];
          } else {
            C = C >>>  ^ T[(C ^ ( | c >>  & )) & ];
            C = C >>>  ^ T[(C ^ ( | c >>  & )) & ];
            C = C >>>  ^ T[(C ^ ( | c & )) & ];
          }
        }
        return ~C;
      }
      CRC.table = T;
      CRC.bstr = crc_bstr;
      CRC.buf = crc_buf;
      CRC.str = crc_str;
    });
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/utils/common.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    var TYPED_OK = typeof UintArray !== "undefined" && typeof UintArray !== "undefined" && typeof IntArray !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, );
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = ; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = ;
        for (i = , l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new UintArray(len);
        pos = ;
        for (i = , l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = ; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf = UintArray;
        exports.Buf = UintArray;
        exports.Buf = IntArray;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf = Array;
        exports.Buf = Array;
        exports.Buf = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/trees.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    var utils = require_common();
    var Z_FIXED = ;
    var Z_BINARY = ;
    var Z_TEXT = ;
    var Z_UNKNOWN = ;
    function zero(buf) {
      var len = buf.length;
      while (--len >= ) {
        buf[len] = ;
      }
    }
    var STORED_BLOCK = ;
    var STATIC_TREES = ;
    var DYN_TREES = ;
    var MIN_MATCH = ;
    var MAX_MATCH = ;
    var LENGTH_CODES = ;
    var LITERALS = ;
    var L_CODES = LITERALS +  + LENGTH_CODES;
    var D_CODES = ;
    var BL_CODES = ;
    var HEAP_SIZE =   L_CODES + ;
    var MAX_BITS = ;
    var Buf_size = ;
    var MAX_BL_BITS = ;
    var END_BLOCK = ;
    var REP__ = ;
    var REPZ__ = ;
    var REPZ__ = ;
    var extra_lbits = (
      / extra bits for each length code /
      [, , , , , , , , , , , , , , , , , , , , , , , , , , , , ]
    );
    var extra_dbits = (
      / extra bits for each distance code /
      [, , , , , , , , , , , , , , , , , , , , , , , , , , , , , ]
    );
    var extra_blbits = (
      / extra bits for each bit length code /
      [, , , , , , , , , , , , , , , , , , ]
    );
    var bl_order = [, , , , , , , , , , , , , , , , , , ];
    var DIST_CODE_LEN = ;
    var static_ltree = new Array((L_CODES + )  );
    zero(static_ltree);
    var static_dtree = new Array(D_CODES  );
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + );
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = ;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist <  ? _dist_code[dist] : _dist_code[ + (dist >>> )];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & ;
      s.pending_buf[s.pending++] = w >>>  & ;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & ;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & ;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c  ],
        tree[c   + ]
        /.Len/
      );
    }
    function bi_reverse(code, len) {
      var res = ;
      do {
        res |= code & ;
        code >>>= ;
        res <<= ;
      } while (--len > );
      return res >>> ;
    }
    function bi_flush(s) {
      if (s.bi_valid === ) {
        put_short(s, s.bi_buf);
        s.bi_buf = ;
        s.bi_valid = ;
      } else if (s.bi_valid >= ) {
        s.pending_buf[s.pending++] = s.bi_buf & ;
        s.bi_buf >>= ;
        s.bi_valid -= ;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = ;
      for (bits = ; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = ;
      }
      tree[s.heap[s.heap_max]   + ] = ;
      for (h = s.heap_max + ; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n   + ]   + ] + ;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n   + ] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = ;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n  ];
        s.opt_len += f  (bits + xbits);
        if (has_stree) {
          s.static_len += f  (stree[n   + ] + xbits);
        }
      }
      if (overflow === ) {
        return;
      }
      do {
        bits = max_length - ;
        while (s.bl_count[bits] === ) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + ] += ;
        s.bl_count[max_length]--;
        overflow -= ;
      } while (overflow > );
      for (bits = max_length; bits !== ; bits--) {
        n = s.bl_count[bits];
        while (n !== ) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m   + ] !== bits) {
            s.opt_len += (bits - tree[m   + ])  tree[m  ];
            tree[m   + ] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + );
      var code = ;
      var bits;
      var n;
      for (bits = ; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - ] << ;
      }
      for (n = ; n <= max_code; n++) {
        var len = tree[n   + ];
        if (len === ) {
          continue;
        }
        tree[n  ] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + );
      length = ;
      for (code = ; code < LENGTH_CODES - ; code++) {
        base_length[code] = length;
        for (n = ; n <  << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - ] = code;
      dist = ;
      for (code = ; code < ; code++) {
        base_dist[code] = dist;
        for (n = ; n <  << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= ;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << ;
        for (n = ; n <  << extra_dbits[code] - ; n++) {
          _dist_code[ + dist++] = code;
        }
      }
      for (bits = ; bits <= MAX_BITS; bits++) {
        bl_count[bits] = ;
      }
      n = ;
      while (n <= ) {
        static_ltree[n   + ] = ;
        n++;
        bl_count[]++;
      }
      while (n <= ) {
        static_ltree[n   + ] = ;
        n++;
        bl_count[]++;
      }
      while (n <= ) {
        static_ltree[n   + ] = ;
        n++;
        bl_count[]++;
      }
      while (n <= ) {
        static_ltree[n   + ] = ;
        n++;
        bl_count[]++;
      }
      gen_codes(static_ltree, L_CODES + , bl_count);
      for (n = ; n < D_CODES; n++) {
        static_dtree[n   + ] = ;
        static_dtree[n  ] = bi_reverse(n, );
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + , L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, , D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(), extra_blbits, , BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = ; n < L_CODES; n++) {
        s.dyn_ltree[n  ] = ;
      }
      for (n = ; n < D_CODES; n++) {
        s.dyn_dtree[n  ] = ;
      }
      for (n = ; n < BL_CODES; n++) {
        s.bl_tree[n  ] = ;
      }
      s.dyn_ltree[END_BLOCK  ] = ;
      s.opt_len = s.static_len = ;
      s.last_lit = s.matches = ;
    }
    function bi_windup(s) {
      if (s.bi_valid > ) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > ) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = ;
      s.bi_valid = ;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n = n  ;
      var _m = m  ;
      return tree[_n] < tree[_m] || tree[_n] === tree[_m] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << ;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + ], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= ;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = ;
      var code;
      var extra;
      if (s.last_lit !== ) {
        do {
          dist = s.pending_buf[s.d_buf + lx  ] <<  | s.pending_buf[s.d_buf + lx   + ];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === ) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + , ltree);
            extra = extra_lbits[code];
            if (extra !== ) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== ) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -;
      var node;
      s.heap_len = ;
      s.heap_max = HEAP_SIZE;
      for (n = ; n < elems; n++) {
        if (tree[n  ] !== ) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = ;
        } else {
          tree[n   + ] = ;
        }
      }
      while (s.heap_len < ) {
        node = s.heap[++s.heap_len] = max_code <  ? ++max_code : ;
        tree[node  ] = ;
        s.depth[node] = ;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node   + ];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> ; n >= ; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          
          /SMALLEST/
        ];
        s.heap[
          
          /SMALLEST/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          
          /SMALLEST/
        );
        m = s.heap[
          
          /SMALLEST/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node  ] = tree[n  ] + tree[m  ];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + ;
        tree[n   + ] = tree[m   + ] = node;
        s.heap[
          
          /SMALLEST/
        ] = node++;
        pqdownheap(
          s,
          tree,
          
          /SMALLEST/
        );
      } while (s.heap_len >= );
      s.heap[--s.heap_max] = s.heap[
        
        /SMALLEST/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -;
      var curlen;
      var nextlen = tree[   + ];
      var count = ;
      var max_count = ;
      var min_count = ;
      if (nextlen === ) {
        max_count = ;
        min_count = ;
      }
      tree[(max_code + )   + ] = ;
      for (n = ; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + )   + ];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen  ] += count;
        } else if (curlen !== ) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen  ]++;
          }
          s.bl_tree[REP__  ]++;
        } else if (count <= ) {
          s.bl_tree[REPZ__  ]++;
        } else {
          s.bl_tree[REPZ__  ]++;
        }
        count = ;
        prevlen = curlen;
        if (nextlen === ) {
          max_count = ;
          min_count = ;
        } else if (curlen === nextlen) {
          max_count = ;
          min_count = ;
        } else {
          max_count = ;
          min_count = ;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -;
      var curlen;
      var nextlen = tree[   + ];
      var count = ;
      var max_count = ;
      var min_count = ;
      if (nextlen === ) {
        max_count = ;
        min_count = ;
      }
      for (n = ; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + )   + ];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== );
        } else if (curlen !== ) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP__, s.bl_tree);
          send_bits(s, count - , );
        } else if (count <= ) {
          send_code(s, REPZ__, s.bl_tree);
          send_bits(s, count - , );
        } else {
          send_code(s, REPZ__, s.bl_tree);
          send_bits(s, count - , );
        }
        count = ;
        prevlen = curlen;
        if (nextlen === ) {
          max_count = ;
          min_count = ;
        } else if (curlen === nextlen) {
          max_count = ;
          min_count = ;
        } else {
          max_count = ;
          min_count = ;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - ; max_blindex >= ; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex]   + ] !== ) {
          break;
        }
      }
      s.opt_len +=   (max_blindex + ) +  +  + ;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - , );
      send_bits(s, dcodes - , );
      send_bits(s, blcodes - , );
      for (rank = ; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank]   + ], );
      }
      send_tree(s, s.dyn_ltree, lcodes - );
      send_tree(s, s.dyn_dtree, dcodes - );
    }
    function detect_data_type(s) {
      var black_mask = ;
      var n;
      for (n = ; n <= ; n++, black_mask >>>= ) {
        if (black_mask &  && s.dyn_ltree[n  ] !== ) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[  ] !==  || s.dyn_ltree[  ] !==  || s.dyn_ltree[  ] !== ) {
        return Z_TEXT;
      }
      for (n = ; n < LITERALS; n++) {
        if (s.dyn_ltree[n  ] !== ) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = ;
      s.bi_valid = ;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last) {
      send_bits(s, (STORED_BLOCK << ) + (last ?  : ), );
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << , );
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last) {
      var opt_lenb, static_lenb;
      var max_blindex = ;
      if (s.level > ) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len +  +  >>> ;
        static_lenb = s.static_len +  +  >>> ;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + ;
      }
      if (stored_len +  <= opt_lenb && buf !== -) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << ) + (last ?  : ), );
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << ) + (last ?  : ), );
        send_all_trees(s, s.l_desc.max_code + , s.d_desc.max_code + , max_blindex + );
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit  ] = dist >>>  & ;
      s.pending_buf[s.d_buf + s.last_lit   + ] = dist & ;
      s.pending_buf[s.l_buf + s.last_lit] = lc & ;
      s.last_lit++;
      if (dist === ) {
        s.dyn_ltree[lc  ]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + )  ]++;
        s.dyn_dtree[d_code(dist)  ]++;
      }
      return s.last_lit === s.lit_bufsize - ;
    }
    exports._tr_init = _tr_init;
    exports._tr_stored_block = _tr_stored_block;
    exports._tr_flush_block = _tr_flush_block;
    exports._tr_tally = _tr_tally;
    exports._tr_align = _tr_align;
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/adler.js
var require_adler = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/adler.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    function adler(adler, buf, len, pos) {
      var s = adler &  | , s = adler >>>  &  | , n = ;
      while (len !== ) {
        n = len > e ? e : len;
        len -= n;
        do {
          s = s + buf[pos++] | ;
          s = s + s | ;
        } while (--n);
        s %= ;
        s %= ;
      }
      return s | s <<  | ;
    }
    module.exports = adler;
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/crc.js
var require_crc = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/crc.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    function makeTable() {
      var c, table = [];
      for (var n = ; n < ; n++) {
        c = n;
        for (var k = ; k < ; k++) {
          c = c &  ?  ^ c >>>  : c >>> ;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -;
      for (var i = pos; i < end; i++) {
        crc = crc >>>  ^ t[(crc ^ buf[i]) & ];
      }
      return crc ^ -;
    }
    module.exports = crc;
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    module.exports = {
      : "need dictionary",
      / Z_NEED_DICT         /
      : "stream end",
      / Z_STREAM_END        /
      : "",
      / Z_OK                /
      "-": "file error",
      / Z_ERRNO         (-) /
      "-": "stream error",
      / Z_STREAM_ERROR  (-) /
      "-": "data error",
      / Z_DATA_ERROR    (-) /
      "-": "insufficient memory",
      / Z_MEM_ERROR     (-) /
      "-": "buffer error",
      / Z_BUF_ERROR     (-) /
      "-": "incompatible version"
      / Z_VERSION_ERROR (-) /
    };
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/deflate.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    var utils = require_common();
    var trees = require_trees();
    var adler = require_adler();
    var crc = require_crc();
    var msg = require_messages();
    var Z_NO_FLUSH = ;
    var Z_PARTIAL_FLUSH = ;
    var Z_FULL_FLUSH = ;
    var Z_FINISH = ;
    var Z_BLOCK = ;
    var Z_OK = ;
    var Z_STREAM_END = ;
    var Z_STREAM_ERROR = -;
    var Z_DATA_ERROR = -;
    var Z_BUF_ERROR = -;
    var Z_DEFAULT_COMPRESSION = -;
    var Z_FILTERED = ;
    var Z_HUFFMAN_ONLY = ;
    var Z_RLE = ;
    var Z_FIXED = ;
    var Z_DEFAULT_STRATEGY = ;
    var Z_UNKNOWN = ;
    var Z_DEFLATED = ;
    var MAX_MEM_LEVEL = ;
    var MAX_WBITS = ;
    var DEF_MEM_LEVEL = ;
    var LENGTH_CODES = ;
    var LITERALS = ;
    var L_CODES = LITERALS +  + LENGTH_CODES;
    var D_CODES = ;
    var BL_CODES = ;
    var HEAP_SIZE =   L_CODES + ;
    var MAX_BITS = ;
    var MIN_MATCH = ;
    var MAX_MATCH = ;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + ;
    var PRESET_DICT = ;
    var INIT_STATE = ;
    var EXTRA_STATE = ;
    var NAME_STATE = ;
    var COMMENT_STATE = ;
    var HCRC_STATE = ;
    var BUSY_STATE = ;
    var FINISH_STATE = ;
    var BS_NEED_MORE = ;
    var BS_BLOCK_DONE = ;
    var BS_FINISH_STARTED = ;
    var BS_FINISH_DONE = ;
    var OS_CODE = ;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << ) - (f >  ?  : );
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= ) {
        buf[len] = ;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === ) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === ) {
        s.pending_out = ;
      }
    }
    function flush_block_only(s, last) {
      trees._tr_flush_block(s, s.block_start >=  ? s.block_start : -, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>>  & ;
      s.pending_buf[s.pending++] = b & ;
    }
    function read_buf(strm, buf, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === ) {
        return ;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === ) {
        strm.adler = adler(strm.adler, buf, len, start);
      } else if (strm.state.wrap === ) {
        strm.adler = crc(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : ;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end = _win[scan + best_len - ];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= ;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - ] !== scan_end || _win[match] !== _win[scan] || _win[++match] !== _win[scan + ]) {
          continue;
        }
        scan += ;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end = _win[scan + best_len - ];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== );
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, );
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : ;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : ;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === ) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + ]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - ]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== );
    }
    function deflate_stored(s, flush) {
      var max_block_size = ;
      if (max_block_size > s.pending_buf_size - ) {
        max_block_size = s.pending_buf_size - ;
      }
      for (; ; ) {
        if (s.lookahead <= ) {
          fill_window(s);
          if (s.lookahead ===  && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === ) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = ;
        var max_start = s.block_start + max_block_size;
        if (s.strstart ===  || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === ) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === ) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = ;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === ) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === ) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === ) {
            break;
          }
        }
        hash_head = ;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - ]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !==  && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - ]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== );
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = ;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + ]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, , s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === ) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH -  ? s.strstart : MIN_MATCH - ;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === ) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === ) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === ) {
            break;
          }
        }
        hash_head = ;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - ]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - ;
        if (hash_head !==  && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <=  && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > )) {
            s.match_length = MIN_MATCH - ;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart -  - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - ;
          s.prev_length -= ;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - ]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== );
          s.match_available = ;
          s.match_length = MIN_MATCH - ;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === ) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, , s.window[s.strstart - ]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === ) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = ;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, , s.window[s.strstart - ]);
        s.match_available = ;
      }
      s.insert = s.strstart < MIN_MATCH -  ? s.strstart : MIN_MATCH - ;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === ) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === ) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === ) {
            break;
          }
        }
        s.match_length = ;
        if (s.lookahead >= MIN_MATCH && s.strstart > ) {
          scan = s.strstart - ;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, , s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = ;
        } else {
          bflush = trees._tr_tally(s, , s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === ) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = ;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === ) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === ) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === ) {
          fill_window(s);
          if (s.lookahead === ) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = ;
        bflush = trees._tr_tally(s, , s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === ) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = ;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === ) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === ) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /      good lazy nice chain /
      new Config(, , , , deflate_stored),
      /  store only /
      new Config(, , , , deflate_fast),
      /  max speed, no lazy matches /
      new Config(, , , , deflate_fast),
      /  /
      new Config(, , , , deflate_fast),
      /  /
      new Config(, , , , deflate_slow),
      /  lazy matches /
      new Config(, , , , deflate_slow),
      /  /
      new Config(, , , , deflate_slow),
      /  /
      new Config(, , , , deflate_slow),
      /  /
      new Config(, , , , deflate_slow),
      /  /
      new Config(, , , , deflate_slow)
      /  max compression /
    ];
    function lm_init(s) {
      s.window_size =   s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = ;
      s.block_start = ;
      s.lookahead = ;
      s.insert = ;
      s.match_length = s.prev_length = MIN_MATCH - ;
      s.match_available = ;
      s.ins_h = ;
    }
    function DeflateState() {
      this.strm = null;
      this.status = ;
      this.pending_buf = null;
      this.pending_buf_size = ;
      this.pending_out = ;
      this.pending = ;
      this.wrap = ;
      this.gzhead = null;
      this.gzindex = ;
      this.method = Z_DEFLATED;
      this.last_flush = -;
      this.w_size = ;
      this.w_bits = ;
      this.w_mask = ;
      this.window = null;
      this.window_size = ;
      this.prev = null;
      this.head = null;
      this.ins_h = ;
      this.hash_size = ;
      this.hash_bits = ;
      this.hash_mask = ;
      this.hash_shift = ;
      this.block_start = ;
      this.match_length = ;
      this.prev_match = ;
      this.match_available = ;
      this.strstart = ;
      this.match_start = ;
      this.lookahead = ;
      this.prev_length = ;
      this.max_chain_length = ;
      this.max_lazy_match = ;
      this.level = ;
      this.strategy = ;
      this.good_match = ;
      this.nice_match = ;
      this.dyn_ltree = new utils.Buf(HEAP_SIZE  );
      this.dyn_dtree = new utils.Buf((  D_CODES + )  );
      this.bl_tree = new utils.Buf((  BL_CODES + )  );
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf(MAX_BITS + );
      this.heap = new utils.Buf(  L_CODES + );
      zero(this.heap);
      this.heap_len = ;
      this.heap_max = ;
      this.depth = new utils.Buf(  L_CODES + );
      zero(this.depth);
      this.l_buf = ;
      this.lit_bufsize = ;
      this.last_lit = ;
      this.d_buf = ;
      this.opt_len = ;
      this.static_len = ;
      this.matches = ;
      this.insert = ;
      this.bi_buf = ;
      this.bi_valid = ;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = ;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = ;
      s.pending_out = ;
      if (s.wrap < ) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap ===  ?  : ;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== ) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = ;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = ;
      }
      if (windowBits < ) {
        wrap = ;
        windowBits = -windowBits;
      } else if (windowBits > ) {
        wrap = ;
        windowBits -= ;
      }
      if (memLevel <  || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits <  || windowBits >  || level <  || level >  || strategy <  || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === ) {
        windowBits = ;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size =  << s.w_bits;
      s.w_mask = s.w_size - ;
      s.hash_bits = memLevel + ;
      s.hash_size =  << s.hash_bits;
      s.hash_mask = s.hash_size - ;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - ) / MIN_MATCH);
      s.window = new utils.Buf(s.w_size  );
      s.head = new utils.Buf(s.hash_size);
      s.prev = new utils.Buf(s.w_size);
      s.lit_bufsize =  << memLevel + ;
      s.pending_buf_size = s.lit_bufsize  ;
      s.pending_buf = new utils.Buf(s.pending_buf_size);
      s.d_buf =   s.lit_bufsize;
      s.l_buf = ( + )  s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < ) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !==  || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out ===  ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === ) {
          strm.adler = ;
          put_byte(s, );
          put_byte(s, );
          put_byte(s, );
          if (!s.gzhead) {
            put_byte(s, );
            put_byte(s, );
            put_byte(s, );
            put_byte(s, );
            put_byte(s, );
            put_byte(s, s.level ===  ?  : s.strategy >= Z_HUFFMAN_ONLY || s.level <  ?  : );
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ?  : ) + (s.gzhead.hcrc ?  : ) + (!s.gzhead.extra ?  : ) + (!s.gzhead.name ?  : ) + (!s.gzhead.comment ?  : )
            );
            put_byte(s, s.gzhead.time & );
            put_byte(s, s.gzhead.time >>  & );
            put_byte(s, s.gzhead.time >>  & );
            put_byte(s, s.gzhead.time >>  & );
            put_byte(s, s.level ===  ?  : s.strategy >= Z_HUFFMAN_ONLY || s.level <  ?  : );
            put_byte(s, s.gzhead.os & );
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & );
              put_byte(s, s.gzhead.extra.length >>  & );
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc(strm.adler, s.pending_buf, s.pending, );
            }
            s.gzindex = ;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits -  << ) << ;
          var level_flags = -;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < ) {
            level_flags = ;
          } else if (s.level < ) {
            level_flags = ;
          } else if (s.level === ) {
            level_flags = ;
          } else {
            level_flags = ;
          }
          header |= level_flags << ;
          if (s.strstart !== ) {
            header |= PRESET_DICT;
          }
          header +=  - header % ;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== ) {
            putShortMSB(s, strm.adler >>> );
            putShortMSB(s, strm.adler & );
          }
          strm.adler = ;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & )) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & );
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = ;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = ;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & ;
            } else {
              val = ;
            }
            put_byte(s, val);
          } while (val !== );
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === ) {
            s.gzindex = ;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = ;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & ;
            } else {
              val = ;
            }
            put_byte(s, val);
          } while (val !== );
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === ) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending +  > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending +  <= s.pending_buf_size) {
            put_byte(s, strm.adler & );
            put_byte(s, strm.adler >>  & );
            strm.adler = ;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== ) {
        flush_pending(strm);
        if (strm.avail_out === ) {
          s.last_flush = -;
          return Z_OK;
        }
      } else if (strm.avail_in ===  && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== ) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !==  || s.lookahead !==  || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === ) {
            s.last_flush = -;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, , , false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === ) {
                s.strstart = ;
                s.block_start = ;
                s.insert = ;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === ) {
            s.last_flush = -;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= ) {
        return Z_STREAM_END;
      }
      if (s.wrap === ) {
        put_byte(s, strm.adler & );
        put_byte(s, strm.adler >>  & );
        put_byte(s, strm.adler >>  & );
        put_byte(s, strm.adler >>  & );
        put_byte(s, strm.total_in & );
        put_byte(s, strm.total_in >>  & );
        put_byte(s, strm.total_in >>  & );
        put_byte(s, strm.total_in >>  & );
      } else {
        putShortMSB(s, strm.adler >>> );
        putShortMSB(s, strm.adler & );
      }
      flush_pending(strm);
      if (s.wrap > ) {
        s.wrap = -s.wrap;
      }
      return s.pending !==  ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap ===  || wrap ===  && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === ) {
        strm.adler = adler(strm.adler, dictionary, dictLength, );
      }
      s.wrap = ;
      if (dictLength >= s.w_size) {
        if (wrap === ) {
          zero(s.head);
          s.strstart = ;
          s.block_start = ;
          s.insert = ;
        }
        tmpDict = new utils.Buf(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, );
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = ;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - );
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - ]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - ;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = ;
      s.match_length = s.prev_length = MIN_MATCH - ;
      s.match_available = ;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports.deflateInit = deflateInit;
    exports.deflateInit = deflateInit;
    exports.deflateReset = deflateReset;
    exports.deflateResetKeep = deflateResetKeep;
    exports.deflateSetHeader = deflateSetHeader;
    exports.deflate = deflate;
    exports.deflateEnd = deflateEnd;
    exports.deflateSetDictionary = deflateSetDictionary;
    exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/utils/strings.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, []);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new UintArray());
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utflen = new utils.Buf();
    for (q = ; q < ; q++) {
      _utflen[q] = q >=  ?  : q >=  ?  : q >=  ?  : q >=  ?  : q >=  ?  : ;
    }
    var q;
    _utflen[] = _utflen[] = ;
    exports.stringbuf = function(str) {
      var buf, c, c, m_pos, i, str_len = str.length, buf_len = ;
      for (m_pos = ; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & ) ===  && m_pos +  < str_len) {
          c = str.charCodeAt(m_pos + );
          if ((c & ) === ) {
            c =  + (c -  << ) + (c - );
            m_pos++;
          }
        }
        buf_len += c <  ?  : c <  ?  : c <  ?  : ;
      }
      buf = new utils.Buf(buf_len);
      for (i = , m_pos = ; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & ) ===  && m_pos +  < str_len) {
          c = str.charCodeAt(m_pos + );
          if ((c & ) === ) {
            c =  + (c -  << ) + (c - );
            m_pos++;
          }
        }
        if (c < ) {
          buf[i++] = c;
        } else if (c < ) {
          buf[i++] =  | c >>> ;
          buf[i++] =  | c & ;
        } else if (c < ) {
          buf[i++] =  | c >>> ;
          buf[i++] =  | c >>>  & ;
          buf[i++] =  | c & ;
        } else {
          buf[i++] =  | c >>> ;
          buf[i++] =  | c >>>  & ;
          buf[i++] =  | c >>>  & ;
          buf[i++] =  | c & ;
        }
      }
      return buf;
    };
    function bufbinstring(buf, len) {
      if (len < ) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result = "";
      for (var i = ; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    }
    exports.bufbinstring = function(buf) {
      return bufbinstring(buf, buf.length);
    };
    exports.binstringbuf = function(str) {
      var buf = new utils.Buf(str.length);
      for (var i = , len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports.bufstring = function(buf, max) {
      var i, out, c, c_len;
      var len = max || buf.length;
      var utfbuf = new Array(len  );
      for (out = , i = ; i < len; ) {
        c = buf[i++];
        if (c < ) {
          utfbuf[out++] = c;
          continue;
        }
        c_len = _utflen[c];
        if (c_len > ) {
          utfbuf[out++] = ;
          i += c_len - ;
          continue;
        }
        c &= c_len ===  ?  : c_len ===  ?  : ;
        while (c_len >  && i < len) {
          c = c <<  | buf[i++] & ;
          c_len--;
        }
        if (c_len > ) {
          utfbuf[out++] = ;
          continue;
        }
        if (c < ) {
          utfbuf[out++] = c;
        } else {
          c -= ;
          utfbuf[out++] =  | c >>  & ;
          utfbuf[out++] =  | c & ;
        }
      }
      return bufbinstring(utfbuf, out);
    };
    exports.utfborder = function(buf, max) {
      var pos;
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      pos = max - ;
      while (pos >=  && (buf[pos] & ) === ) {
        pos--;
      }
      if (pos < ) {
        return max;
      }
      if (pos === ) {
        return max;
      }
      return pos + _utflen[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    function ZStream() {
      this.input = null;
      this.next_in = ;
      this.avail_in = ;
      this.total_in = ;
      this.output = null;
      this.next_out = ;
      this.avail_out = ;
      this.total_out = ;
      this.msg = "";
      this.state = null;
      this.data_type = ;
      this.adler = ;
    }
    module.exports = ZStream;
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/deflate.js
var require_deflate = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/deflate.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var Z_NO_FLUSH = ;
    var Z_FINISH = ;
    var Z_OK = ;
    var Z_STREAM_END = ;
    var Z_SYNC_FLUSH = ;
    var Z_DEFAULT_COMPRESSION = -;
    var Z_DEFAULT_STRATEGY = ;
    var Z_DEFLATED = ;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: ,
        windowBits: ,
        memLevel: ,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > ) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits >  && opt.windowBits < ) {
        opt.windowBits += ;
      }
      this.err = ;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = ;
      var status = zlib_deflate.deflateInit(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.stringbuf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new UintArray(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.stringbuf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new UintArray(data);
      } else {
        strm.input = data;
      }
      strm.next_in = ;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === ) {
          strm.output = new utils.Buf(chunkSize);
          strm.next_out = ;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out ===  || strm.avail_in ===  && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.bufbinstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in >  || strm.avail_out === ) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = ;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports.Deflate = Deflate;
    exports.deflate = deflate;
    exports.deflateRaw = deflateRaw;
    exports.gzip = gzip;
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    var BAD = ;
    var TYPE = ;
    module.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - );
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - );
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = ( << state.lenbits) - ;
      dmask = ( << state.distbits) - ;
      top:
        do {
          if (bits < ) {
            hold += input[_in++] << bits;
            bits += ;
            hold += input[_in++] << bits;
            bits += ;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> ;
              hold >>>= op;
              bits -= op;
              op = here >>>  & ;
              if (op === ) {
                output[_out++] = here & ;
              } else if (op & ) {
                len = here & ;
                op &= ;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += ;
                  }
                  len += hold & ( << op) - ;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < ) {
                  hold += input[_in++] << bits;
                  bits += ;
                  hold += input[_in++] << bits;
                  bits += ;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> ;
                    hold >>>= op;
                    bits -= op;
                    op = here >>>  & ;
                    if (op & ) {
                      dist = here & ;
                      op &= ;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += ;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += ;
                        }
                      }
                      dist += hold & ( << op) - ;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = ;
                        from_source = s_window;
                        if (wnext === ) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = ;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > ) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= ;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > ) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= ;
                        } while (len > );
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > ) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & ) === ) {
                      here = dcode[(here & ) + (hold & ( << op) - )];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & ) === ) {
                here = lcode[(here & ) + (hold & ( << op) - )];
                continue dolen;
              } else if (op & ) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> ;
      _in -= len;
      bits -= len << ;
      hold &= ( << bits) - ;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ?  + (last - _in) :  - (_in - last);
      strm.avail_out = _out < end ?  + (end - _out) :  - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    var utils = require_common();
    var MAXBITS = ;
    var ENOUGH_LENS = ;
    var ENOUGH_DISTS = ;
    var CODES = ;
    var LENS = ;
    var DISTS = ;
    var lbase = [
      / Length codes .. base /
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      
    ];
    var lext = [
      / Length codes .. extra /
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      
    ];
    var dbase = [
      / Distance codes .. base /
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      
    ];
    var dext = [
      / Distance codes .. extra /
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      ,
      
    ];
    module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = ;
      var sym = ;
      var min = , max = ;
      var root = ;
      var curr = ;
      var drop = ;
      var left = ;
      var used = ;
      var huff = ;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = ;
      var end;
      var count = new utils.Buf(MAXBITS + );
      var offs = new utils.Buf(MAXBITS + );
      var extra = null;
      var extra_index = ;
      var here_bits, here_op, here_val;
      for (len = ; len <= MAXBITS; len++) {
        count[len] = ;
      }
      for (sym = ; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= ; max--) {
        if (count[max] !== ) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === ) {
        table[table_index++] =  <<  |  <<  | ;
        table[table_index++] =  <<  |  <<  | ;
        opts.bits = ;
        return ;
      }
      for (min = ; min < max; min++) {
        if (count[min] !== ) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = ;
      for (len = ; len <= MAXBITS; len++) {
        left <<= ;
        left -= count[len];
        if (left < ) {
          return -;
        }
      }
      if (left >  && (type === CODES || max !== )) {
        return -;
      }
      offs[] = ;
      for (len = ; len < MAXBITS; len++) {
        offs[len + ] = offs[len] + count[len];
      }
      for (sym = ; sym < codes; sym++) {
        if (lens[lens_index + sym] !== ) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = ;
      } else if (type === LENS) {
        base = lbase;
        base_index -= ;
        extra = lext;
        extra_index -= ;
        end = ;
      } else {
        base = dbase;
        extra = dext;
        end = -;
      }
      huff = ;
      sym = ;
      len = min;
      next = table_index;
      curr = root;
      drop = ;
      low = -;
      used =  << root;
      mask = used - ;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return ;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = ;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op =  + ;
          here_val = ;
        }
        incr =  << len - drop;
        fill =  << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits <<  | here_op <<  | here_val | ;
        } while (fill !== );
        incr =  << len - ;
        while (huff & incr) {
          incr >>= ;
        }
        if (incr !== ) {
          huff &= incr - ;
          huff += incr;
        } else {
          huff = ;
        }
        sym++;
        if (--count[len] === ) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === ) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left =  << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= ) {
              break;
            }
            curr++;
            left <<= ;
          }
          used +=  << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return ;
          }
          low = huff & mask;
          table[low] = root <<  | curr <<  | next - table_index | ;
        }
      }
      if (huff !== ) {
        table[next + huff] = len - drop <<  |  <<  | ;
      }
      opts.bits = root;
      return ;
    };
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/inflate.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    var utils = require_common();
    var adler = require_adler();
    var crc = require_crc();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = ;
    var LENS = ;
    var DISTS = ;
    var Z_FINISH = ;
    var Z_BLOCK = ;
    var Z_TREES = ;
    var Z_OK = ;
    var Z_STREAM_END = ;
    var Z_NEED_DICT = ;
    var Z_STREAM_ERROR = -;
    var Z_DATA_ERROR = -;
    var Z_MEM_ERROR = -;
    var Z_BUF_ERROR = -;
    var Z_DEFLATED = ;
    var HEAD = ;
    var FLAGS = ;
    var TIME = ;
    var OS = ;
    var EXLEN = ;
    var EXTRA = ;
    var NAME = ;
    var COMMENT = ;
    var HCRC = ;
    var DICTID = ;
    var DICT = ;
    var TYPE = ;
    var TYPEDO = ;
    var STORED = ;
    var COPY_ = ;
    var COPY = ;
    var TABLE = ;
    var LENLENS = ;
    var CODELENS = ;
    var LEN_ = ;
    var LEN = ;
    var LENEXT = ;
    var DIST = ;
    var DISTEXT = ;
    var MATCH = ;
    var LIT = ;
    var CHECK = ;
    var LENGTH = ;
    var DONE = ;
    var BAD = ;
    var MEM = ;
    var SYNC = ;
    var ENOUGH_LENS = ;
    var ENOUGH_DISTS = ;
    var MAX_WBITS = ;
    var DEF_WBITS = MAX_WBITS;
    function zswap(q) {
      return (q >>>  & ) + (q >>>  & ) + ((q & ) << ) + ((q & ) << );
    }
    function InflateState() {
      this.mode = ;
      this.last = false;
      this.wrap = ;
      this.havedict = false;
      this.flags = ;
      this.dmax = ;
      this.check = ;
      this.total = ;
      this.head = null;
      this.wbits = ;
      this.wsize = ;
      this.whave = ;
      this.wnext = ;
      this.window = null;
      this.hold = ;
      this.bits = ;
      this.length = ;
      this.offset = ;
      this.extra = ;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = ;
      this.distbits = ;
      this.ncode = ;
      this.nlen = ;
      this.ndist = ;
      this.have = ;
      this.next = null;
      this.lens = new utils.Buf();
      this.work = new utils.Buf();
      this.lendyn = null;
      this.distdyn = null;
      this.sane = ;
      this.back = ;
      this.was = ;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = ;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & ;
      }
      state.mode = HEAD;
      state.last = ;
      state.havedict = ;
      state.dmax = ;
      state.head = null;
      state.hold = ;
      state.bits = ;
      state.lencode = state.lendyn = new utils.Buf(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf(ENOUGH_DISTS);
      state.sane = ;
      state.back = -;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = ;
      state.whave = ;
      state.wnext = ;
      return inflateResetKeep(strm);
    }
    function inflateReset(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < ) {
        wrap = ;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> ) + ;
        if (windowBits < ) {
          windowBits &= ;
        }
      }
      if (windowBits && (windowBits <  || windowBits > )) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf();
        distfix = new utils.Buf();
        sym = ;
        while (sym < ) {
          state.lens[sym++] = ;
        }
        while (sym < ) {
          state.lens[sym++] = ;
        }
        while (sym < ) {
          state.lens[sym++] = ;
        }
        while (sym < ) {
          state.lens[sym++] = ;
        }
        inflate_table(LENS, state.lens, , , lenfix, , state.work, { bits:  });
        sym = ;
        while (sym < ) {
          state.lens[sym++] = ;
        }
        inflate_table(DISTS, state.lens, , , distfix, , state.work, { bits:  });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = ;
      state.distcode = distfix;
      state.distbits = ;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize =  << state.wbits;
        state.wnext = ;
        state.whave = ;
        state.window = new utils.Buf(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, );
        state.wnext = ;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, );
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = ;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return ;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = ;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf();
      var opts;
      var n;
      var order = (
        / permutation of code lengths /
        [, , , , , , , , , , , , , , , , , , ]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== ) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === ) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < ) {
                if (have === ) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += ;
              }
              if (state.wrap &  && hold === ) {
                state.check = ;
                hbuf[] = hold & ;
                hbuf[] = hold >>>  & ;
                state.check = crc(state.check, hbuf, , );
                hold = ;
                bits = ;
                state.mode = FLAGS;
                break;
              }
              state.flags = ;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & ) || / check if zlib header allowed /
              (((hold & ) << ) + (hold >> )) % ) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & ) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= ;
              bits -= ;
              len = (hold & ) + ;
              if (state.wbits === ) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax =  << len;
              strm.adler = state.check = ;
              state.mode = hold &  ? DICTID : TYPE;
              hold = ;
              bits = ;
              break;
            case FLAGS:
              while (bits < ) {
                if (have === ) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += ;
              }
              state.flags = hold;
              if ((state.flags & ) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & ) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >>  & ;
              }
              if (state.flags & ) {
                hbuf[] = hold & ;
                hbuf[] = hold >>>  & ;
                state.check = crc(state.check, hbuf, , );
              }
              hold = ;
              bits = ;
              state.mode = TIME;
            case TIME:
              while (bits < ) {
                if (have === ) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += ;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & ) {
                hbuf[] = hold & ;
                hbuf[] = hold >>>  & ;
                hbuf[] = hold >>>  & ;
                hbuf[] = hold >>>  & ;
                state.check = crc(state.check, hbuf, , );
              }
              hold = ;
              bits = ;
              state.mode = OS;
            case OS:
              while (bits < ) {
                if (have === ) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += ;
              }
              if (state.head) {
                state.head.xflags = hold & ;
                state.head.os = hold >> ;
              }
              if (state.flags & ) {
                hbuf[] = hold & ;
                hbuf[] = hold >>>  & ;
                state.check = crc(state.check, hbuf, , );
              }
              hold = ;
              bits = ;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & ) {
                while (bits < ) {
                  if (have === ) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += ;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & ) {
                  hbuf[] = hold & ;
                  hbuf[] = hold >>>  & ;
                  state.check = crc(state.check, hbuf, , );
                }
                hold = ;
                bits = ;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & ) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to  bytes
                      // - no need for additional size check
                      copy,
                      /len + copy > state.head.extra_max - len ? state.head.extra_max : copy,/
                      len
                    );
                  }
                  if (state.flags & ) {
                    state.check = crc(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = ;
              state.mode = NAME;
            case NAME:
              if (state.flags & ) {
                if (have === ) {
                  break inf_leave;
                }
                copy = ;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < ) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & ) {
                  state.check = crc(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = ;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & ) {
                if (have === ) {
                  break inf_leave;
                }
                copy = ;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < ) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & ) {
                  state.check = crc(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & ) {
                while (bits < ) {
                  if (have === ) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += ;
                }
                if (hold !== (state.check & )) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = ;
                bits = ;
              }
              if (state.head) {
                state.head.hcrc = state.flags >>  & ;
                state.head.done = true;
              }
              strm.adler = state.check = ;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < ) {
                if (have === ) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += ;
              }
              strm.adler = state.check = zswap(hold);
              hold = ;
              bits = ;
              state.mode = DICT;
            case DICT:
              if (state.havedict === ) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = ;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & ;
                bits -= bits & ;
                state.mode = CHECK;
                break;
              }
              while (bits < ) {
                if (have === ) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += ;
              }
              state.last = hold & ;
              hold >>>= ;
              bits -= ;
              switch (hold & ) {
                case :
                  state.mode = STORED;
                  break;
                case :
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= ;
                    bits -= ;
                    break inf_leave;
                  }
                  break;
                case :
                  state.mode = TABLE;
                  break;
                case :
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= ;
              bits -= ;
              break;
            case STORED:
              hold >>>= bits & ;
              bits -= bits & ;
              while (bits < ) {
                if (have === ) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += ;
              }
              if ((hold & ) !== (hold >>>  ^ )) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & ;
              hold = ;
              bits = ;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === ) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < ) {
                if (have === ) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += ;
              }
              state.nlen = (hold & ) + ;
              hold >>>= ;
              bits -= ;
              state.ndist = (hold & ) + ;
              hold >>>= ;
              bits -= ;
              state.ncode = (hold & ) + ;
              hold >>>= ;
              bits -= ;
              if (state.nlen >  || state.ndist > ) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = ;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < ) {
                  if (have === ) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += ;
                }
                state.lens[order[state.have++]] = hold & ;
                hold >>>= ;
                bits -= ;
              }
              while (state.have < ) {
                state.lens[order[state.have++]] = ;
              }
              state.lencode = state.lendyn;
              state.lenbits = ;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, , , state.lencode, , state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = ;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & ( << state.lenbits) - ];
                  here_bits = here >>> ;
                  here_op = here >>>  & ;
                  here_val = here & ;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === ) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += ;
                }
                if (here_val < ) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === ) {
                    n = here_bits + ;
                    while (bits < n) {
                      if (have === ) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += ;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === ) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - ];
                    copy =  + (hold & );
                    hold >>>= ;
                    bits -= ;
                  } else if (here_val === ) {
                    n = here_bits + ;
                    while (bits < n) {
                      if (have === ) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += ;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = ;
                    copy =  + (hold & );
                    hold >>>= ;
                    bits -= ;
                  } else {
                    n = here_bits + ;
                    while (bits < n) {
                      if (have === ) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += ;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = ;
                    copy =  + (hold & );
                    hold >>>= ;
                    bits -= ;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[] === ) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = ;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, , state.nlen, state.lencode, , state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = ;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, , state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >=  && left >= ) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -;
                }
                break;
              }
              state.back = ;
              for (; ; ) {
                here = state.lencode[hold & ( << state.lenbits) - ];
                here_bits = here >>> ;
                here_op = here >>>  & ;
                here_val = here & ;
                if (here_bits <= bits) {
                  break;
                }
                if (have === ) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += ;
              }
              if (here_op && (here_op & ) === ) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & ( << last_bits + last_op) - ) >> last_bits)];
                  here_bits = here >>> ;
                  here_op = here >>>  & ;
                  here_val = here & ;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === ) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += ;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === ) {
                state.mode = LIT;
                break;
              }
              if (here_op & ) {
                state.back = -;
                state.mode = TYPE;
                break;
              }
              if (here_op & ) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & ;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === ) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += ;
                }
                state.length += hold & ( << state.extra) - ;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & ( << state.distbits) - ];
                here_bits = here >>> ;
                here_op = here >>>  & ;
                here_val = here & ;
                if (here_bits <= bits) {
                  break;
                }
                if (have === ) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += ;
              }
              if ((here_op & ) === ) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & ( << last_bits + last_op) - ) >> last_bits)];
                  here_bits = here >>> ;
                  here_op = here >>>  & ;
                  here_val = here & ;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === ) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += ;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & ) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & ;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === ) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += ;
                }
                state.offset += hold & ( << state.extra) - ;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === ) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === ) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === ) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < ) {
                  if (have === ) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += ;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /UPDATE(state.check, put - _out, _out);/
                  state.flags ? crc(state.check, output, _out, put - _out) : adler(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = ;
                bits = ;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < ) {
                  if (have === ) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += ;
                }
                if (hold !== (state.total & )) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = ;
                bits = ;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /UPDATE(state.check, strm.next_out - _out, _out);/
        state.flags ? crc(state.check, output, _out, strm.next_out - _out) : adler(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ?  : ) + (state.mode === TYPE ?  : ) + (state.mode === LEN_ || state.mode === COPY_ ?  : );
      if ((_in ===  && _out ===  || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & ) === ) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !==  && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = ;
        dictid = adler(dictid, dictionary, dictLength, );
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = ;
      return Z_OK;
    }
    exports.inflateReset = inflateReset;
    exports.inflateReset = inflateReset;
    exports.inflateResetKeep = inflateResetKeep;
    exports.inflateInit = inflateInit;
    exports.inflateInit = inflateInit;
    exports.inflate = inflate;
    exports.inflateEnd = inflateEnd;
    exports.inflateGetHeader = inflateGetHeader;
    exports.inflateSetDictionary = inflateSetDictionary;
    exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    module.exports = {
      / Allowed flush values; see deflate() and inflate() below for details /
      Z_NO_FLUSH: ,
      Z_PARTIAL_FLUSH: ,
      Z_SYNC_FLUSH: ,
      Z_FULL_FLUSH: ,
      Z_FINISH: ,
      Z_BLOCK: ,
      Z_TREES: ,
      / Return codes for the compression/decompression functions. Negative values
       are errors, positive values are used for special but normal events.
      /
      Z_OK: ,
      Z_STREAM_END: ,
      Z_NEED_DICT: ,
      Z_ERRNO: -,
      Z_STREAM_ERROR: -,
      Z_DATA_ERROR: -,
      //Z_MEM_ERROR:     -,
      Z_BUF_ERROR: -,
      //Z_VERSION_ERROR: -,
      / compression levels /
      Z_NO_COMPRESSION: ,
      Z_BEST_SPEED: ,
      Z_BEST_COMPRESSION: ,
      Z_DEFAULT_COMPRESSION: -,
      Z_FILTERED: ,
      Z_HUFFMAN_ONLY: ,
      Z_RLE: ,
      Z_FIXED: ,
      Z_DEFAULT_STRATEGY: ,
      / Possible values of the data_type field (though see inflate()) /
      Z_BINARY: ,
      Z_TEXT: ,
      //Z_ASCII:                , // = Z_TEXT (deprecated)
      Z_UNKNOWN: ,
      / The deflate compression method /
      Z_DEFLATED: 
      //Z_NULL:                 null // Use - or null inline, depending on var type
    };
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    function GZheader() {
      this.text = ;
      this.time = ;
      this.xflags = ;
      this.os = ;
      this.extra = null;
      this.extra_len = ;
      this.name = "";
      this.comment = "";
      this.hcrc = ;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/lib/inflate.js
var require_inflate = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/lib/inflate.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: ,
        windowBits: ,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >=  && opt.windowBits < ) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === ) {
          opt.windowBits = -;
        }
      }
      if (opt.windowBits >=  && opt.windowBits <  && !(options && options.windowBits)) {
        opt.windowBits += ;
      }
      if (opt.windowBits >  && opt.windowBits < ) {
        if ((opt.windowBits & ) === ) {
          opt.windowBits |= ;
        }
      }
      this.err = ;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = ;
      var status = zlib_inflate.inflateInit(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.stringbuf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new UintArray(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf, tail, utfstr;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstringbuf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new UintArray(data);
      } else {
        strm.input = data;
      }
      strm.next_in = ;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === ) {
          strm.output = new utils.Buf(chunkSize);
          strm.next_out = ;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out ===  || status === c.Z_STREAM_END || strm.avail_in ===  && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf = strings.utfborder(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf;
              utfstr = strings.bufstring(strm.output, next_out_utf);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf, tail, );
              }
              this.onData(utfstr);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in ===  && strm.avail_out === ) {
          allowBufError = true;
        }
      } while ((strm.avail_in >  || strm.avail_out === ) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = ;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports.Inflate = Inflate;
    exports.inflate = inflate;
    exports.inflateRaw = inflateRaw;
    exports.ungzip = inflate;
  }
});

// node_modules/.pnpm/pako@../node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/.pnpm/pako@../node_modules/pako/index.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    var assign = require_common().assign;
    var deflate = require_deflate();
    var inflate = require_inflate();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module.exports = pako;
  }
});

// node_modules/.pnpm/pify@../node_modules/pify/index.js
var require_pify = __commonJS({
  "node_modules/.pnpm/pify@../node_modules/pify/index.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    var processFn = (fn, options) => function(...args) {
      const P = options.promiseModule;
      return new P((resolve, reject) => {
        if (options.multiArgs) {
          args.push((...result) => {
            if (options.errorFirst) {
              if (result[]) {
                reject(result);
              } else {
                result.shift();
                resolve(result);
              }
            } else {
              resolve(result);
            }
          });
        } else if (options.errorFirst) {
          args.push((error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          });
        } else {
          args.push(resolve);
        }
        fn.apply(this, args);
      });
    };
    module.exports = (input, options) => {
      options = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, options);
      const objType = typeof input;
      if (!(input !== null && (objType === "object" || objType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objType}\``);
      }
      const filter = (key) => {
        const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return options.include ? options.include.some(match) : !options.exclude.some(match);
      };
      let ret;
      if (objType === "function") {
        ret = function(...args) {
          return options.excludeMain ? input(...args) : processFn(input, options).apply(this, args);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(input));
      }
      for (const key in input) {
        const property = input[key];
        ret[key] = typeof property === "function" && filter(key) ? processFn(property, options) : property;
      }
      return ret;
    };
  }
});

// node_modules/.pnpm/ignore@../node_modules/ignore/index.js
var require_ignore = __commonJS({
  "node_modules/.pnpm/ignore@../node_modules/ignore/index.js"(exports, module) {
    init_polyfill_buffer();
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.\/|^\.+$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([-z])-([-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt() <= to.charCodeAt() ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(, length - length % );
    };
    var REPLACERS = [
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a \ ) -> (a  )
        /\\?\s+$/,
        (match) => match.indexOf("\\") ===  ? SPACE : EMPTY
      ],
      // replace (\ ) with ' '
      [
        /\\\s/g,
        () => SPACE
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are  characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star ,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/.c" matches "cat-file.c" but not "mozilla-sha/sha.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "" followed by a slash means match in all directories.
        // > For example, "/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the ''s have been replaced as '\\'
        /^\^\\\\\\\\\//,
        // '/foo' <-> 'foo'
        () => "^(?:.\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/'`
        /\\\/\\\\\\(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '', or it will be replaced by the next replacer
        // Check if it is not the last `'/'`
        (_, index, str) => index +  < str.length ? "(?:\\/[^\\/]+)" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped ''
        // ignore rule '\' will match the path ''
        // 'abc./' -> go
        // 'abc.'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\)+(?=.+)/g,
        // '.js' matches '.js'
        // '.js' doesn't match 'abc'
        (_, p, p) => {
          const unescaped = p.replace(/\\\/g, "[^\\/]");
          return p + unescaped;
        }
      ],
      [
        // unescape, revert step  except for back slash
        // For example, if a user escape a '\\',
        // after step , the result will be '\\\\\\'
        /\\\\\\(?=[$.|+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 
        /(\\)?\[([^\]/]?)(\\)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length %  ===  ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [..](https://git-scm.com/docs/gitignore/..)
        // which re-fixes , 
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      // trailing wildcard
      [
        /(\^|\\\/)?\\\$/,
        (_, p) => {
          const prefix = p ? `${p}[^/]+` : "[^/]";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = / @__PURE__ / Object.create(null);
    var makeRegex = (pattern, ignoreCase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce(
          (prev, current) => prev.replace(current[], current[].bind(pattern)),
          pattern
        );
        regexCache[pattern] = source;
      }
      return ignoreCase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("") !== ;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignoreCase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === ) {
        negative = true;
        pattern = pattern.substr();
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "");
      const regex = makeRegex(pattern, ignoreCase);
      return new IgnoreRule(
        origin,
        pattern,
        negative,
        regex
      );
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignoreCase = ignoreCase;
        this._allowRelativePaths = allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = / @__PURE__ / Object.create(null);
        this._testCache = / @__PURE__ / Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      //          |           ignored : unignored
      // negative |   :   |   :   |   :   |   :
      // -------- | ------- | ------- | ------- | --------
      //         |  TEST   |  TEST   |  SKIP   |    X
      //         |  TESTIF |  SKIP   |  TEST   |    X
      // - SKIP: always skip
      // - TEST: always test
      // - TESTIF: only test if checkUnignored
      // - X: that never happen
      // @param {boolean} whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // @returns {TestResult} true if a file is ignored
      _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(
          path,
          originalPath,
          this._allowRelativePaths ? RETURN_FALSE : throwError
        );
        return this._t(path, cache, checkUnignored, slices);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._testOne(path, checkUnignored);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module.exports = factory;
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN || process.platform === "win")
    ) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u-\uF]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    }
  }
});

// node_modules/.pnpm/clean-git-ref@../node_modules/clean-git-ref/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/clean-git-ref@../node_modules/clean-git-ref/lib/index.js"(exports, module) {
    "use strict";
    init_polyfill_buffer();
    function escapeRegExp(string) {
      return string.replace(/[.+?^${}()|[\]\\]/g, "\\$&");
    }
    function replaceAll(str, search, replacement) {
      search = search instanceof RegExp ? search : new RegExp(escapeRegExp(search), "g");
      return str.replace(search, replacement);
    }
    var CleanGitRef = {
      clean: function clean(value) {
        if (typeof value !== "string") {
          throw new Error("Expected a string, received: " + value);
        }
        value = replaceAll(value, "./", "/");
        value = replaceAll(value, "..", ".");
        value = replaceAll(value, " ", "-");
        value = replaceAll(value, /^[~^:?\\\-]/g, "");
        value = replaceAll(value, /[~^:?\\]/g, "-");
        value = replaceAll(value, /[~^:?\\\-]$/g, "");
        value = replaceAll(value, "@{", "-");
        value = replaceAll(value, /\.$/g, "");
        value = replaceAll(value, /\/$/g, "");
        value = replaceAll(value, /\.lock$/g, "");
        return value;
      }
    };
    module.exports = CleanGitRef;
  }
});

// node_modules/.pnpm/diff@../node_modules/diff/onp.js
var require_onp = __commonJS({
  "node_modules/.pnpm/diff@../node_modules/diff/onp.js"(exports, module) {
    init_polyfill_buffer();
    module.exports = function(a_, b_) {
      var a = a_, b = b_, m = a.length, n = b.length, reverse = false, ed = null, offset = m + , path = [], pathposi = [], ses = [], lcs = "", SES_DELETE = -, SES_COMMON = , SES_ADD = ;
      var tmp, tmp;
      var init = function() {
        if (m >= n) {
          tmp = a;
          tmp = m;
          a = b;
          b = tmp;
          m = n;
          n = tmp;
          reverse = true;
          offset = m + ;
        }
      };
      var P = function(x, y, k) {
        return {
          "x": x,
          "y": y,
          "k": k
        };
      };
      var seselem = function(elem, t) {
        return {
          "elem": elem,
          "t": t
        };
      };
      var snake = function(k, p, pp) {
        var r, x, y;
        if (p > pp) {
          r = path[k -  + offset];
        } else {
          r = path[k +  + offset];
        }
        y = Math.max(p, pp);
        x = y - k;
        while (x < m && y < n && a[x] === b[y]) {
          ++x;
          ++y;
        }
        path[k + offset] = pathposi.length;
        pathposi[pathposi.length] = new P(x, y, r);
        return y;
      };
      var recordseq = function(epc) {
        var x_idx, y_idx, px_idx, py_idx, i;
        x_idx = y_idx = ;
        px_idx = py_idx = ;
        for (i = epc.length - ; i >= ; --i) {
          while (px_idx < epc[i].x || py_idx < epc[i].y) {
            if (epc[i].y - epc[i].x > py_idx - px_idx) {
              if (reverse) {
                ses[ses.length] = new seselem(b[py_idx], SES_DELETE);
              } else {
                ses[ses.length] = new seselem(b[py_idx], SES_ADD);
              }
              ++y_idx;
              ++py_idx;
            } else if (epc[i].y - epc[i].x < py_idx - px_idx) {
              if (reverse) {
                ses[ses.length] = new seselem(a[px_idx], SES_ADD);
              } else {
                ses[ses.length] = new seselem(a[px_idx], SES_DELETE);
              }
              ++x_idx;
              ++px_idx;
            } else {
              ses[ses.length] = new seselem(a[px_idx], SES_COMMON);
              lcs += a[px_idx];
              ++x_idx;
              ++y_idx;
              ++px_idx;
              ++py_idx;
            }
          }
        }
      };
      init();
      return {
        SES_DELETE: -,
        SES_COMMON: ,
        SES_ADD: ,
        editdistance: function() {
          return ed;
        },
        getlcs: function() {
          return lcs;
        },
        getses: function() {
          return ses;
        },
        compose: function() {
          var delta, size, fp, p, r, epc, i, k;
          delta = n - m;
          size = m + n + ;
          fp = {};
          for (i = ; i < size; ++i) {
            fp[i] = -;
            path[i] = -;
          }
          p = -;
          do {
            ++p;
            for (k = -p; k <= delta - ; ++k) {
              fp[k + offset] = snake(k, fp[k -  + offset] + , fp[k +  + offset]);
            }
            for (k = delta + p; k >= delta + ; --k) {
              fp[k + offset] = snake(k, fp[k -  + offset] + , fp[k +  + offset]);
            }
            fp[delta + offset] = snake(delta, fp[delta -  + offset] + , fp[delta +  + offset]);
          } while (fp[delta + offset] !== n);
          ed = delta +   p;
          r = path[delta + offset];
          epc = [];
          while (r !== -) {
            epc[epc.length] = new P(pathposi[r].x, pathposi[r].y, null);
            r = pathposi[r].k;
          }
          recordseq(epc);
        }
      };
    };
  }
});

// node_modules/.pnpm/diff@../node_modules/diff/diff.js
var require_diff = __commonJS({
  "node_modules/.pnpm/diff@../node_modules/diff/diff.js"(exports, module) {
    init_polyfill_buffer();
    var onp = require_onp();
    function longestCommonSubsequence(file, file) {
      var diff = new onp(file, file);
      diff.compose();
      var ses = diff.getses();
      var root;
      var prev;
      var fileRevIdx = file.length - , fileRevIdx = file.length - ;
      for (var i = ses.length - ; i >= ; --i) {
        if (ses[i].t === diff.SES_COMMON) {
          if (prev) {
            prev.chain = {
              fileindex: fileRevIdx,
              fileindex: fileRevIdx,
              chain: null
            };
            prev = prev.chain;
          } else {
            root = {
              fileindex: fileRevIdx,
              fileindex: fileRevIdx,
              chain: null
            };
            prev = root;
          }
          fileRevIdx--;
          fileRevIdx--;
        } else if (ses[i].t === diff.SES_DELETE) {
          fileRevIdx--;
        } else if (ses[i].t === diff.SES_ADD) {
          fileRevIdx--;
        }
      }
      var tail = {
        fileindex: -,
        fileindex: -,
        chain: null
      };
      if (!prev) {
        return tail;
      }
      prev.chain = tail;
      return root;
    }
    function diffIndices(file, file) {
      var result = [];
      var tail = file.length;
      var tail = file.length;
      for (var candidate = longestCommonSubsequence(file, file); candidate !== null; candidate = candidate.chain) {
        var mismatchLength = tail - candidate.fileindex - ;
        var mismatchLength = tail - candidate.fileindex - ;
        tail = candidate.fileindex;
        tail = candidate.fileindex;
        if (mismatchLength || mismatchLength) {
          result.push({
            file: [tail + , mismatchLength],
            file: [tail + , mismatchLength]
          });
        }
      }
      result.reverse();
      return result;
    }
    function diffMergeIndices(a, o, b) {
      var i;
      var m = diffIndices(o, a);
      var m = diffIndices(o, b);
      var hunks = [];
      function addHunk(h, side) {
        hunks.push([h.file[], side, h.file[], h.file[], h.file[]]);
      }
      for (i = ; i < m.length; i++) {
        addHunk(m[i], );
      }
      for (i = ; i < m.length; i++) {
        addHunk(m[i], );
      }
      hunks.sort(function(x, y) {
        return x[] - y[];
      });
      var result = [];
      var commonOffset = ;
      function copyCommon(targetOffset) {
        if (targetOffset > commonOffset) {
          result.push([, commonOffset, targetOffset - commonOffset]);
          commonOffset = targetOffset;
        }
      }
      for (var hunkIndex = ; hunkIndex < hunks.length; hunkIndex++) {
        var firstHunkIndex = hunkIndex;
        var hunk = hunks[hunkIndex];
        var regionLhs = hunk[];
        var regionRhs = regionLhs + hunk[];
        while (hunkIndex < hunks.length - ) {
          var maybeOverlapping = hunks[hunkIndex + ];
          var maybeLhs = maybeOverlapping[];
          if (maybeLhs > regionRhs)
            break;
          regionRhs = Math.max(regionRhs, maybeLhs + maybeOverlapping[]);
          hunkIndex++;
        }
        copyCommon(regionLhs);
        if (firstHunkIndex == hunkIndex) {
          if (hunk[] > ) {
            result.push([hunk[], hunk[], hunk[]]);
          }
        } else {
          var regions = {
            : [a.length, -, o.length, -],
            : [b.length, -, o.length, -]
          };
          for (i = firstHunkIndex; i <= hunkIndex; i++) {
            hunk = hunks[i];
            var side = hunk[];
            var r = regions[side];
            var oLhs = hunk[];
            var oRhs = oLhs + hunk[];
            var abLhs = hunk[];
            var abRhs = abLhs + hunk[];
            r[] = Math.min(abLhs, r[]);
            r[] = Math.max(abRhs, r[]);
            r[] = Math.min(oLhs, r[]);
            r[] = Math.max(oRhs, r[]);
          }
          var aLhs = regions[][] + (regionLhs - regions[][]);
          var aRhs = regions[][] + (regionRhs - regions[][]);
          var bLhs = regions[][] + (regionLhs - regions[][]);
          var bRhs = regions[][] + (regionRhs - regions[][]);
          result.push([
            -,
            aLhs,
            aRhs - aLhs,
            regionLhs,
            regionRhs - regionLhs,
            bLhs,
            bRhs - bLhs
          ]);
        }
        commonOffset = regionRhs;
      }
      copyCommon(o.length);
      return result;
    }
    function diffMerge(a, o, b) {
      var result = [];
      var files = [a, o, b];
      var indices = diffMergeIndices(a, o, b);
      var okLines = [];
      function flushOk() {
        if (okLines.length) {
          result.push({
            ok: okLines
          });
        }
        okLines = [];
      }
      function pushOk(xs) {
        for (var j = ; j < xs.length; j++) {
          okLines.push(xs[j]);
        }
      }
      function isTrueConflict(rec) {
        if (rec[] != rec[])
          return true;
        var aoff = rec[];
        var boff = rec[];
        for (var j = ; j < rec[]; j++) {
          if (a[j + aoff] != b[j + boff])
            return true;
        }
        return false;
      }
      for (var i = ; i < indices.length; i++) {
        var x = indices[i];
        var side = x[];
        if (side == -) {
          if (!isTrueConflict(x)) {
            pushOk(files[].slice(x[], x[] + x[]));
          } else {
            flushOk();
            result.push({
              conflict: {
                a: a.slice(x[], x[] + x[]),
                aIndex: x[],
                o: o.slice(x[], x[] + x[]),
                oIndex: x[],
                b: b.slice(x[], x[] + x[]),
                bIndex: x[]
              }
            });
          }
        } else {
          pushOk(files[side].slice(x[], x[] + x[]));
        }
      }
      flushOk();
      return result;
    }
    module.exports = diffMerge;
  }
});

// node_modules/.pnpm/ms@../node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/.pnpm/ms@../node_modules/ms/index.js"(exports, module) {
    init_polyfill_buffer();
    var s = e;
    var m = s  ;
    var h = m  ;
    var d = h  ;
    var w = d  ;
    var y = d  .;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > ) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > ) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) (milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[]);
      var type = (match[] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n  y;
        case "weeks":
        case "week":
        case "w":
          return n  w;
        case "days":
        case "day":
        case "d":
          return n  d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n  h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n  m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n  s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void ;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n  .;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/.pnpm/debug@.._supports-color@../node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/debug@.._supports-color@../node_modules/debug/src/common.js"(exports, module) {
    init_polyfill_buffer();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = ;
        for (let i = ; i < namespace.length; i++) {
          hash = (hash << ) - hash + namespace.charCodeAt(i);
          hash |= ;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self = debug;
          const curr = Number(/ @__PURE__ / new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[] = createDebug.coerce(args[]);
          if (typeof args[] !== "string") {
            args.unshift("%O");
          }
          let index = ;
          args[] = args[].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, );
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = ; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\/g, ".?");
          if (namespaces[] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice() + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - ] === "") {
          return true;
        }
        let i;
        let len;
        for (i = , len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = , len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(, regexp.toString().length - ).replace(/\.\\?$/, "");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/.pnpm/debug@.._supports-color@../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/debug@.._supports-color@../node_modules/debug/src/browser.js"(exports, module) {
    init_polyfill_buffer();
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "CC",
      "FF",
      "CC",
      "FF",
      "CC",
      "FF",
      "CC",
      "FF",
      "CC",
      "CC",
      "CC",
      "CC",
      "CCCC",
      "CCFF",
      "CC",
      "FF",
      "CC",
      "FF",
      "CC",
      "FF",
      "CC",
      "FF",
      "CC",
      "CC",
      "CC",
      "CC",
      "CCCC",
      "CCFF",
      "CC",
      "FF",
      "CC",
      "FF",
      "CC",
      "CC",
      "CC",
      "FF",
      "CC",
      "FF",
      "CC",
      "CC",
      "CC",
      "CC",
      "CC",
      "CC",
      "CCCC",
      "CCFF",
      "CC",
      "CC",
      "CC",
      "CC",
      "CCCC",
      "CCFF",
      "CC",
      "CC",
      "CC",
      "CC",
      "CCCC",
      "CCCC",
      "FF",
      "FF",
      "FF",
      "FF",
      "FFCC",
      "FFFF",
      "FF",
      "FF",
      "FF",
      "FF",
      "FFCC",
      "FFFF",
      "FF",
      "FF",
      "FF",
      "FF",
      "FFCC",
      "FFCC"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a//
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_ConsoleStyling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$, ) >=  || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(, , c, "color: inherit");
      let index = ;
      let lastC = ;
      args[].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, , c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/.pnpm/@kwsites+file-exists@.._supports-color@../node_modules/@kwsites/file-exists/dist/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/@kwsites+file-exists@.._supports-color@../node_modules/@kwsites/file-exists/dist/src/index.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var fs_ = require("fs");
    var debug_ = __importDefault(require_browser());
    var log = debug_.default("@kwsites/file-exists");
    function check(path, isFile, isDirectory) {
      log(`checking %s`, path);
      try {
        const stat = fs_.statSync(path);
        if (stat.isFile() && isFile) {
          log(`[OK] path represents a file`);
          return true;
        }
        if (stat.isDirectory() && isDirectory) {
          log(`[OK] path represents a directory`);
          return true;
        }
        log(`[FAIL] path represents something other than a file or directory`);
        return false;
      } catch (e) {
        if (e.code === "ENOENT") {
          log(`[FAIL] path is not accessible: %o`, e);
          return false;
        }
        log(`[FATAL] %o`, e);
        throw e;
      }
    }
    function exists(path, type = exports.READABLE) {
      return check(path, (type & exports.FILE) > , (type & exports.FOLDER) > );
    }
    exports.exists = exists;
    exports.FILE = ;
    exports.FOLDER = ;
    exports.READABLE = exports.FILE + exports.FOLDER;
  }
});

// node_modules/.pnpm/@kwsites+file-exists@.._supports-color@../node_modules/@kwsites/file-exists/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@kwsites+file-exists@.._supports-color@../node_modules/@kwsites/file-exists/dist/index.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    function __export(m) {
      for (var p in m)
        if (!exports.hasOwnProperty(p))
          exports[p] = m[p];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export(require_src());
  }
});

// node_modules/.pnpm/@kwsites+promise-deferred@../node_modules/@kwsites/promise-deferred/dist/index.js
var require_dist = __commonJS({
  "node_modules/.pnpm/@kwsites+promise-deferred@../node_modules/@kwsites/promise-deferred/dist/index.js"(exports) {
    "use strict";
    init_polyfill_buffer();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createDeferred = exports.deferred = void ;
    function deferred() {
      let done;
      let fail;
      let status = "pending";
      const promise = new Promise((_done, _fail) => {
        done = _done;
        fail = _fail;
      });
      return {
        promise: promise,
        done(result) {
          if (status === "pending") {
            status = "resolved";
            done(result);
          }
        },
        fail(error) {
          if (status === "pending") {
            status = "rejected";
            fail(error);
          }
        },
        get fulfilled() {
          return status !== "pending";
        },
        get status() {
          return status;
        }
      };
    }
    exports.deferred = deferred;
    exports.createDeferred = deferred;
    exports.default = deferred;
  }
});

// node_modules/.pnpm/hogan.js@../node_modules/hogan.js/lib/compiler.js
var require_compiler = __commonJS({
  "node_modules/.pnpm/hogan.js@../node_modules/hogan.js/lib/compiler.js"(exports) {
    init_polyfill_buffer();
    (function(Hogan) {
      var rIsWhitespace = /\S/, rQuot = /\"/g, rNewline = /\n/g, rCr = /\r/g, rSlash = /\\/g, rLineSep = /\u/, rParagraphSep = /\u/;
      Hogan.tags = {
        "": ,
        "^": ,
        "<": ,
        "$": ,
        "/": ,
        "!": ,
        ">": ,
        "=": ,
        "_v": ,
        "{": ,
        "&": ,
        "_t": 
      };
      Hogan.scan = function scan(text, delimiters) {
        var len = text.length, IN_TEXT = , IN_TAG_TYPE = , IN_TAG = , state = IN_TEXT, tagType = null, tag = null, buf = "", tokens = [], seenTag = false, i = , lineStart = , otag = "{{", ctag = "}}";
        function addBuf() {
          if (buf.length > ) {
            tokens.push({ tag: "_t", text: new String(buf) });
            buf = "";
          }
        }
        function lineIsWhitespace() {
          var isAllWhitespace = true;
          for (var j = lineStart; j < tokens.length; j++) {
            isAllWhitespace = Hogan.tags[tokens[j].tag] < Hogan.tags["_v"] || tokens[j].tag == "_t" && tokens[j].text.match(rIsWhitespace) === null;
            if (!isAllWhitespace) {
              return false;
            }
          }
          return isAllWhitespace;
        }
        function filterLine(haveSeenTag, noNewLine) {
          addBuf();
          if (haveSeenTag && lineIsWhitespace()) {
            for (var j = lineStart, next; j < tokens.length; j++) {
              if (tokens[j].text) {
                if ((next = tokens[j + ]) && next.tag == ">") {
                  next.indent = tokens[j].text.toString();
                }
                tokens.splice(j, );
              }
            }
          } else if (!noNewLine) {
            tokens.push({ tag: "\n" });
          }
          seenTag = false;
          lineStart = tokens.length;
        }
        function changeDelimiters(text, index) {
          var close = "=" + ctag, closeIndex = text.indexOf(close, index), delimiters = trim(
            text.substring(text.indexOf("=", index) + , closeIndex)
          ).split(" ");
          otag = delimiters[];
          ctag = delimiters[delimiters.length - ];
          return closeIndex + close.length - ;
        }
        if (delimiters) {
          delimiters = delimiters.split(" ");
          otag = delimiters[];
          ctag = delimiters[];
        }
        for (i = ; i < len; i++) {
          if (state == IN_TEXT) {
            if (tagChange(otag, text, i)) {
              --i;
              addBuf();
              state = IN_TAG_TYPE;
            } else {
              if (text.charAt(i) == "\n") {
                filterLine(seenTag);
              } else {
                buf += text.charAt(i);
              }
            }
          } else if (state == IN_TAG_TYPE) {
            i += otag.length - ;
            tag = Hogan.tags[text.charAt(i + )];
            tagType = tag ? text.charAt(i + ) : "_v";
            if (tagType == "=") {
              i = changeDelimiters(text, i);
              state = IN_TEXT;
            } else {
              if (tag) {
                i++;
              }
              state = IN_TAG;
            }
            seenTag = i;
          } else {
            if (tagChange(ctag, text, i)) {
              tokens.push({
                tag: tagType,
                n: trim(buf),
                otag,
                ctag,
                i: tagType == "/" ? seenTag - otag.length : i + ctag.length
              });
              buf = "";
              i += ctag.length - ;
              state = IN_TEXT;
              if (tagType == "{") {
                if (ctag == "}}") {
                  i++;
                } else {
                  cleanTripleStache(tokens[tokens.length - ]);
                }
              }
            } else {
              buf += text.charAt(i);
            }
          }
        }
        filterLine(seenTag, true);
        return tokens;
      };
      function cleanTripleStache(token) {
        if (token.n.substr(token.n.length - ) === "}") {
          token.n = token.n.substring(, token.n.length - );
        }
      }
      function trim(s) {
        if (s.trim) {
          return s.trim();
        }
        return s.replace(/^\s|\s$/g, "");
      }
      function tagChange(tag, text, index) {
        if (text.charAt(index) != tag.charAt()) {
          return false;
        }
        for (var i = , l = tag.length; i < l; i++) {
          if (text.charAt(index + i) != tag.charAt(i)) {
            return false;
          }
        }
        return true;
      }
      var allowedInSuper = { "_t": true, "\n": true, "$": true, "/": true };
      function buildTree(tokens, kind, stack, customTags) {
        var instructions = [], opener = null, tail = null, token = null;
        tail = stack[stack.length - ];
        while (tokens.length > ) {
          token = tokens.shift();
          if (tail && tail.tag == "<" && !(token.tag in allowedInSuper)) {
            throw new Error("Illegal content in < super tag.");
          }
          if (Hogan.tags[token.tag] <= Hogan.tags["$"] || isOpener(token, customTags)) {
            stack.push(token);
            token.nodes = buildTree(tokens, token.tag, stack, customTags);
          } else if (token.tag == "/") {
            if (stack.length === ) {
              throw new Error("Closing tag without opener: /" + token.n);
            }
            opener = stack.pop();
            if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {
              throw new Error("Nesting error: " + opener.n + " vs. " + token.n);
            }
            opener.end = token.i;
            return instructions;
          } else if (token.tag == "\n") {
            token.last = tokens.length ==  || tokens[].tag == "\n";
          }
          instructions.push(token);
        }
        if (stack.length > ) {
          throw new Error("missing closing tag: " + stack.pop().n);
        }
        return instructions;
      }
      function isOpener(token, tags) {
        for (var i = , l = tags.length; i < l; i++) {
          if (tags[i].o == token.n) {
            token.tag = "";
            return true;
          }
        }
      }
      function isCloser(close, open, tags) {
        for (var i = , l = tags.length; i < l; i++) {
          if (tags[i].c == close && tags[i].o == open) {
            return true;
          }
        }
      }
      function stringifySubstitutions(obj) {
        var items = [];
        for (var key in obj) {
          items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + "}");
        }
        return "{ " + items.join(",") + " }";
      }
      function stringifyPartials(codeObj) {
        var partials = [];
        for (var key in codeObj.partials) {
          partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + "}");
        }
        return "partials: {" + partials.join(",") + "}, subs: " + stringifySubstitutions(codeObj.subs);
      }
      Hogan.stringify = function(codeObj, text, options) {
        return "{code: function (c,p,i) { " + Hogan.wrapMain(codeObj.code) + " }," + stringifyPartials(codeObj) + "}";
      };
      var serialNo = ;
      Hogan.generate = function(tree, text, options) {
        serialNo = ;
        var context = { code: "", subs: {}, partials: {} };
        Hogan.walk(tree, context);
        if (options.asString) {
          return this.stringify(context, text, options);
        }
        return this.makeTemplate(context, text, options);
      };
      Hogan.wrapMain = function(code) {
        return 'var t=this;t.b(i=i||"");' + code + "return t.fl();";
      };
      Hogan.template = Hogan.Template;
      Hogan.makeTemplate = function(codeObj, text, options) {
        var template = this.makePartials(codeObj);
        template.code = new Function("c", "p", "i", this.wrapMain(codeObj.code));
        return new this.template(template, text, this, options);
      };
      Hogan.makePartials = function(codeObj) {
        var key, template = { subs: {}, partials: codeObj.partials, name: codeObj.name };
        for (key in template.partials) {
          template.partials[key] = this.makePartials(template.partials[key]);
        }
        for (key in codeObj.subs) {
          template.subs[key] = new Function("c", "p", "t", "i", codeObj.subs[key]);
        }
        return template;
      };
      function esc(s) {
        return s.replace(rSlash, "\\\\").replace(rQuot, '\\"').replace(rNewline, "\\n").replace(rCr, "\\r").replace(rLineSep, "\\u").replace(rParagraphSep, "\\u");
      }
      function chooseMethod(s) {
        return ~s.indexOf(".") ? "d" : "f";
      }
      function createPartial(node, context) {
        var prefix = "<" + (context.prefix || "");
        var sym = prefix + node.n + serialNo++;
        context.partials[sym] = { name: node.n, partials: {} };
        context.code += 't.b(t.rp("' + esc(sym) + '",c,p,"' + (node.indent || "") + '"));';
        return sym;
      }
      Hogan.codegen = {
        "": function(node, context) {
          context.code += "if(t.s(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,),c,p,,' + node.i + "," + node.end + ',"' + node.otag + " " + node.ctag + '")){t.rs(c,p,function(c,p,t){';
          Hogan.walk(node.nodes, context);
          context.code += "});c.pop();}";
        },
        "^": function(node, context) {
          context.code += "if(!t.s(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,),c,p,,,,"")){';
          Hogan.walk(node.nodes, context);
          context.code += "};";
        },
        ">": createPartial,
        "<": function(node, context) {
          var ctx = { partials: {}, code: "", subs: {}, inPartial: true };
          Hogan.walk(node.nodes, ctx);
          var template = context.partials[createPartial(node, context)];
          template.subs = ctx.subs;
          template.partials = ctx.partials;
        },
        "$": function(node, context) {
          var ctx = { subs: {}, code: "", partials: context.partials, prefix: node.n };
          Hogan.walk(node.nodes, ctx);
          context.subs[node.n] = ctx.code;
          if (!context.inPartial) {
            context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
          }
        },
        "\n": function(node, context) {
          context.code += write('"\\n"' + (node.last ? "" : " + i"));
        },
        "_v": function(node, context) {
          context.code += "t.b(t.v(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,)));';
        },
        "_t": function(node, context) {
          context.code += write('"' + esc(node.text) + '"');
        },
        "{": tripleStache,
        "&": tripleStache
      };
      function tripleStache(node, context) {
        context.code += "t.b(t.t(t." + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,)));';
      }
      function write(s) {
        return "t.b(" + s + ");";
      }
      Hogan.walk = function(nodelist, context) {
        var func;
        for (var i = , l = nodelist.length; i < l; i++) {
          func = Hogan.codegen[nodelist[i].tag];
          func && func(nodelist[i], context);
        }
        return context;
      };
      Hogan.parse = function(tokens, text, options) {
        options = options || {};
        return buildTree(tokens, "", [], options.sectionTags || []);
      };
      Hogan.cache = {};
      Hogan.cacheKey = function(text, options) {
        return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join("||");
      };
      Hogan.compile = function(text, options) {
        options = options || {};
        var key = Hogan.cacheKey(text, options);
        var template = this.cache[key];
        if (template) {
          var partials = template.partials;
          for (var name in partials) {
            delete partials[name].instance;
          }
          return template;
        }
        template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
        return this.cache[key] = template;
      };
    })(typeof exports !== "undefined" ? exports : Hogan);
  }
});

// node_modules/.pnpm/hogan.js@../node_modules/hogan.js/lib/template.js
var require_template = __commonJS({
  "node_modules/.pnpm/hogan.js@../node_modules/hogan.js/lib/template.js"(exports) {
    init_polyfill_buffer();
    var Hogan = {};
    (function(Hogan) {
      Hogan.Template = function(codeObj, text, compiler, options) {
        codeObj = codeObj || {};
        this.r = codeObj.code || this.r;
        this.c = compiler;
        this.options = options || {};
        this.text = text || "";
        this.partials = codeObj.partials || {};
        this.subs = codeObj.subs || {};
        this.buf = "";
      };
      Hogan.Template.prototype = {
        // render: replaced by generated code.
        r: function(context, partials, indent) {
          return "";
        },
        // variable escaping
        v: hoganEscape,
        // triple stache
        t: coerceToString,
        render: function render(context, partials, indent) {
          return this.ri([context], partials || {}, indent);
        },
        // render internal -- a hook for overrides that catches partials too
        ri: function(context, partials, indent) {
          return this.r(context, partials, indent);
        },
        // ensurePartial
        ep: function(symbol, partials) {
          var partial = this.partials[symbol];
          var template = partials[partial.name];
          if (partial.instance && partial.base == template) {
            return partial.instance;
          }
          if (typeof template == "string") {
            if (!this.c) {
              throw new Error("No compiler available.");
            }
            template = this.c.compile(template, this.options);
          }
          if (!template) {
            return null;
          }
          this.partials[symbol].base = template;
          if (partial.subs) {
            if (!partials.stackText)
              partials.stackText = {};
            for (key in partial.subs) {
              if (!partials.stackText[key]) {
                partials.stackText[key] = this.activeSub !== void  && partials.stackText[this.activeSub] ? partials.stackText[this.activeSub] : this.text;
              }
            }
            template = createSpecializedPartial(
              template,
              partial.subs,
              partial.partials,
              this.stackSubs,
              this.stackPartials,
              partials.stackText
            );
          }
          this.partials[symbol].instance = template;
          return template;
        },
        // tries to find a partial in the current scope and render it
        rp: function(symbol, context, partials, indent) {
          var partial = this.ep(symbol, partials);
          if (!partial) {
            return "";
          }
          return partial.ri(context, partials, indent);
        },
        // render a section
        rs: function(context, partials, section) {
          var tail = context[context.length - ];
          if (!isArray(tail)) {
            section(context, partials, this);
            return;
          }
          for (var i = ; i < tail.length; i++) {
            context.push(tail[i]);
            section(context, partials, this);
            context.pop();
          }
        },
        // maybe start a section
        s: function(val, ctx, partials, inverted, start, end, tags) {
          var pass;
          if (isArray(val) && val.length === ) {
            return false;
          }
          if (typeof val == "function") {
            val = this.ms(val, ctx, partials, inverted, start, end, tags);
          }
          pass = !!val;
          if (!inverted && pass && ctx) {
            ctx.push(typeof val == "object" ? val : ctx[ctx.length - ]);
          }
          return pass;
        },
        // find values with dotted names
        d: function(key, ctx, partials, returnFound) {
          var found, names = key.split("."), val = this.f(names[], ctx, partials, returnFound), doModelGet = this.options.modelGet, cx = null;
          if (key === "." && isArray(ctx[ctx.length - ])) {
            val = ctx[ctx.length - ];
          } else {
            for (var i = ; i < names.length; i++) {
              found = findInScope(names[i], val, doModelGet);
              if (found !== void ) {
                cx = val;
                val = found;
              } else {
                val = "";
              }
            }
          }
          if (returnFound && !val) {
            return false;
          }
          if (!returnFound && typeof val == "function") {
            ctx.push(cx);
            val = this.mv(val, ctx, partials);
            ctx.pop();
          }
          return val;
        },
        // find values with normal names
        f: function(key, ctx, partials, returnFound) {
          var val = false, v = null, found = false, doModelGet = this.options.modelGet;
          for (var i = ctx.length - ; i >= ; i--) {
            v = ctx[i];
            val = findInScope(key, v, doModelGet);
            if (val !== void ) {
              found = true;
              break;
            }
          }
          if (!found) {
            return returnFound ? false : "";
          }
          if (!returnFound && typeof val == "function") {
            val = this.mv(val, ctx, partials);
          }
          return val;
        },
        // higher order templates
        ls: function(func, cx, partials, text, tags) {
          var oldTags = this.options.delimiters;
          this.options.delimiters = tags;
          this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
          this.options.delimiters = oldTags;
          return false;
        },
        // compile text
        ct: function(text, cx, partials) {
          if (this.options.disableLambda) {
            throw new Error("Lambda features disabled.");
          }
          return this.c.compile(text, this.options).render(cx, partials);
        },
        // template result buffering
        b: function(s) {
          this.buf += s;
        },
        fl: function() {
          var r = this.buf;
          this.buf = "";
          return r;
        },
        // method replace section
        ms: function(func, ctx, partials, inverted, start, end, tags) {
          var textSource, cx = ctx[ctx.length - ], result = func.call(cx);
          if (typeof result == "function") {
            if (inverted) {
              return true;
            } else {
              textSource = this.activeSub && this.subsText && this.subsText[this.activeSub] ? this.subsText[this.activeSub] : this.text;
              return this.ls(result, cx, partials, textSource.substring(start, end), tags);
            }
          }
          return result;
        },
        // method replace variable
        mv: function(func, ctx, partials) {
          var cx = ctx[ctx.length - ];
          var result = func.call(cx);
          if (typeof result == "function") {
            return this.ct(coerceToString(result.call(cx)), cx, partials);
          }
          return result;
        },
        sub: function(name, context, partials, indent) {
          var f = this.subs[name];
          if (f) {
            this.activeSub = name;
            f(context, partials, this, indent);
            this.activeSub = false;
          }
        }
      };
      function findInScope(key, scope, doModelGet) {
        var val;
        if (scope && typeof scope == "object") {
          if (scope[key] !== void ) {
            val = scope[key];
          } else if (doModelGet && scope.get && typeof scope.get == "function") {
            val = scope.get(key);
          }
        }
        return val;
      }
      function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
        function PartialTemplate() {
        }
        ;
        PartialTemplate.prototype = instance;
        function Substitutions() {
        }
        ;
        Substitutions.prototype = instance.subs;
        var key;
        var partial = new PartialTemplate();
        partial.subs = new Substitutions();
        partial.subsText = {};
        partial.buf = "";
        stackSubs = stackSubs || {};
        partial.stackSubs = stackSubs;
        partial.subsText = stackText;
        for (key in subs) {
          if (!stackSubs[key])
            stackSubs[key] = subs[key];
        }
        for (key in stackSubs) {
          partial.subs[key] = stackSubs[key];
        }
        stackPartials = stackPartials || {};
        partial.stackPartials = stackPartials;
        for (key in partials) {
          if (!stackPartials[key])
            stackPartials[key] = partials[key];
        }
        for (key in stackPartials) {
          partial.partials[key] = stackPartials[key];
        }
        return partial;
      }
      var rAmp = /&/g, rLt = /</g, rGt = />/g, rApos = /\'/g, rQuot = /\"/g, hChars = /[&<>\"\']/;
      function coerceToString(val) {
        return String(val === null || val === void  ? "" : val);
      }
      function hoganEscape(str) {
        str = coerceToString(str);
        return hChars.test(str) ? str.replace(rAmp, "&amp;").replace(rLt, "&lt;").replace(rGt, "&gt;").replace(rApos, "&;").replace(rQuot, "&quot;") : str;
      }
      var isArray = Array.isArray || function(a) {
        return Object.prototype.toString.call(a) === "[object Array]";
      };
    })(typeof exports !== "undefined" ? exports : Hogan);
  }
});

// node_modules/.pnpm/hogan.js@../node_modules/hogan.js/lib/hogan.js
var require_hogan = __commonJS({
  "node_modules/.pnpm/hogan.js@../node_modules/hogan.js/lib/hogan.js"(exports, module) {
    init_polyfill_buffer();
    var Hogan = require_compiler();
    Hogan.Template = require_template().Template;
    Hogan.template = Hogan.Template;
    module.exports = Hogan;
  }
});

// node_modules/.pnpm/feather-icons@../node_modules/feather-icons/dist/feather.js
var require_feather = __commonJS({
  "node_modules/.pnpm/feather-icons@../node_modules/feather-icons/dist/feather.js"(exports, module) {
    init_polyfill_buffer();
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else if (typeof exports === "object")
        exports["feather"] = factory();
      else
        root["feather"] = factory();
    })(typeof self !== "undefined" ? self : exports, function() {
      return (
        //
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module = installedModules[moduleId] = {
              //
              i: moduleId,
              //
              l: false,
              //
              exports: {}
              //
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.l = true;
            return module.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.d = function(exports, name, getter) {
            if (!__webpack_require__.o(exports, name)) {
              Object.defineProperty(exports, name, {
                //
                configurable: false,
                //
                enumerable: true,
                //
                get: getter
                //
              });
            }
          };
          __webpack_require__.r = function(exports) {
            Object.defineProperty(exports, "__esModule", { value: true });
          };
          __webpack_require__.n = function(module) {
            var getter = module && module.__esModule ? (
              //
              function getDefault() {
                return module["default"];
              }
            ) : (
              //
              function getModuleExports() {
                return module;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = );
        }({
          //
          "./dist/icons.json": (
            /!!\
              ! ./dist/icons.json !
              \/
            /! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, aperture, archive, arrow-down-circle, arrow-down-left, arrow-down-right, arrow-down, arrow-left-circle, arrow-left, arrow-right-circle, arrow-right, arrow-up-circle, arrow-up-left, arrow-up-right, arrow-up, at-sign, award, bar-chart-, bar-chart, battery-charging, battery, bell-off, bell, bluetooth, bold, book-open, book, bookmark, box, briefcase, calendar, camera-off, camera, cast, check-circle, check-square, check, chevron-down, chevron-left, chevron-right, chevron-up, chevrons-down, chevrons-left, chevrons-right, chevrons-up, chrome, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-off, cloud-rain, cloud-snow, cloud, code, codepen, codesandbox, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, divide-circle, divide-square, divide, dollar-sign, download-cloud, download, dribbble, droplet, edit-, edit-, edit, external-link, eye-off, eye, facebook, fast-forward, feather, figma, file-minus, file-plus, file-text, file, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, grid, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, info, instagram, italic, key, layers, layout, life-buoy, link-, link, linkedin, list, loader, lock, log-in, log-out, mail, map-pin, map, maximize-, maximize, meh, menu, message-circle, message-square, mic-off, mic, minimize-, minimize, minus-circle, minus-square, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation-, navigation, octagon, package, paperclip, pause-circle, pause, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, pie-chart, play-circle, play, plus-circle, plus-square, plus, pocket, power, printer, radio, refresh-ccw, refresh-cw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, server, settings, share-, share, shield-off, shield, shopping-bag, shopping-cart, shuffle, sidebar, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, square, star, stop-circle, sun, sunrise, sunset, table, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash-, trash, trello, trending-down, trending-up, triangle, truck, tv, twitch, twitter, type, umbrella, underline, unlock, upload-cloud, upload, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume-, volume-, volume-x, volume, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default /
            //
            function(module) {
              module.exports = { "activity": '<polyline points="           "></polyline>', "airplay": '<path d="M Ha    --Va     -ha      va    - h-"></path><polygon points="       "></polygon>', "alert-circle": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><line x="" y="" x="." y=""></line>', "alert-octagon": '<polygon points=".  .   .  . .  .   .  . . "></polygon><line x="" y="" x="" y=""></line><line x="" y="" x="." y=""></line>', "alert-triangle": '<path d="M. .L. a     . h.a     .-L. .a    -. z"></path><line x="" y="" x="" y=""></line><line x="" y="" x="." y=""></line>', "align-center": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "align-justify": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "align-left": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "align-right": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "anchor": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><path d="M Ha      h-"></path>', "aperture": '<circle cx="" cy="" r=""></circle><line x="." y="" x="." y="."></line><line x="." y="" x="." y=""></line><line x="." y="" x="." y="."></line><line x="." y="" x="." y="."></line><line x="." y="" x="." y=""></line><line x="." y="" x="." y="."></line>', "archive": '<polyline points="       "></polyline><rect x="" y="" width="" height=""></rect><line x="" y="" x="" y=""></line>', "arrow-down-circle": '<circle cx="" cy="" r=""></circle><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "arrow-down-left": '<line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "arrow-down-right": '<line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "arrow-down": '<line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "arrow-left-circle": '<circle cx="" cy="" r=""></circle><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "arrow-left": '<line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "arrow-right-circle": '<circle cx="" cy="" r=""></circle><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "arrow-right": '<line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "arrow-up-circle": '<circle cx="" cy="" r=""></circle><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "arrow-up-left": '<line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "arrow-up-right": '<line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "arrow-up": '<line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "at-sign": '<circle cx="" cy="" r=""></circle><path d="M va      v-a    -. ."></path>', "award": '<circle cx="" cy="" r=""></circle><polyline points=". .       . ."></polyline>', "bar-chart-": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "bar-chart": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "battery-charging": '<path d="M Ha    --Va     -h.M ha      va    - h-."></path><line x="" y="" x="" y=""></line><polyline points="       "></polyline>', "battery": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="" y=""></line>', "bell-off": '<path d="M. a    -. "></path><path d="M. A. .     "></path><path d="M. .A. .     c - - h"></path><path d="M a    -.-"></path><line x="" y="" x="" y=""></line>', "bell": '<path d="M A      c - - hs----"></path><path d="M. a    -. "></path>', "bluetooth": '<polyline points=". . . .     . . . ."></polyline>', "bold": '<path d="M ha           - Hz"></path><path d="M ha           - Hz"></path>', "book-open": '<path d="M ha      va    --Hz"></path><path d="M h-a    - va     -hz"></path>', "book": '<path d="M .A. .    . H"></path><path d="M. HvH.A. .     .v-A. .    . z"></path>', "bookmark": '<path d="M l--- Va     -ha      z"></path>', "box": '<path d="M Va    --.l--a    - l- A      va      .l a      l-A      z"></path><polyline points=". .  . . ."></polyline><line x="" y="." x="" y=""></line>', "briefcase": '<rect x="" y="" width="" height="" rx="" ry=""></rect><path d="M Va    --h-a    - v"></path>', "calendar": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "camera-off": '<line x="" y="" x="" y=""></line><path d="M Ha    --Va     -hm-hl ha      v.m-.-.a    -.-."></path>', "camera": '<path d="M a    - Ha    --Va     -hl-hl ha      z"></path><circle cx="" cy="" r=""></circle>', "cast": '<path d="M .A     . M .A     . M Va     -ha      va    - h-"></path><line x="" y="" x="." y=""></line>', "check-circle": '<path d="M .Va    -.-."></path><polyline points="   .  ."></polyline>', "check-square": '<polyline points="     "></polyline><path d="M va    - Ha    --Va     -h"></path>', "check": '<polyline points="     "></polyline>', "chevron-down": '<polyline points="     "></polyline>', "chevron-left": '<polyline points="     "></polyline>', "chevron-right": '<polyline points="     "></polyline>', "chevron-up": '<polyline points="     "></polyline>', "chevrons-down": '<polyline points="     "></polyline><polyline points="     "></polyline>', "chevrons-left": '<polyline points="     "></polyline><polyline points="     "></polyline>', "chevrons-right": '<polyline points="     "></polyline><polyline points="     "></polyline>', "chevrons-up": '<polyline points="     "></polyline><polyline points="     "></polyline>', "chrome": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><line x="." y="" x="" y=""></line><line x="." y="." x="." y=""></line><line x="." y="." x="." y=""></line>', "circle": '<circle cx="" cy="" r=""></circle>', "clipboard": '<path d="M ha      va    - Ha    --Va     -h"></path><rect x="" y="" width="" height="" rx="" ry=""></rect>', "clock": '<circle cx="" cy="" r=""></circle><polyline points="     "></polyline>', "cloud-drizzle": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><path d="M .A      h-.A      ."></path>', "cloud-lightning": '<path d="M .A      h-.a    -. "></path><polyline points="       "></polyline>', "cloud-off": '<path d="M. .A      h-.a    -.-M a      ha     .-."></path><line x="" y="" x="" y=""></line>', "cloud-rain": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><path d="M .A      h-.A      ."></path>', "cloud-snow": '<path d="M .A      h-.A      ."></path><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line>', "cloud": '<path d="M h-.A      ha     -z"></path>', "code": '<polyline points="     "></polyline><polyline points="     "></polyline>', "codepen": '<polygon points="   .  .    .  .  "></polygon><line x="" y="" x="" y="."></line><polyline points=" .  .  ."></polyline><polyline points=" .  .  ."></polyline><line x="" y="" x="" y="."></line>', "codesandbox": '<path d="M Va    --.l--a    - l- A      va      .l a      l-A      z"></path><polyline points=". .  . . ."></polyline><polyline points=". . . .  "></polyline><polyline points="  . . . ."></polyline><polyline points=". .  . . ."></polyline><line x="" y="." x="" y=""></line>', "coffee": '<path d="M ha      h-"></path><path d="M hva    - Ha    --Vz"></path><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "columns": '<path d="M ha      va    - h-m-Ha    - va      hm-v"></path>', "command": '<path d="M a    - va            -     --Ha    -              -Va    --     -        ha     -     --z"></path>', "compass": '<circle cx="" cy="" r=""></circle><polygon points=". . . . . . . . . ."></polygon>', "copy": '<rect x="" y="" width="" height="" rx="" ry=""></rect><path d="M Ha    --Va     -ha      v"></path>', "corner-down-left": '<polyline points="     "></polyline><path d="M va    - H"></path>', "corner-down-right": '<polyline points="     "></polyline><path d="M va      h"></path>', "corner-left-down": '<polyline points="     "></polyline><path d="M h-a    - v"></path>', "corner-left-up": '<polyline points="     "></polyline><path d="M h-a    --V"></path>', "corner-right-down": '<polyline points="     "></polyline><path d="M ha      v"></path>', "corner-right-up": '<polyline points="     "></polyline><path d="M ha     -V"></path>', "corner-up-left": '<polyline points="     "></polyline><path d="M v-a    --H"></path>', "corner-up-right": '<polyline points="     "></polyline><path d="M v-a     -h"></path>', "cpu": '<rect x="" y="" width="" height="" rx="" ry=""></rect><rect x="" y="" width="" height=""></rect><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "credit-card": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="" y=""></line>', "crop": '<path d="M. L a      h"></path><path d="M .L a      v"></path>', "crosshair": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "database": '<ellipse cx="" cy="" rx="" ry=""></ellipse><path d="M c .- - s--.--"></path><path d="M vc .    s-. -V"></path>', "delete": '<path d="M Hl-   ha     -Va    --z"></path><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "disc": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle>', "divide-circle": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><circle cx="" cy="" r=""></circle>', "divide-square": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "divide": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><circle cx="" cy="" r=""></circle>', "dollar-sign": '<line x="" y="" x="" y=""></line><path d="M H.a. .     ha. .     H"></path>', "download-cloud": '<polyline points="     "></polyline><line x="" y="" x="" y=""></line><path d="M. .A      h-.A      ."></path>', "download": '<path d="M va    - Ha    --v-"></path><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "dribbble": '<circle cx="" cy="" r=""></circle><path d="M. .c. . . . . .m.-.c-. .-. .-. .m. .c-.-.-.-.-. -..-. .-. ."></path>', "droplet": '<path d="M .l. .a    -. z"></path>', "edit-": '<path d="M a. .     L. .  l.-.L z"></path>', "edit-": '<path d="M h"></path><path d="M. .a. .     L l-  -L. .z"></path>', "edit": '<path d="M Ha    - va      ha     -v-"></path><path d="M. .a. .     L l-  - .-.z"></path>', "external-link": '<path d="M va    - Ha    --Va     -h"></path><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "eye-off": '<path d="M. .A. .     c- ----a. .    .-.M. .A. .     c     a. .   -. .m-.-.a    -.-."></path><line x="" y="" x="" y=""></line>', "eye": '<path d="M s- -    - - ----z"></path><circle cx="" cy="" r=""></circle>', "facebook": '<path d="M h-a    - vHvhvhv-hl-h-Va     -hz"></path>', "fast-forward": '<polygon points="       "></polygon><polygon points="       "></polygon>', "feather": '<path d="M. .a    -.-.L .Vh.z"></path><line x="" y="" x="" y=""></line><line x="." y="" x="" y=""></line>', "figma": '<path d="M .A. .    . HvH.A. .     .z"></path><path d="M h.a. .     HVz"></path><path d="M .a. .      . .   - z"></path><path d="M .A. .    . Hv.a. .   - z"></path><path d="M .A. .    . HvH.A. .     .z"></path>', "file-minus": '<path d="M Ha    - va      ha     -Vz"></path><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "file-plus": '<path d="M Ha    - va      ha     -Vz"></path><polyline points="     "></polyline><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "file-text": '<path d="M Ha    - va      ha     -Vz"></path><polyline points="     "></polyline><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "file": '<path d="M Ha    - va      ha     -Vz"></path><polyline points="     "></polyline>', "film": '<rect x="" y="" width="" height="" rx="." ry="."></rect><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "filter": '<polygon points="     .      .  "></polygon>', "flag": '<path d="M s- -     - -Vs- - ----- - z"></path><line x="" y="" x="" y=""></line>', "folder-minus": '<path d="M a    - Ha    --Va     -hl ha      z"></path><line x="" y="" x="" y=""></line>', "folder-plus": '<path d="M a    - Ha    --Va     -hl ha      z"></path><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "folder": '<path d="M a    - Ha    --Va     -hl ha      z"></path>', "framer": '<path d="M VhVHl h-m- l v-m- h"></path>', "frown": '<circle cx="" cy="" r=""></circle><path d="M s-.---- - "></path><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line>', "gift": '<polyline points="       "></polyline><rect x="" y="" width="" height=""></rect><line x="" y="" x="" y=""></line><path d="M H.a. .    -C     z"></path><path d="M h.a. .    -C     z"></path>', "git-branch": '<line x="" y="" x="" y=""></line><circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><path d="M a    - "></path>', "git-commit": '<circle cx="" cy="" r=""></circle><line x="." y="" x="" y=""></line><line x="." y="" x="." y=""></line>', "git-merge": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><path d="M Va      "></path>', "git-pull-request": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><path d="M ha      v"></path><line x="" y="" x="" y=""></line>', "github": '<path d="M c- .--.--m v-.a. .   -.-.c.-. .-. .-A. .     . . .    . S..  .a. .   - C.. .  . A. .     .a. .   -. .c . . . . A. .     .V"></path>', "gitlab": '<path d="M. .L . . .a..   -.-.l.-. .-.A..    . a..    .  ..    ..l. .h.l.-.A..    . a..    .  ..    ..l. .L .a..   -..z"></path>', "globe": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><path d="M a. .      . .   -  . .   -- . .    -z"></path>', "grid": '<rect x="" y="" width="" height=""></rect><rect x="" y="" width="" height=""></rect><rect x="" y="" width="" height=""></rect><rect x="" y="" width="" height=""></rect>', "hard-drive": '<line x="" y="" x="" y=""></line><path d="M. .L va      ha     -v-l-.-.A     . H.a    -. .z"></path><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line>', "hash": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "headphones": '<path d="M v-a      v"></path><path d="M a    - h-a    --v-a     -hzM a      ha     -v-a    --Hz"></path>', "heart": '<path d="M. .a. .   -. L .l-.-.a. .   -. .l. .L .l.-. .-.a. .    -.z"></path>', "help-circle": '<circle cx="" cy="" r=""></circle><path d="M. a     . c - - "></path><line x="" y="" x="." y=""></line>', "hexagon": '<path d="M Va    --.l--a    - l- A      va      .l a      l-A      z"></path>', "home": '<path d="M l-  va    - Ha    --z"></path><polyline points="       "></polyline>', "image": '<rect x="" y="" width="" height="" rx="" ry=""></rect><circle cx="." cy="." r="."></circle><polyline points="     "></polyline>', "inbox": '<polyline points="           "></polyline><path d="M. .L va      ha     -v-l-.-.A     . H.a    -. .z"></path>', "info": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><line x="" y="" x="." y=""></line>', "instagram": '<rect x="" y="" width="" height="" rx="" ry=""></rect><path d="M .A     .        .z"></path><line x="." y="." x="." y="."></line>', "italic": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "key": '<path d="M l- m-. .a. .   -. . . .    .-.zm L. .m l L l--m-. .L "></path>', "layers": '<polygon points="         "></polygon><polyline points="     "></polyline><polyline points="     "></polyline>', "layout": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "life-buoy": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><line x="." y="." x="." y="."></line><line x="." y="." x="." y="."></line><line x="." y="." x="." y="."></line><line x="." y="." x="." y="."></line><line x="." y="." x="." y="."></line>', "link-": '<path d="M ha           - h-m- Ha    --      -h"></path><line x="" y="" x="" y=""></line>', "link": '<path d="M a     ..l-a    -.-.l-. ."></path><path d="M a    -.-.l- a     . .l.-."></path>', "linkedin": '<path d="M a      vh-v-a    --     - vh-v-a     -z"></path><rect x="" y="" width="" height=""></rect><circle cx="" cy="" r=""></circle>', "list": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line>', "loader": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="." y="." x="." y="."></line><line x="." y="." x="." y="."></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="." y="." x="." y="."></line><line x="." y="." x="." y="."></line>', "lock": '<rect x="" y="" width="" height="" rx="" ry=""></rect><path d="M Va      v"></path>', "log-in": '<path d="M ha      va    - h-"></path><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "log-out": '<path d="M Ha    --Va     -h"></path><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "mail": '<path d="M hc.   .  vc .-. - Hc-. --.--Vc-..- -z"></path><polyline points=", , ,"></polyline>', "map-pin": '<path d="M c - - s----a      z"></path><circle cx="" cy="" r=""></circle>', "map": '<polygon points="                 "></polygon><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "maximize-": '<polyline points="     "></polyline><polyline points="     "></polyline><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "maximize": '<path d="M Ha    - vm Va    --h-m ha     -v-M va      h"></path>', "meh": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line>', "menu": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "message-circle": '<path d="M .a. .   -. . . .   -. . . .   -.-.L l.-.a. .   -.-. . .    .-. . .    .-.h.a. .     v.z"></path>', "message-square": '<path d="M a    - Hl- Va     -ha      z"></path>', "mic-off": '<line x="" y="" x="" y=""></line><path d="M va     . .M .Va    -.-."></path><path d="M .A      v-m va    -. ."></path><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "mic": '<path d="M a    - va      Va    --z"></path><path d="M va    - v-"></path><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "minimize-": '<polyline points="     "></polyline><polyline points="     "></polyline><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "minimize": '<path d="M va    - Hm h-a    --Vm v-a     -hM ha      v"></path>', "minus-circle": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line>', "minus-square": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="" y=""></line>', "minus": '<line x="" y="" x="" y=""></line>', "monitor": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "moon": '<path d="M .A     .        .z"></path>', "more-horizontal": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle>', "more-vertical": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle>', "mouse-pointer": '<path d="M l. . .-. .-.L z"></path><path d="M l "></path>', "move": '<polyline points="     "></polyline><polyline points="     "></polyline><polyline points="     "></polyline><polyline points="     "></polyline><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "music": '<path d="M Vl-v"></path><circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle>', "navigation-": '<polygon points="         "></polygon>', "navigation": '<polygon points="         "></polygon>', "octagon": '<polygon points=".  .   .  . .  .   .  . . "></polygon>', "package": '<line x="." y="." x="." y="."></line><path d="M Va    --.l--a    - l- A      va      .l a      l-A      z"></path><polyline points=". .  . . ."></polyline><line x="" y="." x="" y=""></line>', "paperclip": '<path d="M. .l-. .a    -.-.l.-.a     . .l-. .a    -.-.l.-."></path>', "pause-circle": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "pause": '<rect x="" y="" width="" height=""></rect><rect x="" y="" width="" height=""></rect>', "pen-tool": '<path d="M l-  - --z"></path><path d="M l-.-.L l. .L l-z"></path><path d="M l. ."></path><circle cx="" cy="" r=""></circle>', "percent": '<line x="" y="" x="" y=""></line><circle cx="." cy="." r="."></circle><circle cx="." cy="." r="."></circle>', "phone-call": '<path d="M. A      .M. A      .m- .va    -.  . .   -.-. . .   -- . .   -.-.A     . ha      . . .    . .     -. .L. .a      l.-.a     .-. . .    ..A      .z"></path>', "phone-forwarded": '<polyline points="     "></polyline><line x="" y="" x="" y=""></line><path d="M .va    -.  . .   -.-. . .   -- . .   -.-.A     . ha      . . .    . .     -. .L. .a      l.-.a     .-. . .    ..A      .z"></path>', "phone-incoming": '<polyline points="     "></polyline><line x="" y="" x="" y=""></line><path d="M .va    -.  . .   -.-. . .   -- . .   -.-.A     . ha      . . .    . .     -. .L. .a      l.-.a     .-. . .    ..A      .z"></path>', "phone-missed": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><path d="M .va    -.  . .   -.-. . .   -- . .   -.-.A     . ha      . . .    . .     -. .L. .a      l.-.a     .-. . .    ..A      .z"></path>', "phone-off": '<path d="M. .a     . .l.-.a     .-. . .    ..      . va    -.  . .   -.-. . .   -.-.m-.-.a. .   -.-.A     . ha      . . .    . .     -. .L. ."></path><line x="" y="" x="" y=""></line>', "phone-outgoing": '<polyline points="     "></polyline><line x="" y="" x="" y=""></line><path d="M .va    -.  . .   -.-. . .   -- . .   -.-.A     . ha      . . .    . .     -. .L. .a      l.-.a     .-. . .    ..A      .z"></path>', "phone": '<path d="M .va    -.  . .   -.-. . .   -- . .   -.-.A     . ha      . . .    . .     -. .L. .a      l.-.a     .-. . .    ..A      .z"></path>', "pie-chart": '<path d="M. .A      ."></path><path d="M A      vz"></path>', "play-circle": '<circle cx="" cy="" r=""></circle><polygon points="       "></polygon>', "play": '<polygon points="       "></polygon>', "plus-circle": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "plus-square": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "plus": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "pocket": '<path d="M ha      va    - A      Va     -z"></path><polyline points="     "></polyline>', "power": '<path d="M. .a    -. "></path><line x="" y="" x="" y=""></line>', "printer": '<polyline points="       "></polyline><path d="M Ha    --v-a     -ha      va    - h-"></path><rect x="" y="" width="" height=""></rect>', "radio": '<circle cx="" cy="" r=""></circle><path d="M. .a      .m-.-.a     -.m.-.a      .m-. a     -."></path>', "refresh-ccw": '<polyline points="     "></polyline><polyline points="     "></polyline><path d="M. A     . .L m l-. .A     . "></path>', "refresh-cw": '<polyline points="     "></polyline><polyline points="     "></polyline><path d="M. a     .-.L M l. .A     . "></path>', "repeat": '<polyline points="     "></polyline><path d="M Va     -h"></path><polyline points="     "></polyline><path d="M va    - H"></path>', "rewind": '<polygon points="       "></polygon><polygon points="       "></polygon>', "rotate-ccw": '<polyline points="     "></polyline><path d="M. a     .-.L "></path>', "rotate-cw": '<polyline points="     "></polyline><path d="M. a    -.-.L "></path>', "rss": '<path d="M a      "></path><path d="M a      "></path><circle cx="" cy="" r=""></circle>', "save": '<path d="M Ha    --Va     -hl va    - z"></path><polyline points="       "></polyline><polyline points="     "></polyline>', "scissors": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><line x="" y="" x="." y="."></line><line x="." y="." x="" y=""></line><line x="." y="." x="" y=""></line>', "search": '<circle cx="" cy="" r=""></circle><line x="" y="" x="." y="."></line>', "send": '<line x="" y="" x="" y=""></line><polygon points="         "></polygon>', "server": '<rect x="" y="" width="" height="" rx="" ry=""></rect><rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line>', "settings": '<circle cx="" cy="" r=""></circle><path d="M. a. .    . .l..a      .     -. l-.-.a. .   -.-. . .   - .Va    -      --v-.A. .     .a. .   -..l-..a    -.       -.l.-.a. .    .-. . .   -.-Ha    --      -h.A. .    . a. .   -.-.l-.-.a     -.      . l..a. .    ..Ha. .    -.Va     -       v.a. .     . . .    .-.l.-.a     .        .l-..a. .   -. .Va. .    . Ha           - h-.a. .   -. z"></path>', "share-": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><line x="." y="." x="." y="."></line><line x="." y="." x="." y="."></line>', "share": '<path d="M va      ha     -v-"></path><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "shield-off": '<path d="M. a. .    .-Vl---. ."></path><path d="M. .L vc     a. .    .-."></path><line x="" y="" x="" y=""></line>', "shield": '<path d="M s- -Vl--- vc     z"></path>', "shopping-bag": '<path d="M L va      ha     -Vl--z"></path><line x="" y="" x="" y=""></line><path d="M a    - "></path>', "shopping-cart": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><path d="M hl. .a      .h.a     -.L H"></path>', "shuffle": '<polyline points="     "></polyline><line x="" y="" x="" y=""></line><polyline points="     "></polyline><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "sidebar": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="" y=""></line>', "skip-back": '<polygon points="       "></polygon><line x="" y="" x="" y=""></line>', "skip-forward": '<polygon points="       "></polygon><line x="" y="" x="" y=""></line>', "slack": '<path d="M. c-. -.-.-.-.v-c-..-. .-.s.. . .vc .-. .-. .z"></path><path d="M. HV.c-..-. .-.s.. . .-. .-. .z"></path><path d="M. c.  .. . .vc .-. .-. .S .  .v-c-..-. .-.z"></path><path d="M. Hv.c .-. .-. .S .  . .  . z"></path><path d="M .c-..-. .-.hc.  .. . .s-. .-. .h-c-. -.-.-.-.z"></path><path d="M. Hv.c .. . . .s.-. .-.-.-.-.-.z"></path><path d="M .C . .  . h-C.   .  .S.  . hc.  .-. .-.z"></path><path d="M. HV.C . .  . S .  . .  . z"></path>', "slash": '<circle cx="" cy="" r=""></circle><line x="." y="." x="." y="."></line>', "sliders": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "smartphone": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="." y=""></line>', "smile": '<circle cx="" cy="" r=""></circle><path d="M s.    - -"></path><line x="" y="" x="." y=""></line><line x="" y="" x="." y=""></line>', "speaker": '<rect x="" y="" width="" height="" rx="" ry=""></rect><circle cx="" cy="" r=""></circle><line x="" y="" x="." y=""></line>', "square": '<rect x="" y="" width="" height="" rx="" ry=""></rect>', "star": '<polygon points="  . .  .  . . .  . . .  .  . . .  "></polygon>', "stop-circle": '<circle cx="" cy="" r=""></circle><rect x="" y="" width="" height=""></rect>', "sun": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="." y="." x="." y="."></line><line x="." y="." x="." y="."></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="." y="." x="." y="."></line><line x="." y="." x="." y="."></line>', "sunrise": '<path d="M a    - "></path><line x="" y="" x="" y=""></line><line x="." y="." x="." y="."></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="." y="." x="." y="."></line><line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "sunset": '<path d="M a    - "></path><line x="" y="" x="" y=""></line><line x="." y="." x="." y="."></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line><line x="." y="." x="." y="."></line><line x="" y="" x="" y=""></line><polyline points="     "></polyline>', "table": '<path d="M Ha    - vm-ha      vM vm ha     -VM Ha    --Vm h"></path>', "tablet": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="." y=""></line>', "tag": '<path d="M. .l-. .a    -. L Vhl. .a      .z"></path><line x="" y="" x="." y=""></line>', "target": '<circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle><circle cx="" cy="" r=""></circle>', "terminal": '<polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "thermometer": '<path d="M .V.a. .   - v.a. .     z"></path>', "thumbs-down": '<path d="M va      l-VH.a    - .l-. a      .zm-h.A. .     va. .   -. H"></path>', "thumbs-up": '<path d="M Va    --l- vh.a     -.l.-a    --.zM Ha    --v-a     -h"></path>', "toggle-left": '<rect x="" y="" width="" height="" rx="" ry=""></rect><circle cx="" cy="" r=""></circle>', "toggle-right": '<rect x="" y="" width="" height="" rx="" ry=""></rect><circle cx="" cy="" r=""></circle>', "tool": '<path d="M. .a      .l. .a     . l.-.a    -. .l-. .a. .   --l.-.a     .-.l-. .z"></path>', "trash-": '<polyline points="     "></polyline><path d="M va    - Ha    --Vm Va     -ha      v"></path><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "trash": '<polyline points="     "></polyline><path d="M va    - Ha    --Vm Va     -ha      v"></path>', "trello": '<rect x="" y="" width="" height="" rx="" ry=""></rect><rect x="" y="" width="" height=""></rect><rect x="" y="" width="" height=""></rect>', "trending-down": '<polyline points="  . . . .  "></polyline><polyline points="     "></polyline>', "trending-up": '<polyline points="  . . . .  "></polyline><polyline points="     "></polyline>', "triangle": '<path d="M. .L. a     . h.a     .-L. .a    -. z"></path>', "truck": '<rect x="" y="" width="" height=""></rect><polygon points="           "></polygon><circle cx="." cy="." r="."></circle><circle cx="." cy="." r="."></circle>', "tv": '<rect x="" y="" width="" height="" rx="" ry=""></rect><polyline points="     "></polyline>', "twitch": '<path d="M Hvhvl-hl-Vzm- Vm V"></path>', "twitter": '<path d="M a. .   -. . . .   -. vA. .     s-   a. .   - c    -.a. .   -.-.A. .     z"></path>', "type": '<polyline points="       "></polyline><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "umbrella": '<path d="M a. .   - zm- a    - v-"></path>', "underline": '<path d="M va            -V"></path><line x="" y="" x="" y=""></line>', "unlock": '<rect x="" y="" width="" height="" rx="" ry=""></rect><path d="M Va     .-"></path>', "upload-cloud": '<polyline points="     "></polyline><line x="" y="" x="" y=""></line><path d="M. .A      h-.A      ."></path><polyline points="     "></polyline>', "upload": '<path d="M va    - Ha    --v-"></path><polyline points="     "></polyline><line x="" y="" x="" y=""></line>', "user-check": '<path d="M v-a    --Ha    - v"></path><circle cx="." cy="" r=""></circle><polyline points="     "></polyline>', "user-minus": '<path d="M v-a    --Ha    - v"></path><circle cx="." cy="" r=""></circle><line x="" y="" x="" y=""></line>', "user-plus": '<path d="M v-a    --Ha    - v"></path><circle cx="." cy="" r=""></circle><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "user-x": '<path d="M v-a    --Ha    - v"></path><circle cx="." cy="" r=""></circle><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "user": '<path d="M v-a    --Ha    - v"></path><circle cx="" cy="" r=""></circle>', "users": '<path d="M v-a    --Ha    - v"></path><circle cx="" cy="" r=""></circle><path d="M v-a    --."></path><path d="M .a      ."></path>', "video-off": '<path d="M va    - Ha    --Va     -hm. Ha      v.l L v"></path><line x="" y="" x="" y=""></line>', "video": '<polygon points="       "></polygon><rect x="" y="" width="" height="" rx="" ry=""></rect>', "voicemail": '<circle cx="." cy="." r="."></circle><circle cx="." cy="." r="."></circle><line x="." y="" x="." y=""></line>', "volume-": '<polygon points="             "></polygon><path d="M. .a      ."></path>', "volume-": '<polygon points="             "></polygon><path d="M. .a      .M. .a      ."></path>', "volume-x": '<polygon points="             "></polygon><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "volume": '<polygon points="             "></polygon>', "watch": '<circle cx="" cy="" r=""></circle><polyline points="    . ."></polyline><path d="M. .l-. .a    - .H.a    --.l-.-.m.-.l.-.A     . h.a      .l. ."></path>', "wifi-off": '<line x="" y="" x="" y=""></line><path d="M. .A. .     ."></path><path d="M .a. .    .-."></path><path d="M. .A     . "></path><path d="M. a. .    .-."></path><path d="M. .a     . "></path><line x="" y="" x="." y=""></line>', "wifi": '<path d="M .a     . "></path><path d="M. a     . "></path><path d="M. .a     . "></path><line x="" y="" x="." y=""></line>', "wind": '<path d="M. .A      Hm. .A      Hm.-.A. .    . H"></path>', "x-circle": '<circle cx="" cy="" r=""></circle><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "x-octagon": '<polygon points=".  .   .  . .  .   .  . . "></polygon><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "x-square": '<rect x="" y="" width="" height="" rx="" ry=""></rect><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "x": '<line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "youtube": '<path d="M. .a. .   -.-C.     s-. -..a. .   -. A      .a     . .A. .    . c.. .. ..s.  .-.a. .    .-      .-.     -.-.z"></path><polygon points=". . . . . . . ."></polygon>', "zap-off": '<polyline points=". .   . ."></polyline><polyline points=". .   . "></polyline><polyline points="         "></polyline><line x="" y="" x="" y=""></line>', "zap": '<polygon points="             "></polygon>', "zoom-in": '<circle cx="" cy="" r=""></circle><line x="" y="" x="." y="."></line><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line>', "zoom-out": '<circle cx="" cy="" r=""></circle><line x="" y="" x="." y="."></line><line x="" y="" x="" y=""></line>' };
            }
          ),
          //
          "./node_modules/classnames/dedupe.js": (
            /!!\
              ! ./node_modules/classnames/dedupe.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
              (function() {
                "use strict";
                var classNames = function() {
                  function StorageObject() {
                  }
                  StorageObject.prototype = / @__PURE__ / Object.create(null);
                  function _parseArray(resultSet, array) {
                    var length = array.length;
                    for (var i = ; i < length; ++i) {
                      _parse(resultSet, array[i]);
                    }
                  }
                  var hasOwn = {}.hasOwnProperty;
                  function _parseNumber(resultSet, num) {
                    resultSet[num] = true;
                  }
                  function _parseObject(resultSet, object) {
                    for (var k in object) {
                      if (hasOwn.call(object, k)) {
                        resultSet[k] = !!object[k];
                      }
                    }
                  }
                  var SPACE = /\s+/;
                  function _parseString(resultSet, str) {
                    var array = str.split(SPACE);
                    var length = array.length;
                    for (var i = ; i < length; ++i) {
                      resultSet[array[i]] = true;
                    }
                  }
                  function _parse(resultSet, arg) {
                    if (!arg)
                      return;
                    var argType = typeof arg;
                    if (argType === "string") {
                      _parseString(resultSet, arg);
                    } else if (Array.isArray(arg)) {
                      _parseArray(resultSet, arg);
                    } else if (argType === "object") {
                      _parseObject(resultSet, arg);
                    } else if (argType === "number") {
                      _parseNumber(resultSet, arg);
                    }
                  }
                  function _classNames() {
                    var len = arguments.length;
                    var args = Array(len);
                    for (var i = ; i < len; i++) {
                      args[i] = arguments[i];
                    }
                    var classSet = new StorageObject();
                    _parseArray(classSet, args);
                    var list = [];
                    for (var k in classSet) {
                      if (classSet[k]) {
                        list.push(k);
                      }
                    }
                    return list.join(" ");
                  }
                  return _classNames;
                }();
                if (typeof module !== "undefined" && module.exports) {
                  module.exports = classNames;
                } else if (true) {
                  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return classNames;
                  }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void  && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {
                }
              })();
            }
          ),
          //
          "./node_modules/core-js/es/array/from.js": (
            /!!\
              ! ./node_modules/core-js/es/array/from.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              __webpack_require__(
                /! ../../modules/es.string.iterator /
                "./node_modules/core-js/modules/es.string.iterator.js"
              );
              __webpack_require__(
                /! ../../modules/es.array.from /
                "./node_modules/core-js/modules/es.array.from.js"
              );
              var path = __webpack_require__(
                /! ../../internals/path /
                "./node_modules/core-js/internals/path.js"
              );
              module.exports = path.Array.from;
            }
          ),
          //
          "./node_modules/core-js/internals/a-function.js": (
            /!!\
              ! ./node_modules/core-js/internals/a-function.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              module.exports = function(it) {
                if (typeof it != "function") {
                  throw TypeError(String(it) + " is not a function");
                }
                return it;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/an-object.js": (
            /!!\
              ! ./node_modules/core-js/internals/an-object.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var isObject = __webpack_require__(
                /! ../internals/is-object /
                "./node_modules/core-js/internals/is-object.js"
              );
              module.exports = function(it) {
                if (!isObject(it)) {
                  throw TypeError(String(it) + " is not an object");
                }
                return it;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/array-from.js": (
            /!!\
              ! ./node_modules/core-js/internals/array-from.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              var bind = __webpack_require__(
                /! ../internals/bind-context /
                "./node_modules/core-js/internals/bind-context.js"
              );
              var toObject = __webpack_require__(
                /! ../internals/to-object /
                "./node_modules/core-js/internals/to-object.js"
              );
              var callWithSafeIterationClosing = __webpack_require__(
                /! ../internals/call-with-safe-iteration-closing /
                "./node_modules/core-js/internals/call-with-safe-iteration-closing.js"
              );
              var isArrayIteratorMethod = __webpack_require__(
                /! ../internals/is-array-iterator-method /
                "./node_modules/core-js/internals/is-array-iterator-method.js"
              );
              var toLength = __webpack_require__(
                /! ../internals/to-length /
                "./node_modules/core-js/internals/to-length.js"
              );
              var createProperty = __webpack_require__(
                /! ../internals/create-property /
                "./node_modules/core-js/internals/create-property.js"
              );
              var getIteratorMethod = __webpack_require__(
                /! ../internals/get-iterator-method /
                "./node_modules/core-js/internals/get-iterator-method.js"
              );
              module.exports = function from(arrayLike) {
                var O = toObject(arrayLike);
                var C = typeof this == "function" ? this : Array;
                var argumentsLength = arguments.length;
                var mapfn = argumentsLength >  ? arguments[] : void ;
                var mapping = mapfn !== void ;
                var index = ;
                var iteratorMethod = getIteratorMethod(O);
                var length, result, step, iterator;
                if (mapping)
                  mapfn = bind(mapfn, argumentsLength >  ? arguments[] : void , );
                if (iteratorMethod != void  && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
                  iterator = iteratorMethod.call(O);
                  result = new C();
                  for (; !(step = iterator.next()).done; index++) {
                    createProperty(
                      result,
                      index,
                      mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value
                    );
                  }
                } else {
                  length = toLength(O.length);
                  result = new C(length);
                  for (; length > index; index++) {
                    createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
                  }
                }
                result.length = index;
                return result;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/array-includes.js": (
            /!!\
              ! ./node_modules/core-js/internals/array-includes.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var toIndexedObject = __webpack_require__(
                /! ../internals/to-indexed-object /
                "./node_modules/core-js/internals/to-indexed-object.js"
              );
              var toLength = __webpack_require__(
                /! ../internals/to-length /
                "./node_modules/core-js/internals/to-length.js"
              );
              var toAbsoluteIndex = __webpack_require__(
                /! ../internals/to-absolute-index /
                "./node_modules/core-js/internals/to-absolute-index.js"
              );
              module.exports = function(IS_INCLUDES) {
                return function($this, el, fromIndex) {
                  var O = toIndexedObject($this);
                  var length = toLength(O.length);
                  var index = toAbsoluteIndex(fromIndex, length);
                  var value;
                  if (IS_INCLUDES && el != el)
                    while (length > index) {
                      value = O[index++];
                      if (value != value)
                        return true;
                    }
                  else
                    for (; length > index; index++)
                      if (IS_INCLUDES || index in O) {
                        if (O[index] === el)
                          return IS_INCLUDES || index || ;
                      }
                  return !IS_INCLUDES && -;
                };
              };
            }
          ),
          //
          "./node_modules/core-js/internals/bind-context.js": (
            /!!\
              ! ./node_modules/core-js/internals/bind-context.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var aFunction = __webpack_require__(
                /! ../internals/a-function /
                "./node_modules/core-js/internals/a-function.js"
              );
              module.exports = function(fn, that, length) {
                aFunction(fn);
                if (that === void )
                  return fn;
                switch (length) {
                  case :
                    return function() {
                      return fn.call(that);
                    };
                  case :
                    return function(a) {
                      return fn.call(that, a);
                    };
                  case :
                    return function(a, b) {
                      return fn.call(that, a, b);
                    };
                  case :
                    return function(a, b, c) {
                      return fn.call(that, a, b, c);
                    };
                }
                return function() {
                  return fn.apply(that, arguments);
                };
              };
            }
          ),
          //
          "./node_modules/core-js/internals/call-with-safe-iteration-closing.js": (
            /!!\
              ! ./node_modules/core-js/internals/call-with-safe-iteration-closing.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var anObject = __webpack_require__(
                /! ../internals/an-object /
                "./node_modules/core-js/internals/an-object.js"
              );
              module.exports = function(iterator, fn, value, ENTRIES) {
                try {
                  return ENTRIES ? fn(anObject(value)[], value[]) : fn(value);
                } catch (error) {
                  var returnMethod = iterator["return"];
                  if (returnMethod !== void )
                    anObject(returnMethod.call(iterator));
                  throw error;
                }
              };
            }
          ),
          //
          "./node_modules/core-js/internals/check-correctness-of-iteration.js": (
            /!!\
              ! ./node_modules/core-js/internals/check-correctness-of-iteration.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var wellKnownSymbol = __webpack_require__(
                /! ../internals/well-known-symbol /
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var ITERATOR = wellKnownSymbol("iterator");
              var SAFE_CLOSING = false;
              try {
                var called = ;
                var iteratorWithReturn = {
                  next: function() {
                    return { done: !!called++ };
                  },
                  "return": function() {
                    SAFE_CLOSING = true;
                  }
                };
                iteratorWithReturn[ITERATOR] = function() {
                  return this;
                };
                Array.from(iteratorWithReturn, function() {
                  throw ;
                });
              } catch (error) {
              }
              module.exports = function(exec, SKIP_CLOSING) {
                if (!SKIP_CLOSING && !SAFE_CLOSING)
                  return false;
                var ITERATION_SUPPORT = false;
                try {
                  var object = {};
                  object[ITERATOR] = function() {
                    return {
                      next: function() {
                        return { done: ITERATION_SUPPORT = true };
                      }
                    };
                  };
                  exec(object);
                } catch (error) {
                }
                return ITERATION_SUPPORT;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/classof-raw.js": (
            /!!\
              ! ./node_modules/core-js/internals/classof-raw.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              var toString = {}.toString;
              module.exports = function(it) {
                return toString.call(it).slice(, -);
              };
            }
          ),
          //
          "./node_modules/core-js/internals/classof.js": (
            /!!\
              ! ./node_modules/core-js/internals/classof.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var classofRaw = __webpack_require__(
                /! ../internals/classof-raw /
                "./node_modules/core-js/internals/classof-raw.js"
              );
              var wellKnownSymbol = __webpack_require__(
                /! ../internals/well-known-symbol /
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              var CORRECT_ARGUMENTS = classofRaw(function() {
                return arguments;
              }()) == "Arguments";
              var tryGet = function(it, key) {
                try {
                  return it[key];
                } catch (error) {
                }
              };
              module.exports = function(it) {
                var O, tag, result;
                return it === void  ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : result;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/copy-constructor-properties.js": (
            /!!\
              ! ./node_modules/core-js/internals/copy-constructor-properties.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var has = __webpack_require__(
                /! ../internals/has /
                "./node_modules/core-js/internals/has.js"
              );
              var ownKeys = __webpack_require__(
                /! ../internals/own-keys /
                "./node_modules/core-js/internals/own-keys.js"
              );
              var getOwnPropertyDescriptorModule = __webpack_require__(
                /! ../internals/object-get-own-property-descriptor /
                "./node_modules/core-js/internals/object-get-own-property-descriptor.js"
              );
              var definePropertyModule = __webpack_require__(
                /! ../internals/object-define-property /
                "./node_modules/core-js/internals/object-define-property.js"
              );
              module.exports = function(target, source) {
                var keys = ownKeys(source);
                var defineProperty = definePropertyModule.f;
                var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
                for (var i = ; i < keys.length; i++) {
                  var key = keys[i];
                  if (!has(target, key))
                    defineProperty(target, key, getOwnPropertyDescriptor(source, key));
                }
              };
            }
          ),
          //
          "./node_modules/core-js/internals/correct-prototype-getter.js": (
            /!!\
              ! ./node_modules/core-js/internals/correct-prototype-getter.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var fails = __webpack_require__(
                /! ../internals/fails /
                "./node_modules/core-js/internals/fails.js"
              );
              module.exports = !fails(function() {
                function F() {
                }
                F.prototype.constructor = null;
                return Object.getPrototypeOf(new F()) !== F.prototype;
              });
            }
          ),
          //
          "./node_modules/core-js/internals/create-iterator-constructor.js": (
            /!!\
              ! ./node_modules/core-js/internals/create-iterator-constructor.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              var IteratorPrototype = __webpack_require__(
                /! ../internals/iterators-core /
                "./node_modules/core-js/internals/iterators-core.js"
              ).IteratorPrototype;
              var create = __webpack_require__(
                /! ../internals/object-create /
                "./node_modules/core-js/internals/object-create.js"
              );
              var createPropertyDescriptor = __webpack_require__(
                /! ../internals/create-property-descriptor /
                "./node_modules/core-js/internals/create-property-descriptor.js"
              );
              var setToStringTag = __webpack_require__(
                /! ../internals/set-to-string-tag /
                "./node_modules/core-js/internals/set-to-string-tag.js"
              );
              var Iterators = __webpack_require__(
                /! ../internals/iterators /
                "./node_modules/core-js/internals/iterators.js"
              );
              var returnThis = function() {
                return this;
              };
              module.exports = function(IteratorConstructor, NAME, next) {
                var TO_STRING_TAG = NAME + " Iterator";
                IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(, next) });
                setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
                Iterators[TO_STRING_TAG] = returnThis;
                return IteratorConstructor;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/create-property-descriptor.js": (
            /!!\
              ! ./node_modules/core-js/internals/create-property-descriptor.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              module.exports = function(bitmap, value) {
                return {
                  enumerable: !(bitmap & ),
                  configurable: !(bitmap & ),
                  writable: !(bitmap & ),
                  value
                };
              };
            }
          ),
          //
          "./node_modules/core-js/internals/create-property.js": (
            /!!\
              ! ./node_modules/core-js/internals/create-property.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              var toPrimitive = __webpack_require__(
                /! ../internals/to-primitive /
                "./node_modules/core-js/internals/to-primitive.js"
              );
              var definePropertyModule = __webpack_require__(
                /! ../internals/object-define-property /
                "./node_modules/core-js/internals/object-define-property.js"
              );
              var createPropertyDescriptor = __webpack_require__(
                /! ../internals/create-property-descriptor /
                "./node_modules/core-js/internals/create-property-descriptor.js"
              );
              module.exports = function(object, key, value) {
                var propertyKey = toPrimitive(key);
                if (propertyKey in object)
                  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(, value));
                else
                  object[propertyKey] = value;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/define-iterator.js": (
            /!!\
              ! ./node_modules/core-js/internals/define-iterator.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              var $ = __webpack_require__(
                /! ../internals/export /
                "./node_modules/core-js/internals/export.js"
              );
              var createIteratorConstructor = __webpack_require__(
                /! ../internals/create-iterator-constructor /
                "./node_modules/core-js/internals/create-iterator-constructor.js"
              );
              var getPrototypeOf = __webpack_require__(
                /! ../internals/object-get-prototype-of /
                "./node_modules/core-js/internals/object-get-prototype-of.js"
              );
              var setPrototypeOf = __webpack_require__(
                /! ../internals/object-set-prototype-of /
                "./node_modules/core-js/internals/object-set-prototype-of.js"
              );
              var setToStringTag = __webpack_require__(
                /! ../internals/set-to-string-tag /
                "./node_modules/core-js/internals/set-to-string-tag.js"
              );
              var hide = __webpack_require__(
                /! ../internals/hide /
                "./node_modules/core-js/internals/hide.js"
              );
              var redefine = __webpack_require__(
                /! ../internals/redefine /
                "./node_modules/core-js/internals/redefine.js"
              );
              var wellKnownSymbol = __webpack_require__(
                /! ../internals/well-known-symbol /
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var IS_PURE = __webpack_require__(
                /! ../internals/is-pure /
                "./node_modules/core-js/internals/is-pure.js"
              );
              var Iterators = __webpack_require__(
                /! ../internals/iterators /
                "./node_modules/core-js/internals/iterators.js"
              );
              var IteratorsCore = __webpack_require__(
                /! ../internals/iterators-core /
                "./node_modules/core-js/internals/iterators-core.js"
              );
              var IteratorPrototype = IteratorsCore.IteratorPrototype;
              var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
              var ITERATOR = wellKnownSymbol("iterator");
              var KEYS = "keys";
              var VALUES = "values";
              var ENTRIES = "entries";
              var returnThis = function() {
                return this;
              };
              module.exports = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
                createIteratorConstructor(IteratorConstructor, NAME, next);
                var getIterationMethod = function(KIND) {
                  if (KIND === DEFAULT && defaultIterator)
                    return defaultIterator;
                  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                    return IterablePrototype[KIND];
                  switch (KIND) {
                    case KEYS:
                      return function keys() {
                        return new IteratorConstructor(this, KIND);
                      };
                    case VALUES:
                      return function values() {
                        return new IteratorConstructor(this, KIND);
                      };
                    case ENTRIES:
                      return function entries() {
                        return new IteratorConstructor(this, KIND);
                      };
                  }
                  return function() {
                    return new IteratorConstructor(this);
                  };
                };
                var TO_STRING_TAG = NAME + " Iterator";
                var INCORRECT_VALUES_NAME = false;
                var IterablePrototype = Iterable.prototype;
                var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
                var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
                var anyNativeIterator = NAME == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
                var CurrentIteratorPrototype, methods, KEY;
                if (anyNativeIterator) {
                  CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
                  if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                    if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                      if (setPrototypeOf) {
                        setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                      } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                        hide(CurrentIteratorPrototype, ITERATOR, returnThis);
                      }
                    }
                    setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                    if (IS_PURE)
                      Iterators[TO_STRING_TAG] = returnThis;
                  }
                }
                if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                  INCORRECT_VALUES_NAME = true;
                  defaultIterator = function values() {
                    return nativeIterator.call(this);
                  };
                }
                if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                  hide(IterablePrototype, ITERATOR, defaultIterator);
                }
                Iterators[NAME] = defaultIterator;
                if (DEFAULT) {
                  methods = {
                    values: getIterationMethod(VALUES),
                    keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                    entries: getIterationMethod(ENTRIES)
                  };
                  if (FORCED)
                    for (KEY in methods) {
                      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                        redefine(IterablePrototype, KEY, methods[KEY]);
                      }
                    }
                  else
                    $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
                }
                return methods;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/descriptors.js": (
            /!!\
              ! ./node_modules/core-js/internals/descriptors.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var fails = __webpack_require__(
                /! ../internals/fails /
                "./node_modules/core-js/internals/fails.js"
              );
              module.exports = !fails(function() {
                return Object.defineProperty({}, "a", { get: function() {
                  return ;
                } }).a != ;
              });
            }
          ),
          //
          "./node_modules/core-js/internals/document-create-element.js": (
            /!!\
              ! ./node_modules/core-js/internals/document-create-element.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var global = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
              var isObject = __webpack_require__(
                /! ../internals/is-object /
                "./node_modules/core-js/internals/is-object.js"
              );
              var document = global.document;
              var exist = isObject(document) && isObject(document.createElement);
              module.exports = function(it) {
                return exist ? document.createElement(it) : {};
              };
            }
          ),
          //
          "./node_modules/core-js/internals/enum-bug-keys.js": (
            /!!\
              ! ./node_modules/core-js/internals/enum-bug-keys.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              module.exports = [
                "constructor",
                "hasOwnProperty",
                "isPrototypeOf",
                "propertyIsEnumerable",
                "toLocaleString",
                "toString",
                "valueOf"
              ];
            }
          ),
          //
          "./node_modules/core-js/internals/export.js": (
            /!!\
              ! ./node_modules/core-js/internals/export.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var global = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
              var getOwnPropertyDescriptor = __webpack_require__(
                /! ../internals/object-get-own-property-descriptor /
                "./node_modules/core-js/internals/object-get-own-property-descriptor.js"
              ).f;
              var hide = __webpack_require__(
                /! ../internals/hide /
                "./node_modules/core-js/internals/hide.js"
              );
              var redefine = __webpack_require__(
                /! ../internals/redefine /
                "./node_modules/core-js/internals/redefine.js"
              );
              var setGlobal = __webpack_require__(
                /! ../internals/set-global /
                "./node_modules/core-js/internals/set-global.js"
              );
              var copyConstructorProperties = __webpack_require__(
                /! ../internals/copy-constructor-properties /
                "./node_modules/core-js/internals/copy-constructor-properties.js"
              );
              var isForced = __webpack_require__(
                /! ../internals/is-forced /
                "./node_modules/core-js/internals/is-forced.js"
              );
              module.exports = function(options, source) {
                var TARGET = options.target;
                var GLOBAL = options.global;
                var STATIC = options.stat;
                var FORCED, target, key, targetProperty, sourceProperty, descriptor;
                if (GLOBAL) {
                  target = global;
                } else if (STATIC) {
                  target = global[TARGET] || setGlobal(TARGET, {});
                } else {
                  target = (global[TARGET] || {}).prototype;
                }
                if (target)
                  for (key in source) {
                    sourceProperty = source[key];
                    if (options.noTargetGet) {
                      descriptor = getOwnPropertyDescriptor(target, key);
                      targetProperty = descriptor && descriptor.value;
                    } else
                      targetProperty = target[key];
                    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "") + key, options.forced);
                    if (!FORCED && targetProperty !== void ) {
                      if (typeof sourceProperty === typeof targetProperty)
                        continue;
                      copyConstructorProperties(sourceProperty, targetProperty);
                    }
                    if (options.sham || targetProperty && targetProperty.sham) {
                      hide(sourceProperty, "sham", true);
                    }
                    redefine(target, key, sourceProperty, options);
                  }
              };
            }
          ),
          //
          "./node_modules/core-js/internals/fails.js": (
            /!!\
              ! ./node_modules/core-js/internals/fails.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              module.exports = function(exec) {
                try {
                  return !!exec();
                } catch (error) {
                  return true;
                }
              };
            }
          ),
          //
          "./node_modules/core-js/internals/function-to-string.js": (
            /!!\
              ! ./node_modules/core-js/internals/function-to-string.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var shared = __webpack_require__(
                /! ../internals/shared /
                "./node_modules/core-js/internals/shared.js"
              );
              module.exports = shared("native-function-to-string", Function.toString);
            }
          ),
          //
          "./node_modules/core-js/internals/get-iterator-method.js": (
            /!!\
              ! ./node_modules/core-js/internals/get-iterator-method.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var classof = __webpack_require__(
                /! ../internals/classof /
                "./node_modules/core-js/internals/classof.js"
              );
              var Iterators = __webpack_require__(
                /! ../internals/iterators /
                "./node_modules/core-js/internals/iterators.js"
              );
              var wellKnownSymbol = __webpack_require__(
                /! ../internals/well-known-symbol /
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var ITERATOR = wellKnownSymbol("iterator");
              module.exports = function(it) {
                if (it != void )
                  return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
              };
            }
          ),
          //
          "./node_modules/core-js/internals/global.js": (
            /!!\
              ! ./node_modules/core-js/internals/global.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              (function(global) {
                var O = "object";
                var check = function(it) {
                  return it && it.Math == Math && it;
                };
                module.exports = // eslint-disable-next-line no-undef
                check(typeof globalThis == O && globalThis) || check(typeof window == O && window) || check(typeof self == O && self) || check(typeof global == O && global) || // eslint-disable-next-line no-new-func
                Function("return this")();
              }).call(this, __webpack_require__(
                /! ./../../webpack/buildin/global.js /
                "./node_modules/webpack/buildin/global.js"
              ));
            }
          ),
          //
          "./node_modules/core-js/internals/has.js": (
            /!!\
              ! ./node_modules/core-js/internals/has.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              var hasOwnProperty = {}.hasOwnProperty;
              module.exports = function(it, key) {
                return hasOwnProperty.call(it, key);
              };
            }
          ),
          //
          "./node_modules/core-js/internals/hidden-keys.js": (
            /!!\
              ! ./node_modules/core-js/internals/hidden-keys.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              module.exports = {};
            }
          ),
          //
          "./node_modules/core-js/internals/hide.js": (
            /!!\
              ! ./node_modules/core-js/internals/hide.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var DESCRIPTORS = __webpack_require__(
                /! ../internals/descriptors /
                "./node_modules/core-js/internals/descriptors.js"
              );
              var definePropertyModule = __webpack_require__(
                /! ../internals/object-define-property /
                "./node_modules/core-js/internals/object-define-property.js"
              );
              var createPropertyDescriptor = __webpack_require__(
                /! ../internals/create-property-descriptor /
                "./node_modules/core-js/internals/create-property-descriptor.js"
              );
              module.exports = DESCRIPTORS ? function(object, key, value) {
                return definePropertyModule.f(object, key, createPropertyDescriptor(, value));
              } : function(object, key, value) {
                object[key] = value;
                return object;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/html.js": (
            /!!\
              ! ./node_modules/core-js/internals/html.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var global = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
              var document = global.document;
              module.exports = document && document.documentElement;
            }
          ),
          //
          "./node_modules/core-js/internals/ie-dom-define.js": (
            /!!\
              ! ./node_modules/core-js/internals/ie-dom-define.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var DESCRIPTORS = __webpack_require__(
                /! ../internals/descriptors /
                "./node_modules/core-js/internals/descriptors.js"
              );
              var fails = __webpack_require__(
                /! ../internals/fails /
                "./node_modules/core-js/internals/fails.js"
              );
              var createElement = __webpack_require__(
                /! ../internals/document-create-element /
                "./node_modules/core-js/internals/document-create-element.js"
              );
              module.exports = !DESCRIPTORS && !fails(function() {
                return Object.defineProperty(createElement("div"), "a", {
                  get: function() {
                    return ;
                  }
                }).a != ;
              });
            }
          ),
          //
          "./node_modules/core-js/internals/indexed-object.js": (
            /!!\
              ! ./node_modules/core-js/internals/indexed-object.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var fails = __webpack_require__(
                /! ../internals/fails /
                "./node_modules/core-js/internals/fails.js"
              );
              var classof = __webpack_require__(
                /! ../internals/classof-raw /
                "./node_modules/core-js/internals/classof-raw.js"
              );
              var split = "".split;
              module.exports = fails(function() {
                return !Object("z").propertyIsEnumerable();
              }) ? function(it) {
                return classof(it) == "String" ? split.call(it, "") : Object(it);
              } : Object;
            }
          ),
          //
          "./node_modules/core-js/internals/internal-state.js": (
            /!!\
              ! ./node_modules/core-js/internals/internal-state.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var NATIVE_WEAK_MAP = __webpack_require__(
                /! ../internals/native-weak-map /
                "./node_modules/core-js/internals/native-weak-map.js"
              );
              var global = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
              var isObject = __webpack_require__(
                /! ../internals/is-object /
                "./node_modules/core-js/internals/is-object.js"
              );
              var hide = __webpack_require__(
                /! ../internals/hide /
                "./node_modules/core-js/internals/hide.js"
              );
              var objectHas = __webpack_require__(
                /! ../internals/has /
                "./node_modules/core-js/internals/has.js"
              );
              var sharedKey = __webpack_require__(
                /! ../internals/shared-key /
                "./node_modules/core-js/internals/shared-key.js"
              );
              var hiddenKeys = __webpack_require__(
                /! ../internals/hidden-keys /
                "./node_modules/core-js/internals/hidden-keys.js"
              );
              var WeakMap = global.WeakMap;
              var set, get, has;
              var enforce = function(it) {
                return has(it) ? get(it) : set(it, {});
              };
              var getterFor = function(TYPE) {
                return function(it) {
                  var state;
                  if (!isObject(it) || (state = get(it)).type !== TYPE) {
                    throw TypeError("Incompatible receiver, " + TYPE + " required");
                  }
                  return state;
                };
              };
              if (NATIVE_WEAK_MAP) {
                var store = new WeakMap();
                var wmget = store.get;
                var wmhas = store.has;
                var wmset = store.set;
                set = function(it, metadata) {
                  wmset.call(store, it, metadata);
                  return metadata;
                };
                get = function(it) {
                  return wmget.call(store, it) || {};
                };
                has = function(it) {
                  return wmhas.call(store, it);
                };
              } else {
                var STATE = sharedKey("state");
                hiddenKeys[STATE] = true;
                set = function(it, metadata) {
                  hide(it, STATE, metadata);
                  return metadata;
                };
                get = function(it) {
                  return objectHas(it, STATE) ? it[STATE] : {};
                };
                has = function(it) {
                  return objectHas(it, STATE);
                };
              }
              module.exports = {
                set,
                get,
                has,
                enforce,
                getterFor
              };
            }
          ),
          //
          "./node_modules/core-js/internals/is-array-iterator-method.js": (
            /!!\
              ! ./node_modules/core-js/internals/is-array-iterator-method.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var wellKnownSymbol = __webpack_require__(
                /! ../internals/well-known-symbol /
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var Iterators = __webpack_require__(
                /! ../internals/iterators /
                "./node_modules/core-js/internals/iterators.js"
              );
              var ITERATOR = wellKnownSymbol("iterator");
              var ArrayPrototype = Array.prototype;
              module.exports = function(it) {
                return it !== void  && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
              };
            }
          ),
          //
          "./node_modules/core-js/internals/is-forced.js": (
            /!!\
              ! ./node_modules/core-js/internals/is-forced.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var fails = __webpack_require__(
                /! ../internals/fails /
                "./node_modules/core-js/internals/fails.js"
              );
              var replacement = /|\.prototype\./;
              var isForced = function(feature, detection) {
                var value = data[normalize(feature)];
                return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
              };
              var normalize = isForced.normalize = function(string) {
                return String(string).replace(replacement, ".").toLowerCase();
              };
              var data = isForced.data = {};
              var NATIVE = isForced.NATIVE = "N";
              var POLYFILL = isForced.POLYFILL = "P";
              module.exports = isForced;
            }
          ),
          //
          "./node_modules/core-js/internals/is-object.js": (
            /!!\
              ! ./node_modules/core-js/internals/is-object.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              module.exports = function(it) {
                return typeof it === "object" ? it !== null : typeof it === "function";
              };
            }
          ),
          //
          "./node_modules/core-js/internals/is-pure.js": (
            /!!\
              ! ./node_modules/core-js/internals/is-pure.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              module.exports = false;
            }
          ),
          //
          "./node_modules/core-js/internals/iterators-core.js": (
            /!!\
              ! ./node_modules/core-js/internals/iterators-core.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              var getPrototypeOf = __webpack_require__(
                /! ../internals/object-get-prototype-of /
                "./node_modules/core-js/internals/object-get-prototype-of.js"
              );
              var hide = __webpack_require__(
                /! ../internals/hide /
                "./node_modules/core-js/internals/hide.js"
              );
              var has = __webpack_require__(
                /! ../internals/has /
                "./node_modules/core-js/internals/has.js"
              );
              var wellKnownSymbol = __webpack_require__(
                /! ../internals/well-known-symbol /
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var IS_PURE = __webpack_require__(
                /! ../internals/is-pure /
                "./node_modules/core-js/internals/is-pure.js"
              );
              var ITERATOR = wellKnownSymbol("iterator");
              var BUGGY_SAFARI_ITERATORS = false;
              var returnThis = function() {
                return this;
              };
              var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
              if ([].keys) {
                arrayIterator = [].keys();
                if (!("next" in arrayIterator))
                  BUGGY_SAFARI_ITERATORS = true;
                else {
                  PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
                  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                    IteratorPrototype = PrototypeOfArrayIteratorPrototype;
                }
              }
              if (IteratorPrototype == void )
                IteratorPrototype = {};
              if (!IS_PURE && !has(IteratorPrototype, ITERATOR))
                hide(IteratorPrototype, ITERATOR, returnThis);
              module.exports = {
                IteratorPrototype,
                BUGGY_SAFARI_ITERATORS
              };
            }
          ),
          //
          "./node_modules/core-js/internals/iterators.js": (
            /!!\
              ! ./node_modules/core-js/internals/iterators.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              module.exports = {};
            }
          ),
          //
          "./node_modules/core-js/internals/native-symbol.js": (
            /!!\
              ! ./node_modules/core-js/internals/native-symbol.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var fails = __webpack_require__(
                /! ../internals/fails /
                "./node_modules/core-js/internals/fails.js"
              );
              module.exports = !!Object.getOwnPropertySymbols && !fails(function() {
                return !String(Symbol());
              });
            }
          ),
          //
          "./node_modules/core-js/internals/native-weak-map.js": (
            /!!\
              ! ./node_modules/core-js/internals/native-weak-map.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var global = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
              var nativeFunctionToString = __webpack_require__(
                /! ../internals/function-to-string /
                "./node_modules/core-js/internals/function-to-string.js"
              );
              var WeakMap = global.WeakMap;
              module.exports = typeof WeakMap === "function" && /native code/.test(nativeFunctionToString.call(WeakMap));
            }
          ),
          //
          "./node_modules/core-js/internals/object-create.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-create.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var anObject = __webpack_require__(
                /! ../internals/an-object /
                "./node_modules/core-js/internals/an-object.js"
              );
              var defineProperties = __webpack_require__(
                /! ../internals/object-define-properties /
                "./node_modules/core-js/internals/object-define-properties.js"
              );
              var enumBugKeys = __webpack_require__(
                /! ../internals/enum-bug-keys /
                "./node_modules/core-js/internals/enum-bug-keys.js"
              );
              var hiddenKeys = __webpack_require__(
                /! ../internals/hidden-keys /
                "./node_modules/core-js/internals/hidden-keys.js"
              );
              var html = __webpack_require__(
                /! ../internals/html /
                "./node_modules/core-js/internals/html.js"
              );
              var documentCreateElement = __webpack_require__(
                /! ../internals/document-create-element /
                "./node_modules/core-js/internals/document-create-element.js"
              );
              var sharedKey = __webpack_require__(
                /! ../internals/shared-key /
                "./node_modules/core-js/internals/shared-key.js"
              );
              var IE_PROTO = sharedKey("IE_PROTO");
              var PROTOTYPE = "prototype";
              var Empty = function() {
              };
              var createDict = function() {
                var iframe = documentCreateElement("iframe");
                var length = enumBugKeys.length;
                var lt = "<";
                var script = "script";
                var gt = ">";
                var js = "java" + script + ":";
                var iframeDocument;
                iframe.style.display = "none";
                html.appendChild(iframe);
                iframe.src = String(js);
                iframeDocument = iframe.contentWindow.document;
                iframeDocument.open();
                iframeDocument.write(lt + script + gt + "document.F=Object" + lt + "/" + script + gt);
                iframeDocument.close();
                createDict = iframeDocument.F;
                while (length--)
                  delete createDict[PROTOTYPE][enumBugKeys[length]];
                return createDict();
              };
              module.exports = Object.create || function create(O, Properties) {
                var result;
                if (O !== null) {
                  Empty[PROTOTYPE] = anObject(O);
                  result = new Empty();
                  Empty[PROTOTYPE] = null;
                  result[IE_PROTO] = O;
                } else
                  result = createDict();
                return Properties === void  ? result : defineProperties(result, Properties);
              };
              hiddenKeys[IE_PROTO] = true;
            }
          ),
          //
          "./node_modules/core-js/internals/object-define-properties.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-define-properties.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var DESCRIPTORS = __webpack_require__(
                /! ../internals/descriptors /
                "./node_modules/core-js/internals/descriptors.js"
              );
              var definePropertyModule = __webpack_require__(
                /! ../internals/object-define-property /
                "./node_modules/core-js/internals/object-define-property.js"
              );
              var anObject = __webpack_require__(
                /! ../internals/an-object /
                "./node_modules/core-js/internals/an-object.js"
              );
              var objectKeys = __webpack_require__(
                /! ../internals/object-keys /
                "./node_modules/core-js/internals/object-keys.js"
              );
              module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
                anObject(O);
                var keys = objectKeys(Properties);
                var length = keys.length;
                var i = ;
                var key;
                while (length > i)
                  definePropertyModule.f(O, key = keys[i++], Properties[key]);
                return O;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/object-define-property.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-define-property.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var DESCRIPTORS = __webpack_require__(
                /! ../internals/descriptors /
                "./node_modules/core-js/internals/descriptors.js"
              );
              var IE_DOM_DEFINE = __webpack_require__(
                /! ../internals/ie-dom-define /
                "./node_modules/core-js/internals/ie-dom-define.js"
              );
              var anObject = __webpack_require__(
                /! ../internals/an-object /
                "./node_modules/core-js/internals/an-object.js"
              );
              var toPrimitive = __webpack_require__(
                /! ../internals/to-primitive /
                "./node_modules/core-js/internals/to-primitive.js"
              );
              var nativeDefineProperty = Object.defineProperty;
              exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
                anObject(O);
                P = toPrimitive(P, true);
                anObject(Attributes);
                if (IE_DOM_DEFINE)
                  try {
                    return nativeDefineProperty(O, P, Attributes);
                  } catch (error) {
                  }
                if ("get" in Attributes || "set" in Attributes)
                  throw TypeError("Accessors not supported");
                if ("value" in Attributes)
                  O[P] = Attributes.value;
                return O;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/object-get-own-property-descriptor.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-get-own-property-descriptor.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var DESCRIPTORS = __webpack_require__(
                /! ../internals/descriptors /
                "./node_modules/core-js/internals/descriptors.js"
              );
              var propertyIsEnumerableModule = __webpack_require__(
                /! ../internals/object-property-is-enumerable /
                "./node_modules/core-js/internals/object-property-is-enumerable.js"
              );
              var createPropertyDescriptor = __webpack_require__(
                /! ../internals/create-property-descriptor /
                "./node_modules/core-js/internals/create-property-descriptor.js"
              );
              var toIndexedObject = __webpack_require__(
                /! ../internals/to-indexed-object /
                "./node_modules/core-js/internals/to-indexed-object.js"
              );
              var toPrimitive = __webpack_require__(
                /! ../internals/to-primitive /
                "./node_modules/core-js/internals/to-primitive.js"
              );
              var has = __webpack_require__(
                /! ../internals/has /
                "./node_modules/core-js/internals/has.js"
              );
              var IE_DOM_DEFINE = __webpack_require__(
                /! ../internals/ie-dom-define /
                "./node_modules/core-js/internals/ie-dom-define.js"
              );
              var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
                O = toIndexedObject(O);
                P = toPrimitive(P, true);
                if (IE_DOM_DEFINE)
                  try {
                    return nativeGetOwnPropertyDescriptor(O, P);
                  } catch (error) {
                  }
                if (has(O, P))
                  return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
              };
            }
          ),
          //
          "./node_modules/core-js/internals/object-get-own-property-names.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-get-own-property-names.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var internalObjectKeys = __webpack_require__(
                /! ../internals/object-keys-internal /
                "./node_modules/core-js/internals/object-keys-internal.js"
              );
              var enumBugKeys = __webpack_require__(
                /! ../internals/enum-bug-keys /
                "./node_modules/core-js/internals/enum-bug-keys.js"
              );
              var hiddenKeys = enumBugKeys.concat("length", "prototype");
              exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                return internalObjectKeys(O, hiddenKeys);
              };
            }
          ),
          //
          "./node_modules/core-js/internals/object-get-own-property-symbols.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-get-own-property-symbols.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              exports.f = Object.getOwnPropertySymbols;
            }
          ),
          //
          "./node_modules/core-js/internals/object-get-prototype-of.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-get-prototype-of.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var has = __webpack_require__(
                /! ../internals/has /
                "./node_modules/core-js/internals/has.js"
              );
              var toObject = __webpack_require__(
                /! ../internals/to-object /
                "./node_modules/core-js/internals/to-object.js"
              );
              var sharedKey = __webpack_require__(
                /! ../internals/shared-key /
                "./node_modules/core-js/internals/shared-key.js"
              );
              var CORRECT_PROTOTYPE_GETTER = __webpack_require__(
                /! ../internals/correct-prototype-getter /
                "./node_modules/core-js/internals/correct-prototype-getter.js"
              );
              var IE_PROTO = sharedKey("IE_PROTO");
              var ObjectPrototype = Object.prototype;
              module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
                O = toObject(O);
                if (has(O, IE_PROTO))
                  return O[IE_PROTO];
                if (typeof O.constructor == "function" && O instanceof O.constructor) {
                  return O.constructor.prototype;
                }
                return O instanceof Object ? ObjectPrototype : null;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/object-keys-internal.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-keys-internal.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var has = __webpack_require__(
                /! ../internals/has /
                "./node_modules/core-js/internals/has.js"
              );
              var toIndexedObject = __webpack_require__(
                /! ../internals/to-indexed-object /
                "./node_modules/core-js/internals/to-indexed-object.js"
              );
              var arrayIncludes = __webpack_require__(
                /! ../internals/array-includes /
                "./node_modules/core-js/internals/array-includes.js"
              );
              var hiddenKeys = __webpack_require__(
                /! ../internals/hidden-keys /
                "./node_modules/core-js/internals/hidden-keys.js"
              );
              var arrayIndexOf = arrayIncludes(false);
              module.exports = function(object, names) {
                var O = toIndexedObject(object);
                var i = ;
                var result = [];
                var key;
                for (key in O)
                  !has(hiddenKeys, key) && has(O, key) && result.push(key);
                while (names.length > i)
                  if (has(O, key = names[i++])) {
                    ~arrayIndexOf(result, key) || result.push(key);
                  }
                return result;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/object-keys.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-keys.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var internalObjectKeys = __webpack_require__(
                /! ../internals/object-keys-internal /
                "./node_modules/core-js/internals/object-keys-internal.js"
              );
              var enumBugKeys = __webpack_require__(
                /! ../internals/enum-bug-keys /
                "./node_modules/core-js/internals/enum-bug-keys.js"
              );
              module.exports = Object.keys || function keys(O) {
                return internalObjectKeys(O, enumBugKeys);
              };
            }
          ),
          //
          "./node_modules/core-js/internals/object-property-is-enumerable.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-property-is-enumerable.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
              var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
              var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ :  }, );
              exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
                var descriptor = getOwnPropertyDescriptor(this, V);
                return !!descriptor && descriptor.enumerable;
              } : nativePropertyIsEnumerable;
            }
          ),
          //
          "./node_modules/core-js/internals/object-set-prototype-of.js": (
            /!!\
              ! ./node_modules/core-js/internals/object-set-prototype-of.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var validateSetPrototypeOfArguments = __webpack_require__(
                /! ../internals/validate-set-prototype-of-arguments /
                "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js"
              );
              module.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                var correctSetter = false;
                var test = {};
                var setter;
                try {
                  setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
                  setter.call(test, []);
                  correctSetter = test instanceof Array;
                } catch (error) {
                }
                return function setPrototypeOf(O, proto) {
                  validateSetPrototypeOfArguments(O, proto);
                  if (correctSetter)
                    setter.call(O, proto);
                  else
                    O.__proto__ = proto;
                  return O;
                };
              }() : void );
            }
          ),
          //
          "./node_modules/core-js/internals/own-keys.js": (
            /!!\
              ! ./node_modules/core-js/internals/own-keys.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var global = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
              var getOwnPropertyNamesModule = __webpack_require__(
                /! ../internals/object-get-own-property-names /
                "./node_modules/core-js/internals/object-get-own-property-names.js"
              );
              var getOwnPropertySymbolsModule = __webpack_require__(
                /! ../internals/object-get-own-property-symbols /
                "./node_modules/core-js/internals/object-get-own-property-symbols.js"
              );
              var anObject = __webpack_require__(
                /! ../internals/an-object /
                "./node_modules/core-js/internals/an-object.js"
              );
              var Reflect = global.Reflect;
              module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
                var keys = getOwnPropertyNamesModule.f(anObject(it));
                var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
                return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/path.js": (
            /!!\
              ! ./node_modules/core-js/internals/path.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              module.exports = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
            }
          ),
          //
          "./node_modules/core-js/internals/redefine.js": (
            /!!\
              ! ./node_modules/core-js/internals/redefine.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var global = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
              var shared = __webpack_require__(
                /! ../internals/shared /
                "./node_modules/core-js/internals/shared.js"
              );
              var hide = __webpack_require__(
                /! ../internals/hide /
                "./node_modules/core-js/internals/hide.js"
              );
              var has = __webpack_require__(
                /! ../internals/has /
                "./node_modules/core-js/internals/has.js"
              );
              var setGlobal = __webpack_require__(
                /! ../internals/set-global /
                "./node_modules/core-js/internals/set-global.js"
              );
              var nativeFunctionToString = __webpack_require__(
                /! ../internals/function-to-string /
                "./node_modules/core-js/internals/function-to-string.js"
              );
              var InternalStateModule = __webpack_require__(
                /! ../internals/internal-state /
                "./node_modules/core-js/internals/internal-state.js"
              );
              var getInternalState = InternalStateModule.get;
              var enforceInternalState = InternalStateModule.enforce;
              var TEMPLATE = String(nativeFunctionToString).split("toString");
              shared("inspectSource", function(it) {
                return nativeFunctionToString.call(it);
              });
              (module.exports = function(O, key, value, options) {
                var unsafe = options ? !!options.unsafe : false;
                var simple = options ? !!options.enumerable : false;
                var noTargetGet = options ? !!options.noTargetGet : false;
                if (typeof value == "function") {
                  if (typeof key == "string" && !has(value, "name"))
                    hide(value, "name", key);
                  enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
                }
                if (O === global) {
                  if (simple)
                    O[key] = value;
                  else
                    setGlobal(key, value);
                  return;
                } else if (!unsafe) {
                  delete O[key];
                } else if (!noTargetGet && O[key]) {
                  simple = true;
                }
                if (simple)
                  O[key] = value;
                else
                  hide(O, key, value);
              })(Function.prototype, "toString", function toString() {
                return typeof this == "function" && getInternalState(this).source || nativeFunctionToString.call(this);
              });
            }
          ),
          //
          "./node_modules/core-js/internals/require-object-coercible.js": (
            /!!\
              ! ./node_modules/core-js/internals/require-object-coercible.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              module.exports = function(it) {
                if (it == void )
                  throw TypeError("Can't call method on " + it);
                return it;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/set-global.js": (
            /!!\
              ! ./node_modules/core-js/internals/set-global.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var global = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
              var hide = __webpack_require__(
                /! ../internals/hide /
                "./node_modules/core-js/internals/hide.js"
              );
              module.exports = function(key, value) {
                try {
                  hide(global, key, value);
                } catch (error) {
                  global[key] = value;
                }
                return value;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/set-to-string-tag.js": (
            /!!\
              ! ./node_modules/core-js/internals/set-to-string-tag.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var defineProperty = __webpack_require__(
                /! ../internals/object-define-property /
                "./node_modules/core-js/internals/object-define-property.js"
              ).f;
              var has = __webpack_require__(
                /! ../internals/has /
                "./node_modules/core-js/internals/has.js"
              );
              var wellKnownSymbol = __webpack_require__(
                /! ../internals/well-known-symbol /
                "./node_modules/core-js/internals/well-known-symbol.js"
              );
              var TO_STRING_TAG = wellKnownSymbol("toStringTag");
              module.exports = function(it, TAG, STATIC) {
                if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
                  defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
                }
              };
            }
          ),
          //
          "./node_modules/core-js/internals/shared-key.js": (
            /!!\
              ! ./node_modules/core-js/internals/shared-key.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var shared = __webpack_require__(
                /! ../internals/shared /
                "./node_modules/core-js/internals/shared.js"
              );
              var uid = __webpack_require__(
                /! ../internals/uid /
                "./node_modules/core-js/internals/uid.js"
              );
              var keys = shared("keys");
              module.exports = function(key) {
                return keys[key] || (keys[key] = uid(key));
              };
            }
          ),
          //
          "./node_modules/core-js/internals/shared.js": (
            /!!\
              ! ./node_modules/core-js/internals/shared.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var global = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
              var setGlobal = __webpack_require__(
                /! ../internals/set-global /
                "./node_modules/core-js/internals/set-global.js"
              );
              var IS_PURE = __webpack_require__(
                /! ../internals/is-pure /
                "./node_modules/core-js/internals/is-pure.js"
              );
              var SHARED = "__core-js_shared__";
              var store = global[SHARED] || setGlobal(SHARED, {});
              (module.exports = function(key, value) {
                return store[key] || (store[key] = value !== void  ? value : {});
              })("versions", []).push({
                version: "..",
                mode: IS_PURE ? "pure" : "global",
                copyright: "\xA  Denis Pushkarev (zloirock.ru)"
              });
            }
          ),
          //
          "./node_modules/core-js/internals/string-at.js": (
            /!!\
              ! ./node_modules/core-js/internals/string-at.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var toInteger = __webpack_require__(
                /! ../internals/to-integer /
                "./node_modules/core-js/internals/to-integer.js"
              );
              var requireObjectCoercible = __webpack_require__(
                /! ../internals/require-object-coercible /
                "./node_modules/core-js/internals/require-object-coercible.js"
              );
              module.exports = function(that, pos, CONVERT_TO_STRING) {
                var S = String(requireObjectCoercible(that));
                var position = toInteger(pos);
                var size = S.length;
                var first, second;
                if (position <  || position >= size)
                  return CONVERT_TO_STRING ? "" : void ;
                first = S.charCodeAt(position);
                return first <  || first >  || position +  === size || (second = S.charCodeAt(position + )) <  || second >  ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + ) : (first -  << ) + (second - ) + ;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/to-absolute-index.js": (
            /!!\
              ! ./node_modules/core-js/internals/to-absolute-index.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var toInteger = __webpack_require__(
                /! ../internals/to-integer /
                "./node_modules/core-js/internals/to-integer.js"
              );
              var max = Math.max;
              var min = Math.min;
              module.exports = function(index, length) {
                var integer = toInteger(index);
                return integer <  ? max(integer + length, ) : min(integer, length);
              };
            }
          ),
          //
          "./node_modules/core-js/internals/to-indexed-object.js": (
            /!!\
              ! ./node_modules/core-js/internals/to-indexed-object.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var IndexedObject = __webpack_require__(
                /! ../internals/indexed-object /
                "./node_modules/core-js/internals/indexed-object.js"
              );
              var requireObjectCoercible = __webpack_require__(
                /! ../internals/require-object-coercible /
                "./node_modules/core-js/internals/require-object-coercible.js"
              );
              module.exports = function(it) {
                return IndexedObject(requireObjectCoercible(it));
              };
            }
          ),
          //
          "./node_modules/core-js/internals/to-integer.js": (
            /!!\
              ! ./node_modules/core-js/internals/to-integer.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              var ceil = Math.ceil;
              var floor = Math.floor;
              module.exports = function(argument) {
                return isNaN(argument = +argument) ?  : (argument >  ? floor : ceil)(argument);
              };
            }
          ),
          //
          "./node_modules/core-js/internals/to-length.js": (
            /!!\
              ! ./node_modules/core-js/internals/to-length.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var toInteger = __webpack_require__(
                /! ../internals/to-integer /
                "./node_modules/core-js/internals/to-integer.js"
              );
              var min = Math.min;
              module.exports = function(argument) {
                return argument >  ? min(toInteger(argument), ) : ;
              };
            }
          ),
          //
          "./node_modules/core-js/internals/to-object.js": (
            /!!\
              ! ./node_modules/core-js/internals/to-object.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var requireObjectCoercible = __webpack_require__(
                /! ../internals/require-object-coercible /
                "./node_modules/core-js/internals/require-object-coercible.js"
              );
              module.exports = function(argument) {
                return Object(requireObjectCoercible(argument));
              };
            }
          ),
          //
          "./node_modules/core-js/internals/to-primitive.js": (
            /!!\
              ! ./node_modules/core-js/internals/to-primitive.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var isObject = __webpack_require__(
                /! ../internals/is-object /
                "./node_modules/core-js/internals/is-object.js"
              );
              module.exports = function(it, S) {
                if (!isObject(it))
                  return it;
                var fn, val;
                if (S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
                  return val;
                if (typeof (fn = it.valueOf) == "function" && !isObject(val = fn.call(it)))
                  return val;
                if (!S && typeof (fn = it.toString) == "function" && !isObject(val = fn.call(it)))
                  return val;
                throw TypeError("Can't convert object to primitive value");
              };
            }
          ),
          //
          "./node_modules/core-js/internals/uid.js": (
            /!!\
              ! ./node_modules/core-js/internals/uid.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              var id = ;
              var postfix = Math.random();
              module.exports = function(key) {
                return "Symbol(".concat(key === void  ? "" : key, ")_", (++id + postfix).toString());
              };
            }
          ),
          //
          "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js": (
            /!!\
              ! ./node_modules/core-js/internals/validate-set-prototype-of-arguments.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var isObject = __webpack_require__(
                /! ../internals/is-object /
                "./node_modules/core-js/internals/is-object.js"
              );
              var anObject = __webpack_require__(
                /! ../internals/an-object /
                "./node_modules/core-js/internals/an-object.js"
              );
              module.exports = function(O, proto) {
                anObject(O);
                if (!isObject(proto) && proto !== null) {
                  throw TypeError("Can't set " + String(proto) + " as a prototype");
                }
              };
            }
          ),
          //
          "./node_modules/core-js/internals/well-known-symbol.js": (
            /!!\
              ! ./node_modules/core-js/internals/well-known-symbol.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var global = __webpack_require__(
                /! ../internals/global /
                "./node_modules/core-js/internals/global.js"
              );
              var shared = __webpack_require__(
                /! ../internals/shared /
                "./node_modules/core-js/internals/shared.js"
              );
              var uid = __webpack_require__(
                /! ../internals/uid /
                "./node_modules/core-js/internals/uid.js"
              );
              var NATIVE_SYMBOL = __webpack_require__(
                /! ../internals/native-symbol /
                "./node_modules/core-js/internals/native-symbol.js"
              );
              var Symbol = global.Symbol;
              var store = shared("wks");
              module.exports = function(name) {
                return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name] || (NATIVE_SYMBOL ? Symbol : uid)("Symbol." + name));
              };
            }
          ),
          //
          "./node_modules/core-js/modules/es.array.from.js": (
            /!!\
              ! ./node_modules/core-js/modules/es.array.from.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              var $ = __webpack_require__(
                /! ../internals/export /
                "./node_modules/core-js/internals/export.js"
              );
              var from = __webpack_require__(
                /! ../internals/array-from /
                "./node_modules/core-js/internals/array-from.js"
              );
              var checkCorrectnessOfIteration = __webpack_require__(
                /! ../internals/check-correctness-of-iteration /
                "./node_modules/core-js/internals/check-correctness-of-iteration.js"
              );
              var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
                Array.from(iterable);
              });
              $({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
                from
              });
            }
          ),
          //
          "./node_modules/core-js/modules/es.string.iterator.js": (
            /!!\
              ! ./node_modules/core-js/modules/es.string.iterator.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              var codePointAt = __webpack_require__(
                /! ../internals/string-at /
                "./node_modules/core-js/internals/string-at.js"
              );
              var InternalStateModule = __webpack_require__(
                /! ../internals/internal-state /
                "./node_modules/core-js/internals/internal-state.js"
              );
              var defineIterator = __webpack_require__(
                /! ../internals/define-iterator /
                "./node_modules/core-js/internals/define-iterator.js"
              );
              var STRING_ITERATOR = "String Iterator";
              var setInternalState = InternalStateModule.set;
              var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
              defineIterator(String, "String", function(iterated) {
                setInternalState(this, {
                  type: STRING_ITERATOR,
                  string: String(iterated),
                  index: 
                });
              }, function next() {
                var state = getInternalState(this);
                var string = state.string;
                var index = state.index;
                var point;
                if (index >= string.length)
                  return { value: void , done: true };
                point = codePointAt(string, index, true);
                state.index += point.length;
                return { value: point, done: false };
              });
            }
          ),
          //
          "./node_modules/webpack/buildin/global.js": (
            /!!\
              ! (webpack)/buildin/global.js !
              \/
            /! no static exports found /
            //
            function(module, exports) {
              var g;
              g = function() {
                return this;
              }();
              try {
                g = g || Function("return this")() || (, eval)("this");
              } catch (e) {
                if (typeof window === "object")
                  g = window;
              }
              module.exports = g;
            }
          ),
          //
          "./src/default-attrs.json": (
            /!!\
              ! ./src/default-attrs.json !
              \/
            /! exports provided: xmlns, width, height, viewBox, fill, stroke, stroke-width, stroke-linecap, stroke-linejoin, default /
            //
            function(module) {
              module.exports = { "xmlns": "http://www.w.org//svg", "width": , "height": , "viewBox": "   ", "fill": "none", "stroke": "currentColor", "stroke-width": , "stroke-linecap": "round", "stroke-linejoin": "round" };
            }
          ),
          //
          "./src/icon.js": (
            /!!\
              ! ./src/icon.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _extends = Object.assign || function(target) {
                for (var i = ; i < arguments.length; i++) {
                  var source = arguments[i];
                  for (var key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                      target[key] = source[key];
                    }
                  }
                }
                return target;
              };
              var _createClass = function() {
                function defineProperties(target, props) {
                  for (var i = ; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor)
                      descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                  }
                }
                return function(Constructor, protoProps, staticProps) {
                  if (protoProps)
                    defineProperties(Constructor.prototype, protoProps);
                  if (staticProps)
                    defineProperties(Constructor, staticProps);
                  return Constructor;
                };
              }();
              var _dedupe = __webpack_require__(
                /! classnames/dedupe /
                "./node_modules/classnames/dedupe.js"
              );
              var _dedupe = _interopRequireDefault(_dedupe);
              var _defaultAttrs = __webpack_require__(
                /! ./default-attrs.json /
                "./src/default-attrs.json"
              );
              var _defaultAttrs = _interopRequireDefault(_defaultAttrs);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                  throw new TypeError("Cannot call a class as a function");
                }
              }
              var Icon = function() {
                function Icon(name, contents) {
                  var tags = arguments.length >  && arguments[] !== void  ? arguments[] : [];
                  _classCallCheck(this, Icon);
                  this.name = name;
                  this.contents = contents;
                  this.tags = tags;
                  this.attrs = _extends({}, _defaultAttrs.default, { class: "feather feather-" + name });
                }
                _createClass(Icon, [{
                  key: "toSvg",
                  value: function toSvg() {
                    var attrs = arguments.length >  && arguments[] !== void  ? arguments[] : {};
                    var combinedAttrs = _extends({}, this.attrs, attrs, { class: (, _dedupe.default)(this.attrs.class, attrs.class) });
                    return "<svg " + attrsToString(combinedAttrs) + ">" + this.contents + "</svg>";
                  }
                  /
                    Return string representation of an `Icon`.
                   
                    Added for backward compatibility. If old code expects `feather.icons.<name>`
                    to be a string, `toString()` will get implicitly called.
                   
                    @returns {string}
                   /
                }, {
                  key: "toString",
                  value: function toString() {
                    return this.contents;
                  }
                }]);
                return Icon;
              }();
              function attrsToString(attrs) {
                return Object.keys(attrs).map(function(key) {
                  return key + '="' + attrs[key] + '"';
                }).join(" ");
              }
              exports.default = Icon;
            }
          ),
          //
          "./src/icons.js": (
            /!!\
              ! ./src/icons.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _icon = __webpack_require__(
                /! ./icon /
                "./src/icon.js"
              );
              var _icon = _interopRequireDefault(_icon);
              var _icons = __webpack_require__(
                /! ../dist/icons.json /
                "./dist/icons.json"
              );
              var _icons = _interopRequireDefault(_icons);
              var _tags = __webpack_require__(
                /! ./tags.json /
                "./src/tags.json"
              );
              var _tags = _interopRequireDefault(_tags);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              exports.default = Object.keys(_icons.default).map(function(key) {
                return new _icon.default(key, _icons.default[key], _tags.default[key]);
              }).reduce(function(object, icon) {
                object[icon.name] = icon;
                return object;
              }, {});
            }
          ),
          //
          "./src/index.js": (
            /!!\
              ! ./src/index.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              var _icons = __webpack_require__(
                /! ./icons /
                "./src/icons.js"
              );
              var _icons = _interopRequireDefault(_icons);
              var _toSvg = __webpack_require__(
                /! ./to-svg /
                "./src/to-svg.js"
              );
              var _toSvg = _interopRequireDefault(_toSvg);
              var _replace = __webpack_require__(
                /! ./replace /
                "./src/replace.js"
              );
              var _replace = _interopRequireDefault(_replace);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              module.exports = { icons: _icons.default, toSvg: _toSvg.default, replace: _replace.default };
            }
          ),
          //
          "./src/replace.js": (
            /!!\
              ! ./src/replace.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _extends = Object.assign || function(target) {
                for (var i = ; i < arguments.length; i++) {
                  var source = arguments[i];
                  for (var key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                      target[key] = source[key];
                    }
                  }
                }
                return target;
              };
              var _dedupe = __webpack_require__(
                /! classnames/dedupe /
                "./node_modules/classnames/dedupe.js"
              );
              var _dedupe = _interopRequireDefault(_dedupe);
              var _icons = __webpack_require__(
                /! ./icons /
                "./src/icons.js"
              );
              var _icons = _interopRequireDefault(_icons);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              function replace() {
                var attrs = arguments.length >  && arguments[] !== void  ? arguments[] : {};
                if (typeof document === "undefined") {
                  throw new Error("`feather.replace()` only works in a browser environment.");
                }
                var elementsToReplace = document.querySelectorAll("[data-feather]");
                Array.from(elementsToReplace).forEach(function(element) {
                  return replaceElement(element, attrs);
                });
              }
              function replaceElement(element) {
                var attrs = arguments.length >  && arguments[] !== void  ? arguments[] : {};
                var elementAttrs = getAttrs(element);
                var name = elementAttrs["data-feather"];
                delete elementAttrs["data-feather"];
                var svgString = _icons.default[name].toSvg(_extends({}, attrs, elementAttrs, { class: (, _dedupe.default)(attrs.class, elementAttrs.class) }));
                var svgDocument = new DOMParser().parseFromString(svgString, "image/svg+xml");
                var svgElement = svgDocument.querySelector("svg");
                element.parentNode.replaceChild(svgElement, element);
              }
              function getAttrs(element) {
                return Array.from(element.attributes).reduce(function(attrs, attr) {
                  attrs[attr.name] = attr.value;
                  return attrs;
                }, {});
              }
              exports.default = replace;
            }
          ),
          //
          "./src/tags.json": (
            /!!\
              ! ./src/tags.json !
              \/
            /! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, archive, at-sign, award, aperture, bar-chart, bar-chart-, battery, battery-charging, bell, bell-off, bluetooth, book-open, book, bookmark, box, briefcase, calendar, camera, cast, chevron-down, chevron-up, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-rain, cloud-snow, cloud, codepen, codesandbox, code, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, dollar-sign, droplet, edit, edit-, edit-, eye, eye-off, external-link, facebook, fast-forward, figma, file-minus, file-plus, file-text, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, instagram, key, layers, layout, life-bouy, link, link-, linkedin, list, lock, log-in, log-out, mail, map-pin, map, maximize, maximize-, meh, menu, message-circle, message-square, mic-off, mic, minimize, minimize-, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation, navigation-, octagon, package, paperclip, pause, pause-circle, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, play, pie-chart, play-circle, plus, plus-circle, plus-square, pocket, power, printer, radio, refresh-cw, refresh-ccw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, settings, share-, shield, shield-off, shopping-bag, shopping-cart, shuffle, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, star, stop-circle, sun, sunrise, sunset, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash, trash-, triangle, truck, tv, twitch, twitter, type, umbrella, unlock, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume, volume-, volume-, volume-x, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default /
            //
            function(module) {
              module.exports = { "activity": ["pulse", "health", "action", "motion"], "airplay": ["stream", "cast", "mirroring"], "alert-circle": ["warning", "alert", "danger"], "alert-octagon": ["warning", "alert", "danger"], "alert-triangle": ["warning", "alert", "danger"], "align-center": ["text alignment", "center"], "align-justify": ["text alignment", "justified"], "align-left": ["text alignment", "left"], "align-right": ["text alignment", "right"], "anchor": [], "archive": ["index", "box"], "at-sign": ["mention", "at", "email", "message"], "award": ["achievement", "badge"], "aperture": ["camera", "photo"], "bar-chart": ["statistics", "diagram", "graph"], "bar-chart-": ["statistics", "diagram", "graph"], "battery": ["power", "electricity"], "battery-charging": ["power", "electricity"], "bell": ["alarm", "notification", "sound"], "bell-off": ["alarm", "notification", "silent"], "bluetooth": ["wireless"], "book-open": ["read", "library"], "book": ["read", "dictionary", "booklet", "magazine", "library"], "bookmark": ["read", "clip", "marker", "tag"], "box": ["cube"], "briefcase": ["work", "bag", "baggage", "folder"], "calendar": ["date"], "camera": ["photo"], "cast": ["chromecast", "airplay"], "chevron-down": ["expand"], "chevron-up": ["collapse"], "circle": ["off", "zero", "record"], "clipboard": ["copy"], "clock": ["time", "watch", "alarm"], "cloud-drizzle": ["weather", "shower"], "cloud-lightning": ["weather", "bolt"], "cloud-rain": ["weather"], "cloud-snow": ["weather", "blizzard"], "cloud": ["weather"], "codepen": ["logo"], "codesandbox": ["logo"], "code": ["source", "programming"], "coffee": ["drink", "cup", "mug", "tea", "cafe", "hot", "beverage"], "columns": ["layout"], "command": ["keyboard", "cmd", "terminal", "prompt"], "compass": ["navigation", "safari", "travel", "direction"], "copy": ["clone", "duplicate"], "corner-down-left": ["arrow", "return"], "corner-down-right": ["arrow"], "corner-left-down": ["arrow"], "corner-left-up": ["arrow"], "corner-right-down": ["arrow"], "corner-right-up": ["arrow"], "corner-up-left": ["arrow"], "corner-up-right": ["arrow"], "cpu": ["processor", "technology"], "credit-card": ["purchase", "payment", "cc"], "crop": ["photo", "image"], "crosshair": ["aim", "target"], "database": ["storage", "memory"], "delete": ["remove"], "disc": ["album", "cd", "dvd", "music"], "dollar-sign": ["currency", "money", "payment"], "droplet": ["water"], "edit": ["pencil", "change"], "edit-": ["pencil", "change"], "edit-": ["pencil", "change"], "eye": ["view", "watch"], "eye-off": ["view", "watch", "hide", "hidden"], "external-link": ["outbound"], "facebook": ["logo", "social"], "fast-forward": ["music"], "figma": ["logo", "design", "tool"], "file-minus": ["delete", "remove", "erase"], "file-plus": ["add", "create", "new"], "file-text": ["data", "txt", "pdf"], "film": ["movie", "video"], "filter": ["funnel", "hopper"], "flag": ["report"], "folder-minus": ["directory"], "folder-plus": ["directory"], "folder": ["directory"], "framer": ["logo", "design", "tool"], "frown": ["emoji", "face", "bad", "sad", "emotion"], "gift": ["present", "box", "birthday", "party"], "git-branch": ["code", "version control"], "git-commit": ["code", "version control"], "git-merge": ["code", "version control"], "git-pull-request": ["code", "version control"], "github": ["logo", "version control"], "gitlab": ["logo", "version control"], "globe": ["world", "browser", "language", "translate"], "hard-drive": ["computer", "server", "memory", "data"], "hash": ["hashtag", "number", "pound"], "headphones": ["music", "audio", "sound"], "heart": ["like", "love", "emotion"], "help-circle": ["question mark"], "hexagon": ["shape", "node.js", "logo"], "home": ["house", "living"], "image": ["picture"], "inbox": ["email"], "instagram": ["logo", "camera"], "key": ["password", "login", "authentication", "secure"], "layers": ["stack"], "layout": ["window", "webpage"], "life-bouy": ["help", "life ring", "support"], "link": ["chain", "url"], "link-": ["chain", "url"], "linkedin": ["logo", "social media"], "list": ["options"], "lock": ["security", "password", "secure"], "log-in": ["sign in", "arrow", "enter"], "log-out": ["sign out", "arrow", "exit"], "mail": ["email", "message"], "map-pin": ["location", "navigation", "travel", "marker"], "map": ["location", "navigation", "travel"], "maximize": ["fullscreen"], "maximize-": ["fullscreen", "arrows", "expand"], "meh": ["emoji", "face", "neutral", "emotion"], "menu": ["bars", "navigation", "hamburger"], "message-circle": ["comment", "chat"], "message-square": ["comment", "chat"], "mic-off": ["record", "sound", "mute"], "mic": ["record", "sound", "listen"], "minimize": ["exit fullscreen", "close"], "minimize-": ["exit fullscreen", "arrows", "close"], "minus": ["subtract"], "monitor": ["tv", "screen", "display"], "moon": ["dark", "night"], "more-horizontal": ["ellipsis"], "more-vertical": ["ellipsis"], "mouse-pointer": ["arrow", "cursor"], "move": ["arrows"], "music": ["note"], "navigation": ["location", "travel"], "navigation-": ["location", "travel"], "octagon": ["stop"], "package": ["box", "container"], "paperclip": ["attachment"], "pause": ["music", "stop"], "pause-circle": ["music", "audio", "stop"], "pen-tool": ["vector", "drawing"], "percent": ["discount"], "phone-call": ["ring"], "phone-forwarded": ["call"], "phone-incoming": ["call"], "phone-missed": ["call"], "phone-off": ["call", "mute"], "phone-outgoing": ["call"], "phone": ["call"], "play": ["music", "start"], "pie-chart": ["statistics", "diagram"], "play-circle": ["music", "start"], "plus": ["add", "new"], "plus-circle": ["add", "new"], "plus-square": ["add", "new"], "pocket": ["logo", "save"], "power": ["on", "off"], "printer": ["fax", "office", "device"], "radio": ["signal"], "refresh-cw": ["synchronise", "arrows"], "refresh-ccw": ["arrows"], "repeat": ["loop", "arrows"], "rewind": ["music"], "rotate-ccw": ["arrow"], "rotate-cw": ["arrow"], "rss": ["feed", "subscribe"], "save": ["floppy disk"], "scissors": ["cut"], "search": ["find", "magnifier", "magnifying glass"], "send": ["message", "mail", "email", "paper airplane", "paper aeroplane"], "settings": ["cog", "edit", "gear", "preferences"], "share-": ["network", "connections"], "shield": ["security", "secure"], "shield-off": ["security", "insecure"], "shopping-bag": ["ecommerce", "cart", "purchase", "store"], "shopping-cart": ["ecommerce", "cart", "purchase", "store"], "shuffle": ["music"], "skip-back": ["music"], "skip-forward": ["music"], "slack": ["logo"], "slash": ["ban", "no"], "sliders": ["settings", "controls"], "smartphone": ["cellphone", "device"], "smile": ["emoji", "face", "happy", "good", "emotion"], "speaker": ["audio", "music"], "star": ["bookmark", "favorite", "like"], "stop-circle": ["media", "music"], "sun": ["brightness", "weather", "light"], "sunrise": ["weather", "time", "morning", "day"], "sunset": ["weather", "time", "evening", "night"], "tablet": ["device"], "tag": ["label"], "target": ["logo", "bullseye"], "terminal": ["code", "command line", "prompt"], "thermometer": ["temperature", "celsius", "fahrenheit", "weather"], "thumbs-down": ["dislike", "bad", "emotion"], "thumbs-up": ["like", "good", "emotion"], "toggle-left": ["on", "off", "switch"], "toggle-right": ["on", "off", "switch"], "tool": ["settings", "spanner"], "trash": ["garbage", "delete", "remove", "bin"], "trash-": ["garbage", "delete", "remove", "bin"], "triangle": ["delta"], "truck": ["delivery", "van", "shipping", "transport", "lorry"], "tv": ["television", "stream"], "twitch": ["logo"], "twitter": ["logo", "social"], "type": ["text"], "umbrella": ["rain", "weather"], "unlock": ["security"], "user-check": ["followed", "subscribed"], "user-minus": ["delete", "remove", "unfollow", "unsubscribe"], "user-plus": ["new", "add", "create", "follow", "subscribe"], "user-x": ["delete", "remove", "unfollow", "unsubscribe", "unavailable"], "user": ["person", "account"], "users": ["group"], "video-off": ["camera", "movie", "film"], "video": ["camera", "movie", "film"], "voicemail": ["phone"], "volume": ["music", "sound", "mute"], "volume-": ["music", "sound"], "volume-": ["music", "sound"], "volume-x": ["music", "sound", "mute"], "watch": ["clock", "time"], "wifi-off": ["disabled"], "wifi": ["connection", "signal", "wireless"], "wind": ["weather", "air"], "x-circle": ["cancel", "close", "delete", "remove", "times", "clear"], "x-octagon": ["delete", "stop", "alert", "warning", "times", "clear"], "x-square": ["cancel", "close", "delete", "remove", "times", "clear"], "x": ["cancel", "close", "delete", "remove", "times", "clear"], "youtube": ["logo", "video", "play"], "zap-off": ["flash", "camera", "lightning"], "zap": ["flash", "camera", "lightning"], "zoom-in": ["magnifying glass"], "zoom-out": ["magnifying glass"] };
            }
          ),
          //
          "./src/to-svg.js": (
            /!!\
              ! ./src/to-svg.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              "use strict";
              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              var _icons = __webpack_require__(
                /! ./icons /
                "./src/icons.js"
              );
              var _icons = _interopRequireDefault(_icons);
              function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : { default: obj };
              }
              function toSvg(name) {
                var attrs = arguments.length >  && arguments[] !== void  ? arguments[] : {};
                console.warn("feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.");
                if (!name) {
                  throw new Error("The required `key` (icon name) parameter is missing.");
                }
                if (!_icons.default[name]) {
                  throw new Error("No icon matching '" + name + "'. See the complete list of icons at https://feathericons.com");
                }
                return _icons.default[name].toSvg(attrs);
              }
              exports.default = toSvg;
            }
          ),
          //
          : (
            /!!\
              ! multi core-js/es/array/from ./src/index.js !
              \/
            /! no static exports found /
            //
            function(module, exports, __webpack_require__) {
              __webpack_require__(
                /! core-js/es/array/from /
                "./node_modules/core-js/es/array/from.js"
              );
              module.exports = __webpack_require__(
                /! /home/runner/work/feather/feather/src/index.js /
                "./src/index.js"
              );
            }
          )
          //
        })
      );
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianGit
});
module.exports = __toCommonJS(main_exports);
init_polyfill_buffer();

// node_modules/.pnpm/isomorphic-git@../node_modules/isomorphic-git/index.js
init_polyfill_buffer();
var import_async_lock = __toESM(require_async_lock(), );
var import_sha = __toESM(require_sha(), );
var import_crc_ = __toESM(require_crc(), );
var import_pako = __toESM(require_pako(), );
var import_pify = __toESM(require_pify(), );
var import_ignore = __toESM(require_ignore(), );
var import_clean_git_ref = __toESM(require_lib(), );
var import_diff = __toESM(require_diff(), );
var BaseError = class extends Error {
  constructor(message) {
    super(message);
    this.caller = "";
  }
  toJSON() {
    return {
      code: this.code,
      data: this.data,
      caller: this.caller,
      message: this.message,
      stack: this.stack
    };
  }
  fromJSON(json) {
    const e = new BaseError(json.message);
    e.code = json.code;
    e.data = json.data;
    e.caller = json.caller;
    e.stack = json.stack;
    return e;
  }
  get isIsomorphicGitError() {
    return true;
  }
};
var UnmergedPathsError = class extends BaseError {
  /
    @param {Array<string>} filepaths
   /
  constructor(filepaths) {
    super(
      `Modifying the index is not possible because you have unmerged files: ${filepaths.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`
    );
    this.code = this.name = UnmergedPathsError.code;
    this.data = { filepaths };
  }
};
UnmergedPathsError.code = "UnmergedPathsError";
var InternalError = class extends BaseError {
  /
    @param {string} message
   /
  constructor(message) {
    super(
      `An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${message}`
    );
    this.code = this.name = InternalError.code;
    this.data = { message };
  }
};
InternalError.code = "InternalError";
var UnsafeFilepathError = class extends BaseError {
  /
    @param {string} filepath
   /
  constructor(filepath) {
    super(`The filepath "${filepath}" contains unsafe character sequences`);
    this.code = this.name = UnsafeFilepathError.code;
    this.data = { filepath };
  }
};
UnsafeFilepathError.code = "UnsafeFilepathError";
var BufferCursor = class {
  constructor(buffer) {
    this.buffer = buffer;
    this._start = ;
  }
  eof() {
    return this._start >= this.buffer.length;
  }
  tell() {
    return this._start;
  }
  seek(n) {
    this._start = n;
  }
  slice(n) {
    const r = this.buffer.slice(this._start, this._start + n);
    this._start += n;
    return r;
  }
  toString(enc, length) {
    const r = this.buffer.toString(enc, this._start, this._start + length);
    this._start += length;
    return r;
  }
  write(value, length, enc) {
    const r = this.buffer.write(value, this._start, length, enc);
    this._start += length;
    return r;
  }
  copy(source, start, end) {
    const r = source.copy(this.buffer, this._start, start, end);
    this._start += r;
    return r;
  }
  readUInt() {
    const r = this.buffer.readUInt(this._start);
    this._start += ;
    return r;
  }
  writeUInt(value) {
    const r = this.buffer.writeUInt(value, this._start);
    this._start += ;
    return r;
  }
  readUIntBE() {
    const r = this.buffer.readUIntBE(this._start);
    this._start += ;
    return r;
  }
  writeUIntBE(value) {
    const r = this.buffer.writeUIntBE(value, this._start);
    this._start += ;
    return r;
  }
  readUIntBE() {
    const r = this.buffer.readUIntBE(this._start);
    this._start += ;
    return r;
  }
  writeUIntBE(value) {
    const r = this.buffer.writeUIntBE(value, this._start);
    this._start += ;
    return r;
  }
};
function compareStrings(a, b) {
  return -(a < b) || +(a > b);
}
function comparePath(a, b) {
  return compareStrings(a.path, b.path);
}
function normalizeMode(mode) {
  let type = mode >  ? mode >>  : ;
  if (type !==  && type !==  && type !==  && type !== ) {
    type = ;
  }
  let permissions = mode & ;
  if (permissions & ) {
    permissions = ;
  } else {
    permissions = ;
  }
  if (type !== )
    permissions = ;
  return (type << ) + permissions;
}
var MAX_UINT =   ;
function SecondsNanoseconds(givenSeconds, givenNanoseconds, milliseconds, date) {
  if (givenSeconds !== void  && givenNanoseconds !== void ) {
    return [givenSeconds, givenNanoseconds];
  }
  if (milliseconds === void ) {
    milliseconds = date.valueOf();
  }
  const seconds = Math.floor(milliseconds / e);
  const nanoseconds = (milliseconds - seconds  e)  e;
  return [seconds, nanoseconds];
}
function normalizeStats(e) {
  const [ctimeSeconds, ctimeNanoseconds] = SecondsNanoseconds(
    e.ctimeSeconds,
    e.ctimeNanoseconds,
    e.ctimeMs,
    e.ctime
  );
  const [mtimeSeconds, mtimeNanoseconds] = SecondsNanoseconds(
    e.mtimeSeconds,
    e.mtimeNanoseconds,
    e.mtimeMs,
    e.mtime
  );
  return {
    ctimeSeconds: ctimeSeconds % MAX_UINT,
    ctimeNanoseconds: ctimeNanoseconds % MAX_UINT,
    mtimeSeconds: mtimeSeconds % MAX_UINT,
    mtimeNanoseconds: mtimeNanoseconds % MAX_UINT,
    dev: e.dev % MAX_UINT,
    ino: e.ino % MAX_UINT,
    mode: normalizeMode(e.mode % MAX_UINT),
    uid: e.uid % MAX_UINT,
    gid: e.gid % MAX_UINT,
    // size of - happens over a BrowserFS HTTP Backend that doesn't serve Content-Length headers
    // (like the Karma webserver) because BrowserFS HTTP Backend uses HTTP HEAD requests to do fs.stat
    size: e.size > - ? e.size % MAX_UINT : 
  };
}
function toHex(buffer) {
  let hex = "";
  for (const byte of new UintArray(buffer)) {
    if (byte < )
      hex += "";
    hex += byte.toString();
  }
  return hex;
}
var supportsSubtleSHA = null;
async function shasum(buffer) {
  if (supportsSubtleSHA === null) {
    supportsSubtleSHA = await testSubtleSHA();
  }
  return supportsSubtleSHA ? subtleSHA(buffer) : shasumSync(buffer);
}
function shasumSync(buffer) {
  return new import_sha.default().update(buffer).digest("hex");
}
async function subtleSHA(buffer) {
  const hash = await crypto.subtle.digest("SHA-", buffer);
  return toHex(hash);
}
async function testSubtleSHA() {
  try {
    const hash = await subtleSHA(new UintArray([]));
    if (hash === "daaeeebbdbfefafd")
      return true;
  } catch (_) {
  }
  return false;
}
function parseCacheEntryFlags(bits) {
  return {
    assumeValid: Boolean(bits & ),
    extended: Boolean(bits & ),
    stage: (bits & ) >> ,
    nameLength: bits & 
  };
}
function renderCacheEntryFlags(entry) {
  const flags = entry.flags;
  flags.extended = false;
  flags.nameLength = Math.min(Buffer.from(entry.path).length, );
  return (flags.assumeValid ?  : ) + (flags.extended ?  : ) + ((flags.stage & ) << ) + (flags.nameLength & );
}
var GitIndex = class {
  /::
   _entries: Map<string, CacheEntry>
   _dirty: boolean // Used to determine if index needs to be saved to filesystem
   /
  constructor(entries, unmergedPaths) {
    this._dirty = false;
    this._unmergedPaths = unmergedPaths || / @__PURE__ / new Set();
    this._entries = entries || / @__PURE__ / new Map();
  }
  _addEntry(entry) {
    if (entry.flags.stage === ) {
      entry.stages = [entry];
      this._entries.set(entry.path, entry);
      this._unmergedPaths.delete(entry.path);
    } else {
      let existingEntry = this._entries.get(entry.path);
      if (!existingEntry) {
        this._entries.set(entry.path, entry);
        existingEntry = entry;
      }
      existingEntry.stages[entry.flags.stage] = entry;
      this._unmergedPaths.add(entry.path);
    }
  }
  static async from(buffer) {
    if (Buffer.isBuffer(buffer)) {
      return GitIndex.fromBuffer(buffer);
    } else if (buffer === null) {
      return new GitIndex(null);
    } else {
      throw new InternalError("invalid type passed to GitIndex.from");
    }
  }
  static async fromBuffer(buffer) {
    const shaComputed = await shasum(buffer.slice(, -));
    const shaClaimed = buffer.slice(-).toString("hex");
    if (shaClaimed !== shaComputed) {
      throw new InternalError(
        `Invalid checksum in GitIndex buffer: expected ${shaClaimed} but saw ${shaComputed}`
      );
    }
    const index = new GitIndex();
    const reader = new BufferCursor(buffer);
    const magic = reader.toString("utf", );
    if (magic !== "DIRC") {
      throw new InternalError(`Inavlid dircache magic file number: ${magic}`);
    }
    const version = reader.readUIntBE();
    if (version !== ) {
      throw new InternalError(`Unsupported dircache version: ${version}`);
    }
    const numEntries = reader.readUIntBE();
    let i = ;
    while (!reader.eof() && i < numEntries) {
      const entry = {};
      entry.ctimeSeconds = reader.readUIntBE();
      entry.ctimeNanoseconds = reader.readUIntBE();
      entry.mtimeSeconds = reader.readUIntBE();
      entry.mtimeNanoseconds = reader.readUIntBE();
      entry.dev = reader.readUIntBE();
      entry.ino = reader.readUIntBE();
      entry.mode = reader.readUIntBE();
      entry.uid = reader.readUIntBE();
      entry.gid = reader.readUIntBE();
      entry.size = reader.readUIntBE();
      entry.oid = reader.slice().toString("hex");
      const flags = reader.readUIntBE();
      entry.flags = parseCacheEntryFlags(flags);
      const pathlength = buffer.indexOf(, reader.tell() + ) - reader.tell();
      if (pathlength < ) {
        throw new InternalError(`Got a path length of: ${pathlength}`);
      }
      entry.path = reader.toString("utf", pathlength);
      if (entry.path.includes("..\\") || entry.path.includes("../")) {
        throw new UnsafeFilepathError(entry.path);
      }
      let padding =  - (reader.tell() - ) % ;
      if (padding === )
        padding = ;
      while (padding--) {
        const tmp = reader.readUInt();
        if (tmp !== ) {
          throw new InternalError(
            `Expected - null characters but got '${tmp}' after ${entry.path}`
          );
        } else if (reader.eof()) {
          throw new InternalError("Unexpected end of file");
        }
      }
      entry.stages = [];
      index._addEntry(entry);
      i++;
    }
    return index;
  }
  get unmergedPaths() {
    return [...this._unmergedPaths];
  }
  get entries() {
    return [...this._entries.values()].sort(comparePath);
  }
  get entriesMap() {
    return this._entries;
  }
  get entriesFlat() {
    return [...this.entries].flatMap((entry) => {
      return entry.stages.length >  ? entry.stages.filter((x) => x) : entry;
    });
  }
  [Symbol.iterator]() {
    for (const entry of this.entries) {
      yield entry;
    }
  }
  insert({ filepath, stats, oid, stage =  }) {
    if (!stats) {
      stats = {
        ctimeSeconds: ,
        ctimeNanoseconds: ,
        mtimeSeconds: ,
        mtimeNanoseconds: ,
        dev: ,
        ino: ,
        mode: ,
        uid: ,
        gid: ,
        size: 
      };
    }
    stats = normalizeStats(stats);
    const bfilepath = Buffer.from(filepath);
    const entry = {
      ctimeSeconds: stats.ctimeSeconds,
      ctimeNanoseconds: stats.ctimeNanoseconds,
      mtimeSeconds: stats.mtimeSeconds,
      mtimeNanoseconds: stats.mtimeNanoseconds,
      dev: stats.dev,
      ino: stats.ino,
      // We provide a fallback value for `mode` here because not all fs
      // implementations assign it, but we use it in GitTree.
      // '' is for a "regular non-executable file"
      mode: stats.mode || ,
      uid: stats.uid,
      gid: stats.gid,
      size: stats.size,
      path: filepath,
      oid,
      flags: {
        assumeValid: false,
        extended: false,
        stage,
        nameLength: bfilepath.length <  ? bfilepath.length : 
      },
      stages: []
    };
    this._addEntry(entry);
    this._dirty = true;
  }
  delete({ filepath }) {
    if (this._entries.has(filepath)) {
      this._entries.delete(filepath);
    } else {
      for (const key of this._entries.keys()) {
        if (key.startsWith(filepath + "/")) {
          this._entries.delete(key);
        }
      }
    }
    if (this._unmergedPaths.has(filepath)) {
      this._unmergedPaths.delete(filepath);
    }
    this._dirty = true;
  }
  clear() {
    this._entries.clear();
    this._dirty = true;
  }
  has({ filepath }) {
    return this._entries.has(filepath);
  }
  render() {
    return this.entries.map((entry) => `${entry.mode.toString()} ${entry.oid}    ${entry.path}`).join("\n");
  }
  static async _entryToBuffer(entry) {
    const bpath = Buffer.from(entry.path);
    const length = Math.ceil(( + bpath.length + ) / )  ;
    const written = Buffer.alloc(length);
    const writer = new BufferCursor(written);
    const stat = normalizeStats(entry);
    writer.writeUIntBE(stat.ctimeSeconds);
    writer.writeUIntBE(stat.ctimeNanoseconds);
    writer.writeUIntBE(stat.mtimeSeconds);
    writer.writeUIntBE(stat.mtimeNanoseconds);
    writer.writeUIntBE(stat.dev);
    writer.writeUIntBE(stat.ino);
    writer.writeUIntBE(stat.mode);
    writer.writeUIntBE(stat.uid);
    writer.writeUIntBE(stat.gid);
    writer.writeUIntBE(stat.size);
    writer.write(entry.oid, , "hex");
    writer.writeUIntBE(renderCacheEntryFlags(entry));
    writer.write(entry.path, bpath.length, "utf");
    return written;
  }
  async toObject() {
    const header = Buffer.alloc();
    const writer = new BufferCursor(header);
    writer.write("DIRC", , "utf");
    writer.writeUIntBE();
    writer.writeUIntBE(this.entriesFlat.length);
    let entryBuffers = [];
    for (const entry of this.entries) {
      entryBuffers.push(GitIndex._entryToBuffer(entry));
      if (entry.stages.length > ) {
        for (const stage of entry.stages) {
          if (stage && stage !== entry) {
            entryBuffers.push(GitIndex._entryToBuffer(stage));
          }
        }
      }
    }
    entryBuffers = await Promise.all(entryBuffers);
    const body = Buffer.concat(entryBuffers);
    const main = Buffer.concat([header, body]);
    const sum = await shasum(main);
    return Buffer.concat([main, Buffer.from(sum, "hex")]);
  }
};
function compareStats(entry, stats) {
  const e = normalizeStats(entry);
  const s = normalizeStats(stats);
  const staleness = e.mode !== s.mode || e.mtimeSeconds !== s.mtimeSeconds || e.ctimeSeconds !== s.ctimeSeconds || e.uid !== s.uid || e.gid !== s.gid || e.ino !== s.ino || e.size !== s.size;
  return staleness;
}
var lock = null;
var IndexCache = Symbol("IndexCache");
function createCache() {
  return {
    map: / @__PURE__ / new Map(),
    stats: / @__PURE__ / new Map()
  };
}
async function updateCachedIndexFile(fs, filepath, cache) {
  const stat = await fs.lstat(filepath);
  const rawIndexFile = await fs.read(filepath);
  const index = await GitIndex.from(rawIndexFile);
  cache.map.set(filepath, index);
  cache.stats.set(filepath, stat);
}
async function isIndexStale(fs, filepath, cache) {
  const savedStats = cache.stats.get(filepath);
  if (savedStats === void )
    return true;
  const currStats = await fs.lstat(filepath);
  if (savedStats === null)
    return false;
  if (currStats === null)
    return false;
  return compareStats(savedStats, currStats);
}
var GitIndexManager = class {
  /
   
    @param {object} opts
    @param {import('../models/FileSystem.js').FileSystem} opts.fs
    @param {string} opts.gitdir
    @param {object} opts.cache
    @param {bool} opts.allowUnmerged
    @param {function(GitIndex): any} closure
   /
  static async acquire({ fs, gitdir, cache, allowUnmerged = true }, closure) {
    if (!cache[IndexCache])
      cache[IndexCache] = createCache();
    const filepath = `${gitdir}/index`;
    if (lock === null)
      lock = new import_async_lock.default({ maxPending: Infinity });
    let result;
    let unmergedPaths = [];
    await lock.acquire(filepath, async () => {
      if (await isIndexStale(fs, filepath, cache[IndexCache])) {
        await updateCachedIndexFile(fs, filepath, cache[IndexCache]);
      }
      const index = cache[IndexCache].map.get(filepath);
      unmergedPaths = index.unmergedPaths;
      if (unmergedPaths.length && !allowUnmerged)
        throw new UnmergedPathsError(unmergedPaths);
      result = await closure(index);
      if (index._dirty) {
        const buffer = await index.toObject();
        await fs.write(filepath, buffer);
        cache[IndexCache].stats.set(filepath, await fs.lstat(filepath));
        index._dirty = false;
      }
    });
    return result;
  }
};
function basename(path) {
  const last = Math.max(path.lastIndexOf("/"), path.lastIndexOf("\\"));
  if (last > -) {
    path = path.slice(last + );
  }
  return path;
}
function dirname(path) {
  const last = Math.max(path.lastIndexOf("/"), path.lastIndexOf("\\"));
  if (last === -)
    return ".";
  if (last === )
    return "/";
  return path.slice(, last);
}
function flatFileListToDirectoryStructure(files) {
  const inodes = / @__PURE__ / new Map();
  const mkdir = function(name) {
    if (!inodes.has(name)) {
      const dir = {
        type: "tree",
        fullpath: name,
        basename: basename(name),
        metadata: {},
        children: []
      };
      inodes.set(name, dir);
      dir.parent = mkdir(dirname(name));
      if (dir.parent && dir.parent !== dir)
        dir.parent.children.push(dir);
    }
    return inodes.get(name);
  };
  const mkfile = function(name, metadata) {
    if (!inodes.has(name)) {
      const file = {
        type: "blob",
        fullpath: name,
        basename: basename(name),
        metadata,
        // This recursively generates any missing parent folders.
        parent: mkdir(dirname(name)),
        children: []
      };
      if (file.parent)
        file.parent.children.push(file);
      inodes.set(name, file);
    }
    return inodes.get(name);
  };
  mkdir(".");
  for (const file of files) {
    mkfile(file.path, file);
  }
  return inodes;
}
function modetype(mode) {
  switch (mode) {
    case :
      return "tree";
    case :
      return "blob";
    case :
      return "blob";
    case :
      return "blob";
    case :
      return "commit";
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode.toString()}`);
}
var GitWalkerIndex = class {
  constructor({ fs, gitdir, cache }) {
    this.treePromise = GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function(index) {
        return flatFileListToDirectoryStructure(index.entries);
      }
    );
    const walker = this;
    this.ConstructEntry = class StageEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._oid = false;
      }
      async type() {
        return walker.type(this);
      }
      async mode() {
        return walker.mode(this);
      }
      async stat() {
        return walker.stat(this);
      }
      async content() {
        return walker.content(this);
      }
      async oid() {
        return walker.oid(this);
      }
    };
  }
  async readdir(entry) {
    const filepath = entry._fullpath;
    const tree = await this.treePromise;
    const inode = tree.get(filepath);
    if (!inode)
      return null;
    if (inode.type === "blob")
      return null;
    if (inode.type !== "tree") {
      throw new Error(`ENOTDIR: not a directory, scandir '${filepath}'`);
    }
    const names = inode.children.map((inode) => inode.fullpath);
    names.sort(compareStrings);
    return names;
  }
  async type(entry) {
    if (entry._type === false) {
      await entry.stat();
    }
    return entry._type;
  }
  async mode(entry) {
    if (entry._mode === false) {
      await entry.stat();
    }
    return entry._mode;
  }
  async stat(entry) {
    if (entry._stat === false) {
      const tree = await this.treePromise;
      const inode = tree.get(entry._fullpath);
      if (!inode) {
        throw new Error(
          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
        );
      }
      const stats = inode.type === "tree" ? {} : normalizeStats(inode.metadata);
      entry._type = inode.type === "tree" ? "tree" : modetype(stats.mode);
      entry._mode = stats.mode;
      if (inode.type === "tree") {
        entry._stat = void ;
      } else {
        entry._stat = stats;
      }
    }
    return entry._stat;
  }
  async content(_entry) {
  }
  async oid(entry) {
    if (entry._oid === false) {
      const tree = await this.treePromise;
      const inode = tree.get(entry._fullpath);
      entry._oid = inode.metadata.oid;
    }
    return entry._oid;
  }
};
var GitWalkSymbol = Symbol("GitWalkSymbol");
function STAGE() {
  const o = / @__PURE__ / Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, gitdir, cache }) {
      return new GitWalkerIndex({ fs, gitdir, cache });
    }
  });
  Object.freeze(o);
  return o;
}
var NotFoundError = class extends BaseError {
  /
    @param {string} what
   /
  constructor(what) {
    super(`Could not find ${what}.`);
    this.code = this.name = NotFoundError.code;
    this.data = { what };
  }
};
NotFoundError.code = "NotFoundError";
var ObjectTypeError = class extends BaseError {
  /
    @param {string} oid
    @param {'blob'|'commit'|'tag'|'tree'} actual
    @param {'blob'|'commit'|'tag'|'tree'} expected
    @param {string} [filepath]
   /
  constructor(oid, actual, expected, filepath) {
    super(
      `Object ${oid} ${filepath ? `at ${filepath}` : ""}was anticipated to be a ${expected} but it is a ${actual}.`
    );
    this.code = this.name = ObjectTypeError.code;
    this.data = { oid, actual, expected, filepath };
  }
};
ObjectTypeError.code = "ObjectTypeError";
var InvalidOidError = class extends BaseError {
  /
    @param {string} value
   /
  constructor(value) {
    super(`Expected a -char hex object id but saw "${value}".`);
    this.code = this.name = InvalidOidError.code;
    this.data = { value };
  }
};
InvalidOidError.code = "InvalidOidError";
var NoRefspecError = class extends BaseError {
  /
    @param {string} remote
   /
  constructor(remote) {
    super(`Could not find a fetch refspec for remote "${remote}". Make sure the config file has an entry like the following:
[remote "${remote}"]
	fetch = +refs/heads/:refs/remotes/origin/
`);
    this.code = this.name = NoRefspecError.code;
    this.data = { remote };
  }
};
NoRefspecError.code = "NoRefspecError";
var GitPackedRefs = class {
  constructor(text) {
    this.refs = / @__PURE__ / new Map();
    this.parsedConfig = [];
    if (text) {
      let key = null;
      this.parsedConfig = text.trim().split("\n").map((line) => {
        if (/^\s/.test(line)) {
          return { line, comment: true };
        }
        const i = line.indexOf(" ");
        if (line.startsWith("^")) {
          const value = line.slice();
          this.refs.set(key + "^{}", value);
          return { line, ref: key, peeled: value };
        } else {
          const value = line.slice(, i);
          key = line.slice(i + );
          this.refs.set(key, value);
          return { line, ref: key, oid: value };
        }
      });
    }
    return this;
  }
  static from(text) {
    return new GitPackedRefs(text);
  }
  delete(ref) {
    this.parsedConfig = this.parsedConfig.filter((entry) => entry.ref !== ref);
    this.refs.delete(ref);
  }
  toString() {
    return this.parsedConfig.map(({ line }) => line).join("\n") + "\n";
  }
};
var GitRefSpec = class {
  constructor({ remotePath, localPath, force, matchPrefix }) {
    Object.assign(this, {
      remotePath,
      localPath,
      force,
      matchPrefix
    });
  }
  static from(refspec) {
    const [
      forceMatch,
      remotePath,
      remoteGlobMatch,
      localPath,
      localGlobMatch
    ] = refspec.match(/^(\+?)(.?)(\?):(.?)(\?)$/).slice();
    const force = forceMatch === "+";
    const remoteIsGlob = remoteGlobMatch === "";
    const localIsGlob = localGlobMatch === "";
    if (remoteIsGlob !== localIsGlob) {
      throw new InternalError("Invalid refspec");
    }
    return new GitRefSpec({
      remotePath,
      localPath,
      force,
      matchPrefix: remoteIsGlob
    });
  }
  translate(remoteBranch) {
    if (this.matchPrefix) {
      if (remoteBranch.startsWith(this.remotePath)) {
        return this.localPath + remoteBranch.replace(this.remotePath, "");
      }
    } else {
      if (remoteBranch === this.remotePath)
        return this.localPath;
    }
    return null;
  }
  reverseTranslate(localBranch) {
    if (this.matchPrefix) {
      if (localBranch.startsWith(this.localPath)) {
        return this.remotePath + localBranch.replace(this.localPath, "");
      }
    } else {
      if (localBranch === this.localPath)
        return this.remotePath;
    }
    return null;
  }
};
var GitRefSpecSet = class {
  constructor(rules = []) {
    this.rules = rules;
  }
  static from(refspecs) {
    const rules = [];
    for (const refspec of refspecs) {
      rules.push(GitRefSpec.from(refspec));
    }
    return new GitRefSpecSet(rules);
  }
  add(refspec) {
    const rule = GitRefSpec.from(refspec);
    this.rules.push(rule);
  }
  translate(remoteRefs) {
    const result = [];
    for (const rule of this.rules) {
      for (const remoteRef of remoteRefs) {
        const localRef = rule.translate(remoteRef);
        if (localRef) {
          result.push([remoteRef, localRef]);
        }
      }
    }
    return result;
  }
  translateOne(remoteRef) {
    let result = null;
    for (const rule of this.rules) {
      const localRef = rule.translate(remoteRef);
      if (localRef) {
        result = localRef;
      }
    }
    return result;
  }
  localNamespaces() {
    return this.rules.filter((rule) => rule.matchPrefix).map((rule) => rule.localPath.replace(/\/$/, ""));
  }
};
function compareRefNames(a, b) {
  const _a = a.replace(/\^\{\}$/, "");
  const _b = b.replace(/\^\{\}$/, "");
  const tmp = -(_a < _b) || +(_a > _b);
  if (tmp === ) {
    return a.endsWith("^{}") ?  : -;
  }
  return tmp;
}
function normalizePath(path) {
  return path.replace(/\/\.\//g, "/").replace(/\/{,}/g, "/").replace(/^\/\.$/, "/").replace(/^\.\/$/, ".").replace(/^\.\//, "").replace(/\/\.$/, "").replace(/(.+)\/$/, "$").replace(/^$/, ".");
}
function join(...parts) {
  return normalizePath(parts.map(normalizePath).join("/"));
}
var num = (val) => {
  val = val.toLowerCase();
  let n = parseInt(val);
  if (val.endsWith("k"))
    n = ;
  if (val.endsWith("m"))
    n =   ;
  if (val.endsWith("g"))
    n =     ;
  return n;
};
var bool = (val) => {
  val = val.trim().toLowerCase();
  if (val === "true" || val === "yes" || val === "on")
    return true;
  if (val === "false" || val === "no" || val === "off")
    return false;
  throw Error(
    `Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${val}`
  );
};
var schema = {
  core: {
    filemode: bool,
    bare: bool,
    logallrefupdates: bool,
    symlinks: bool,
    ignorecase: bool,
    bigFileThreshold: num
  }
};
var SECTION_LINE_REGEX = /^\[([A-Za-z--.]+)(?: "(.)")?\]$/;
var SECTION_REGEX = /^[A-Za-z--.]+$/;
var VARIABLE_LINE_REGEX = /^([A-Za-z][A-Za-z-])(?: = (.))?$/;
var VARIABLE_NAME_REGEX = /^[A-Za-z][A-Za-z-]$/;
var VARIABLE_VALUE_COMMENT_REGEX = /^(.?)( [;].)$/;
var extractSectionLine = (line) => {
  const matches = SECTION_LINE_REGEX.exec(line);
  if (matches != null) {
    const [section, subsection] = matches.slice();
    return [section, subsection];
  }
  return null;
};
var extractVariableLine = (line) => {
  const matches = VARIABLE_LINE_REGEX.exec(line);
  if (matches != null) {
    const [name, rawValue = "true"] = matches.slice();
    const valueWithoutComments = removeComments(rawValue);
    const valueWithoutQuotes = removeQuotes(valueWithoutComments);
    return [name, valueWithoutQuotes];
  }
  return null;
};
var removeComments = (rawValue) => {
  const commentMatches = VARIABLE_VALUE_COMMENT_REGEX.exec(rawValue);
  if (commentMatches == null) {
    return rawValue;
  }
  const [valueWithoutComment, comment] = commentMatches.slice();
  if (hasOddNumberOfQuotes(valueWithoutComment) && hasOddNumberOfQuotes(comment)) {
    return `${valueWithoutComment}${comment}`;
  }
  return valueWithoutComment;
};
var hasOddNumberOfQuotes = (text) => {
  const numberOfQuotes = (text.match(/(?:^|[^\\])"/g) || []).length;
  return numberOfQuotes %  !== ;
};
var removeQuotes = (text) => {
  return text.split("").reduce((newText, c, idx, text) => {
    const isQuote = c === '"' && text[idx - ] !== "\\";
    const isEscapeForQuote = c === "\\" && text[idx + ] === '"';
    if (isQuote || isEscapeForQuote) {
      return newText;
    }
    return newText + c;
  }, "");
};
var lower = (text) => {
  return text != null ? text.toLowerCase() : null;
};
var getPath = (section, subsection, name) => {
  return [lower(section), subsection, lower(name)].filter((a) => a != null).join(".");
};
var normalizePath$ = (path) => {
  const pathSegments = path.split(".");
  const section = pathSegments.shift();
  const name = pathSegments.pop();
  const subsection = pathSegments.length ? pathSegments.join(".") : void ;
  return {
    section,
    subsection,
    name,
    path: getPath(section, subsection, name),
    sectionPath: getPath(section, subsection, null)
  };
};
var findLastIndex = (array, callback) => {
  return array.reduce((lastIndex, item, index) => {
    return callback(item) ? index : lastIndex;
  }, -);
};
var GitConfig = class {
  constructor(text) {
    let section = null;
    let subsection = null;
    this.parsedConfig = text.split("\n").map((line) => {
      let name = null;
      let value = null;
      const trimmedLine = line.trim();
      const extractedSection = extractSectionLine(trimmedLine);
      const isSection = extractedSection != null;
      if (isSection) {
        ;
        [section, subsection] = extractedSection;
      } else {
        const extractedVariable = extractVariableLine(trimmedLine);
        const isVariable = extractedVariable != null;
        if (isVariable) {
          ;
          [name, value] = extractedVariable;
        }
      }
      const path = getPath(section, subsection, name);
      return { line, isSection, section, subsection, name, value, path: path };
    });
  }
  static from(text) {
    return new GitConfig(text);
  }
  async get(path, getall = false) {
    const normalizedPath = normalizePath$(path).path;
    const allValues = this.parsedConfig.filter((config) => config.path === normalizedPath).map(({ section, name, value }) => {
      const fn = schema[section] && schema[section][name];
      return fn ? fn(value) : value;
    });
    return getall ? allValues : allValues.pop();
  }
  async getall(path) {
    return this.get(path, true);
  }
  async getSubsections(section) {
    return this.parsedConfig.filter((config) => config.section === section && config.isSection).map((config) => config.subsection);
  }
  async deleteSection(section, subsection) {
    this.parsedConfig = this.parsedConfig.filter(
      (config) => !(config.section === section && config.subsection === subsection)
    );
  }
  async append(path, value) {
    return this.set(path, value, true);
  }
  async set(path, value, append = false) {
    const {
      section,
      subsection,
      name,
      path: normalizedPath,
      sectionPath
    } = normalizePath$(path);
    const configIndex = findLastIndex(
      this.parsedConfig,
      (config) => config.path === normalizedPath
    );
    if (value == null) {
      if (configIndex !== -) {
        this.parsedConfig.splice(configIndex, );
      }
    } else {
      if (configIndex !== -) {
        const config = this.parsedConfig[configIndex];
        const modifiedConfig = Object.assign({}, config, {
          name,
          value,
          modified: true
        });
        if (append) {
          this.parsedConfig.splice(configIndex + , , modifiedConfig);
        } else {
          this.parsedConfig[configIndex] = modifiedConfig;
        }
      } else {
        const sectionIndex = this.parsedConfig.findIndex(
          (config) => config.path === sectionPath
        );
        const newConfig = {
          section,
          subsection,
          name,
          value,
          modified: true,
          path: normalizedPath
        };
        if (SECTION_REGEX.test(section) && VARIABLE_NAME_REGEX.test(name)) {
          if (sectionIndex >= ) {
            this.parsedConfig.splice(sectionIndex + , , newConfig);
          } else {
            const newSection = {
              section,
              subsection,
              modified: true,
              path: sectionPath
            };
            this.parsedConfig.push(newSection, newConfig);
          }
        }
      }
    }
  }
  toString() {
    return this.parsedConfig.map(({ line, section, subsection, name, value, modified: modified = false }) => {
      if (!modified) {
        return line;
      }
      if (name != null && value != null) {
        if (typeof value === "string" && /[;]/.test(value)) {
          return `	${name} = "${value}"`;
        }
        return `	${name} = ${value}`;
      }
      if (subsection != null) {
        return `[${section} "${subsection}"]`;
      }
      return `[${section}]`;
    }).join("\n");
  }
};
var GitConfigManager = class {
  static async get({ fs, gitdir }) {
    const text = await fs.read(`${gitdir}/config`, { encoding: "utf" });
    return GitConfig.from(text);
  }
  static async save({ fs, gitdir, config }) {
    await fs.write(`${gitdir}/config`, config.toString(), {
      encoding: "utf"
    });
  }
};
var refpaths = (ref) => [
  `${ref}`,
  `refs/${ref}`,
  `refs/tags/${ref}`,
  `refs/heads/${ref}`,
  `refs/remotes/${ref}`,
  `refs/remotes/${ref}/HEAD`
];
var GIT_FILES = ["config", "description", "index", "shallow", "commondir"];
var GitRefManager = class {
  static async updateRemoteRefs({
    fs,
    gitdir,
    remote,
    refs,
    symrefs,
    tags,
    refspecs = void ,
    prune = false,
    pruneTags = false
  }) {
    for (const value of refs.values()) {
      if (!value.match(/[-a-f]{}/)) {
        throw new InvalidOidError(value);
      }
    }
    const config = await GitConfigManager.get({ fs, gitdir });
    if (!refspecs) {
      refspecs = await config.getall(`remote.${remote}.fetch`);
      if (refspecs.length === ) {
        throw new NoRefspecError(remote);
      }
      refspecs.unshift(`+HEAD:refs/remotes/${remote}/HEAD`);
    }
    const refspec = GitRefSpecSet.from(refspecs);
    const actualRefsToWrite = / @__PURE__ / new Map();
    if (pruneTags) {
      const tags = await GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: "refs/tags"
      });
      await GitRefManager.deleteRefs({
        fs,
        gitdir,
        refs: tags.map((tag) => `refs/tags/${tag}`)
      });
    }
    if (tags) {
      for (const serverRef of refs.keys()) {
        if (serverRef.startsWith("refs/tags") && !serverRef.endsWith("^{}")) {
          if (!await GitRefManager.exists({ fs, gitdir, ref: serverRef })) {
            const oid = refs.get(serverRef);
            actualRefsToWrite.set(serverRef, oid);
          }
        }
      }
    }
    const refTranslations = refspec.translate([...refs.keys()]);
    for (const [serverRef, translatedRef] of refTranslations) {
      const value = refs.get(serverRef);
      actualRefsToWrite.set(translatedRef, value);
    }
    const symrefTranslations = refspec.translate([...symrefs.keys()]);
    for (const [serverRef, translatedRef] of symrefTranslations) {
      const value = symrefs.get(serverRef);
      const symtarget = refspec.translateOne(value);
      if (symtarget) {
        actualRefsToWrite.set(translatedRef, `ref: ${symtarget}`);
      }
    }
    const pruned = [];
    if (prune) {
      for (const filepath of refspec.localNamespaces()) {
        const refs = (await GitRefManager.listRefs({
          fs,
          gitdir,
          filepath
        })).map((file) => `${filepath}/${file}`);
        for (const ref of refs) {
          if (!actualRefsToWrite.has(ref)) {
            pruned.push(ref);
          }
        }
      }
      if (pruned.length > ) {
        await GitRefManager.deleteRefs({ fs, gitdir, refs: pruned });
      }
    }
    for (const [key, value] of actualRefsToWrite) {
      await fs.write(join(gitdir, key), `${value.trim()}
`, "utf");
    }
    return { pruned };
  }
  // TODO: make this less crude?
  static async writeRef({ fs, gitdir, ref, value }) {
    if (!value.match(/[-a-f]{}/)) {
      throw new InvalidOidError(value);
    }
    await fs.write(join(gitdir, ref), `${value.trim()}
`, "utf");
  }
  static async writeSymbolicRef({ fs, gitdir, ref, value }) {
    await fs.write(join(gitdir, ref), `ref: ${value.trim()}
`, "utf");
  }
  static async deleteRef({ fs, gitdir, ref }) {
    return GitRefManager.deleteRefs({ fs, gitdir, refs: [ref] });
  }
  static async deleteRefs({ fs, gitdir, refs }) {
    await Promise.all(refs.map((ref) => fs.rm(join(gitdir, ref))));
    let text = await fs.read(`${gitdir}/packed-refs`, { encoding: "utf" });
    const packed = GitPackedRefs.from(text);
    const beforeSize = packed.refs.size;
    for (const ref of refs) {
      if (packed.refs.has(ref)) {
        packed.delete(ref);
      }
    }
    if (packed.refs.size < beforeSize) {
      text = packed.toString();
      await fs.write(`${gitdir}/packed-refs`, text, { encoding: "utf" });
    }
  }
  /
    @param {object} args
    @param {import('../models/FileSystem.js').FileSystem} args.fs
    @param {string} args.gitdir
    @param {string} args.ref
    @param {number} [args.depth]
    @returns {Promise<string>}
   /
  static async resolve({ fs, gitdir, ref, depth = void  }) {
    if (depth !== void ) {
      depth--;
      if (depth === -) {
        return ref;
      }
    }
    let sha;
    if (ref.startsWith("ref: ")) {
      ref = ref.slice("ref: ".length);
      return GitRefManager.resolve({ fs, gitdir, ref, depth });
    }
    if (ref.length ===  && /[-a-f]{}/.test(ref)) {
      return ref;
    }
    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });
    const allpaths = refpaths(ref).filter((p) => !GIT_FILES.includes(p));
    for (const ref of allpaths) {
      sha = await fs.read(`${gitdir}/${ref}`, { encoding: "utf" }) || packedMap.get(ref);
      if (sha) {
        return GitRefManager.resolve({ fs, gitdir, ref: sha.trim(), depth });
      }
    }
    throw new NotFoundError(ref);
  }
  static async exists({ fs, gitdir, ref }) {
    try {
      await GitRefManager.expand({ fs, gitdir, ref });
      return true;
    } catch (err) {
      return false;
    }
  }
  static async expand({ fs, gitdir, ref }) {
    if (ref.length ===  && /[-a-f]{}/.test(ref)) {
      return ref;
    }
    const packedMap = await GitRefManager.packedRefs({ fs, gitdir });
    const allpaths = refpaths(ref);
    for (const ref of allpaths) {
      if (await fs.exists(`${gitdir}/${ref}`))
        return ref;
      if (packedMap.has(ref))
        return ref;
    }
    throw new NotFoundError(ref);
  }
  static async expandAgainstMap({ ref, map }) {
    const allpaths = refpaths(ref);
    for (const ref of allpaths) {
      if (await map.has(ref))
        return ref;
    }
    throw new NotFoundError(ref);
  }
  static resolveAgainstMap({ ref, fullref = ref, depth = void , map }) {
    if (depth !== void ) {
      depth--;
      if (depth === -) {
        return { fullref, oid: ref };
      }
    }
    if (ref.startsWith("ref: ")) {
      ref = ref.slice("ref: ".length);
      return GitRefManager.resolveAgainstMap({ ref, fullref, depth, map });
    }
    if (ref.length ===  && /[-a-f]{}/.test(ref)) {
      return { fullref, oid: ref };
    }
    const allpaths = refpaths(ref);
    for (const ref of allpaths) {
      const sha = map.get(ref);
      if (sha) {
        return GitRefManager.resolveAgainstMap({
          ref: sha.trim(),
          fullref: ref,
          depth,
          map
        });
      }
    }
    throw new NotFoundError(ref);
  }
  static async packedRefs({ fs, gitdir }) {
    const text = await fs.read(`${gitdir}/packed-refs`, { encoding: "utf" });
    const packed = GitPackedRefs.from(text);
    return packed.refs;
  }
  // List all the refs that match the `filepath` prefix
  static async listRefs({ fs, gitdir, filepath }) {
    const packedMap = GitRefManager.packedRefs({ fs, gitdir });
    let files = null;
    try {
      files = await fs.readdirDeep(`${gitdir}/${filepath}`);
      files = files.map((x) => x.replace(`${gitdir}/${filepath}/`, ""));
    } catch (err) {
      files = [];
    }
    for (let key of (await packedMap).keys()) {
      if (key.startsWith(filepath)) {
        key = key.replace(filepath + "/", "");
        if (!files.includes(key)) {
          files.push(key);
        }
      }
    }
    files.sort(compareRefNames);
    return files;
  }
  static async listBranches({ fs, gitdir, remote }) {
    if (remote) {
      return GitRefManager.listRefs({
        fs,
        gitdir,
        filepath: `refs/remotes/${remote}`
      });
    } else {
      return GitRefManager.listRefs({ fs, gitdir, filepath: `refs/heads` });
    }
  }
  static async listTags({ fs, gitdir }) {
    const tags = await GitRefManager.listRefs({
      fs,
      gitdir,
      filepath: `refs/tags`
    });
    return tags.filter((x) => !x.endsWith("^{}"));
  }
};
function compareTreeEntryPath(a, b) {
  return compareStrings(appendSlashIfDir(a), appendSlashIfDir(b));
}
function appendSlashIfDir(entry) {
  return entry.mode === "" ? entry.path + "/" : entry.path;
}
function modetype$(mode) {
  switch (mode) {
    case "":
      return "tree";
    case "":
      return "blob";
    case "":
      return "blob";
    case "":
      return "blob";
    case "":
      return "commit";
  }
  throw new InternalError(`Unexpected GitTree entry mode: ${mode}`);
}
function parseBuffer(buffer) {
  const _entries = [];
  let cursor = ;
  while (cursor < buffer.length) {
    const space = buffer.indexOf(, cursor);
    if (space === -) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next space character.`
      );
    }
    const nullchar = buffer.indexOf(, cursor);
    if (nullchar === -) {
      throw new InternalError(
        `GitTree: Error parsing buffer at byte location ${cursor}: Could not find the next null character.`
      );
    }
    let mode = buffer.slice(cursor, space).toString("utf");
    if (mode === "")
      mode = "";
    const type = modetype$(mode);
    const path = buffer.slice(space + , nullchar).toString("utf");
    if (path.includes("\\") || path.includes("/")) {
      throw new UnsafeFilepathError(path);
    }
    const oid = buffer.slice(nullchar + , nullchar + ).toString("hex");
    cursor = nullchar + ;
    _entries.push({ mode, path: path, oid, type });
  }
  return _entries;
}
function limitModeToAllowed(mode) {
  if (typeof mode === "number") {
    mode = mode.toString();
  }
  if (mode.match(/^?./))
    return "";
  if (mode.match(/^./))
    return "";
  if (mode.match(/^./))
    return "";
  if (mode.match(/^./))
    return "";
  if (mode.match(/^./))
    return "";
  throw new InternalError(`Could not understand file mode: ${mode}`);
}
function nudgeIntoShape(entry) {
  if (!entry.oid && entry.sha) {
    entry.oid = entry.sha;
  }
  entry.mode = limitModeToAllowed(entry.mode);
  if (!entry.type) {
    entry.type = modetype$(entry.mode);
  }
  return entry;
}
var GitTree = class {
  constructor(entries) {
    if (Buffer.isBuffer(entries)) {
      this._entries = parseBuffer(entries);
    } else if (Array.isArray(entries)) {
      this._entries = entries.map(nudgeIntoShape);
    } else {
      throw new InternalError("invalid type passed to GitTree constructor");
    }
    this._entries.sort(comparePath);
  }
  static from(tree) {
    return new GitTree(tree);
  }
  render() {
    return this._entries.map((entry) => `${entry.mode} ${entry.type} ${entry.oid}    ${entry.path}`).join("\n");
  }
  toObject() {
    const entries = [...this._entries];
    entries.sort(compareTreeEntryPath);
    return Buffer.concat(
      entries.map((entry) => {
        const mode = Buffer.from(entry.mode.replace(/^/, ""));
        const space = Buffer.from(" ");
        const path = Buffer.from(entry.path, "utf");
        const nullchar = Buffer.from([]);
        const oid = Buffer.from(entry.oid, "hex");
        return Buffer.concat([mode, space, path, nullchar, oid]);
      })
    );
  }
  /
    @returns {TreeEntry[]}
   /
  entries() {
    return this._entries;
  }
  [Symbol.iterator]() {
    for (const entry of this._entries) {
      yield entry;
    }
  }
};
var GitObject = class {
  static wrap({ type, object }) {
    return Buffer.concat([
      Buffer.from(`${type} ${object.byteLength.toString()}\`),
      Buffer.from(object)
    ]);
  }
  static unwrap(buffer) {
    const s = buffer.indexOf();
    const i = buffer.indexOf();
    const type = buffer.slice(, s).toString("utf");
    const length = buffer.slice(s + , i).toString("utf");
    const actualLength = buffer.length - (i + );
    if (parseInt(length) !== actualLength) {
      throw new InternalError(
        `Length mismatch: expected ${length} bytes but got ${actualLength} instead.`
      );
    }
    return {
      type,
      object: Buffer.from(buffer.slice(i + ))
    };
  }
};
async function readObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(, )}/${oid.slice()}`;
  const file = await fs.read(`${gitdir}/${source}`);
  if (!file) {
    return null;
  }
  return { object: file, format: "deflated", source };
}
function applyDelta(delta, source) {
  const reader = new BufferCursor(delta);
  const sourceSize = readVarIntLE(reader);
  if (sourceSize !== source.byteLength) {
    throw new InternalError(
      `applyDelta expected source buffer to be ${sourceSize} bytes but the provided buffer was ${source.length} bytes`
    );
  }
  const targetSize = readVarIntLE(reader);
  let target;
  const firstOp = readOp(reader, source);
  if (firstOp.byteLength === targetSize) {
    target = firstOp;
  } else {
    target = Buffer.alloc(targetSize);
    const writer = new BufferCursor(target);
    writer.copy(firstOp);
    while (!reader.eof()) {
      writer.copy(readOp(reader, source));
    }
    const tell = writer.tell();
    if (targetSize !== tell) {
      throw new InternalError(
        `applyDelta expected target buffer to be ${targetSize} bytes but the resulting buffer was ${tell} bytes`
      );
    }
  }
  return target;
}
function readVarIntLE(reader) {
  let result = ;
  let shift = ;
  let byte = null;
  do {
    byte = reader.readUInt();
    result |= (byte & ) << shift;
    shift += ;
  } while (byte & );
  return result;
}
function readCompactLE(reader, flags, size) {
  let result = ;
  let shift = ;
  while (size--) {
    if (flags & ) {
      result |= reader.readUInt() << shift;
    }
    flags >>= ;
    shift += ;
  }
  return result;
}
function readOp(reader, source) {
  const byte = reader.readUInt();
  const COPY = ;
  const OFFS = ;
  const SIZE = ;
  if (byte & COPY) {
    const offset = readCompactLE(reader, byte & OFFS, );
    let size = readCompactLE(reader, (byte & SIZE) >> , );
    if (size === )
      size = ;
    return source.slice(offset, offset + size);
  } else {
    return reader.slice(byte);
  }
}
function fromValue(value) {
  let queue = [value];
  return {
    next() {
      return Promise.resolve({ done: queue.length === , value: queue.pop() });
    },
    return() {
      queue = [];
      return {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function getIterator(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]();
  }
  if (iterable[Symbol.iterator]) {
    return iterable[Symbol.iterator]();
  }
  if (iterable.next) {
    return iterable;
  }
  return fromValue(iterable);
}
var StreamReader = class {
  constructor(stream) {
    this.stream = getIterator(stream);
    this.buffer = null;
    this.cursor = ;
    this.undoCursor = ;
    this.started = false;
    this._ended = false;
    this._discardedBytes = ;
  }
  eof() {
    return this._ended && this.cursor === this.buffer.length;
  }
  tell() {
    return this._discardedBytes + this.cursor;
  }
  async byte() {
    if (this.eof())
      return;
    if (!this.started)
      await this._init();
    if (this.cursor === this.buffer.length) {
      await this._loadnext();
      if (this._ended)
        return;
    }
    this._moveCursor();
    return this.buffer[this.undoCursor];
  }
  async chunk() {
    if (this.eof())
      return;
    if (!this.started)
      await this._init();
    if (this.cursor === this.buffer.length) {
      await this._loadnext();
      if (this._ended)
        return;
    }
    this._moveCursor(this.buffer.length);
    return this.buffer.slice(this.undoCursor, this.cursor);
  }
  async read(n) {
    if (this.eof())
      return;
    if (!this.started)
      await this._init();
    if (this.cursor + n > this.buffer.length) {
      this._trim();
      await this._accumulate(n);
    }
    this._moveCursor(n);
    return this.buffer.slice(this.undoCursor, this.cursor);
  }
  async skip(n) {
    if (this.eof())
      return;
    if (!this.started)
      await this._init();
    if (this.cursor + n > this.buffer.length) {
      this._trim();
      await this._accumulate(n);
    }
    this._moveCursor(n);
  }
  async undo() {
    this.cursor = this.undoCursor;
  }
  async _next() {
    this.started = true;
    let { done, value } = await this.stream.next();
    if (done) {
      this._ended = true;
    }
    if (value) {
      value = Buffer.from(value);
    }
    return value;
  }
  _trim() {
    this.buffer = this.buffer.slice(this.undoCursor);
    this.cursor -= this.undoCursor;
    this._discardedBytes += this.undoCursor;
    this.undoCursor = ;
  }
  _moveCursor(n) {
    this.undoCursor = this.cursor;
    this.cursor += n;
    if (this.cursor > this.buffer.length) {
      this.cursor = this.buffer.length;
    }
  }
  async _accumulate(n) {
    if (this._ended)
      return;
    const buffers = [this.buffer];
    while (this.cursor + n > lengthBuffers(buffers)) {
      const nextbuffer = await this._next();
      if (this._ended)
        break;
      buffers.push(nextbuffer);
    }
    this.buffer = Buffer.concat(buffers);
  }
  async _loadnext() {
    this._discardedBytes += this.buffer.length;
    this.undoCursor = ;
    this.cursor = ;
    this.buffer = await this._next();
  }
  async _init() {
    this.buffer = await this._next();
  }
};
function lengthBuffers(buffers) {
  return buffers.reduce((acc, buffer) => acc + buffer.length, );
}
async function listpack(stream, onData) {
  const reader = new StreamReader(stream);
  let PACK = await reader.read();
  PACK = PACK.toString("utf");
  if (PACK !== "PACK") {
    throw new InternalError(`Invalid PACK header '${PACK}'`);
  }
  let version = await reader.read();
  version = version.readUIntBE();
  if (version !== ) {
    throw new InternalError(`Invalid packfile version: ${version}`);
  }
  let numObjects = await reader.read();
  numObjects = numObjects.readUIntBE();
  if (numObjects < )
    return;
  while (!reader.eof() && numObjects--) {
    const offset = reader.tell();
    const { type, length, ofs, reference } = await parseHeader(reader);
    const inflator = new import_pako.default.Inflate();
    while (!inflator.result) {
      const chunk = await reader.chunk();
      if (!chunk)
        break;
      inflator.push(chunk, false);
      if (inflator.err) {
        throw new InternalError(`Pako error: ${inflator.msg}`);
      }
      if (inflator.result) {
        if (inflator.result.length !== length) {
          throw new InternalError(
            `Inflated object size is different from that stated in packfile.`
          );
        }
        await reader.undo();
        await reader.read(chunk.length - inflator.strm.avail_in);
        const end = reader.tell();
        await onData({
          data: inflator.result,
          type,
          num: numObjects,
          offset,
          end,
          reference,
          ofs
        });
      }
    }
  }
}
async function parseHeader(reader) {
  let byte = await reader.byte();
  const type = byte >>  & ;
  let length = byte & ;
  if (byte & ) {
    let shift = ;
    do {
      byte = await reader.byte();
      length |= (byte & ) << shift;
      shift += ;
    } while (byte & );
  }
  let ofs;
  let reference;
  if (type === ) {
    let shift = ;
    ofs = ;
    const bytes = [];
    do {
      byte = await reader.byte();
      ofs |= (byte & ) << shift;
      shift += ;
      bytes.push(byte);
    } while (byte & );
    reference = Buffer.from(bytes);
  }
  if (type === ) {
    const buf = await reader.read();
    reference = buf;
  }
  return { type, length, ofs, reference };
}
var supportsDecompressionStream = false;
async function inflate(buffer) {
  if (supportsDecompressionStream === null) {
    supportsDecompressionStream = testDecompressionStream();
  }
  return supportsDecompressionStream ? browserInflate(buffer) : import_pako.default.inflate(buffer);
}
async function browserInflate(buffer) {
  const ds = new DecompressionStream("deflate");
  const d = new Blob([buffer]).stream().pipeThrough(ds);
  return new UintArray(await new Response(d).arrayBuffer());
}
function testDecompressionStream() {
  try {
    const ds = new DecompressionStream("deflate");
    if (ds)
      return true;
  } catch (_) {
  }
  return false;
}
function decodeVarInt(reader) {
  const bytes = [];
  let byte = ;
  let multibyte = ;
  do {
    byte = reader.readUInt();
    const lastSeven = byte & ;
    bytes.push(lastSeven);
    multibyte = byte & ;
  } while (multibyte);
  return bytes.reduce((a, b) => a +  <<  | b, -);
}
function otherVarIntDecode(reader, startWith) {
  let result = startWith;
  let shift = ;
  let byte = null;
  do {
    byte = reader.readUInt();
    result |= (byte & ) << shift;
    shift += ;
  } while (byte & );
  return result;
}
var GitPackIndex = class {
  constructor(stuff) {
    Object.assign(this, stuff);
    this.offsetCache = {};
  }
  static async fromIdx({ idx, getExternalRefDelta }) {
    const reader = new BufferCursor(idx);
    const magic = reader.slice().toString("hex");
    if (magic !== "fff") {
      return;
    }
    const version = reader.readUIntBE();
    if (version !== ) {
      throw new InternalError(
        `Unable to read version ${version} packfile IDX. (Only version  supported)`
      );
    }
    if (idx.byteLength >     ) {
      throw new InternalError(
        `To keep implementation simple, I haven't implemented the layer  feature needed to support packfiles > GB in size.`
      );
    }
    reader.seek(reader.tell() +   );
    const size = reader.readUIntBE();
    const hashes = [];
    for (let i = ; i < size; i++) {
      const hash = reader.slice().toString("hex");
      hashes[i] = hash;
    }
    reader.seek(reader.tell() +   size);
    const offsets = / @__PURE__ / new Map();
    for (let i = ; i < size; i++) {
      offsets.set(hashes[i], reader.readUIntBE());
    }
    const packfileSha = reader.slice().toString("hex");
    return new GitPackIndex({
      hashes,
      crcs: {},
      offsets,
      packfileSha,
      getExternalRefDelta
    });
  }
  static async fromPack({ pack, getExternalRefDelta, onProgress }) {
    const listpackTypes = {
      : "commit",
      : "tree",
      : "blob",
      : "tag",
      : "ofs-delta",
      : "ref-delta"
    };
    const offsetToObject = {};
    const packfileSha = pack.slice(-).toString("hex");
    const hashes = [];
    const crcs = {};
    const offsets = / @__PURE__ / new Map();
    let totalObjectCount = null;
    let lastPercent = null;
    await listpack([pack], async ({ data, type, reference, offset, num: num }) => {
      if (totalObjectCount === null)
        totalObjectCount = num;
      const percent = Math.floor(
        (totalObjectCount - num)   / totalObjectCount
      );
      if (percent !== lastPercent) {
        if (onProgress) {
          await onProgress({
            phase: "Receiving objects",
            loaded: totalObjectCount - num,
            total: totalObjectCount
          });
        }
      }
      lastPercent = percent;
      type = listpackTypes[type];
      if (["commit", "tree", "blob", "tag"].includes(type)) {
        offsetToObject[offset] = {
          type,
          offset
        };
      } else if (type === "ofs-delta") {
        offsetToObject[offset] = {
          type,
          offset
        };
      } else if (type === "ref-delta") {
        offsetToObject[offset] = {
          type,
          offset
        };
      }
    });
    const offsetArray = Object.keys(offsetToObject).map(Number);
    for (const [i, start] of offsetArray.entries()) {
      const end = i +  === offsetArray.length ? pack.byteLength -  : offsetArray[i + ];
      const o = offsetToObject[start];
      const crc = import_crc_.default.buf(pack.slice(start, end)) >>> ;
      o.end = end;
      o.crc = crc;
    }
    const p = new GitPackIndex({
      pack: Promise.resolve(pack),
      packfileSha,
      crcs,
      hashes,
      offsets,
      getExternalRefDelta
    });
    lastPercent = null;
    let count = ;
    const objectsByDepth = [, , , , , , , , , , , ];
    for (let offset in offsetToObject) {
      offset = Number(offset);
      const percent = Math.floor(count   / totalObjectCount);
      if (percent !== lastPercent) {
        if (onProgress) {
          await onProgress({
            phase: "Resolving deltas",
            loaded: count,
            total: totalObjectCount
          });
        }
      }
      count++;
      lastPercent = percent;
      const o = offsetToObject[offset];
      if (o.oid)
        continue;
      try {
        p.readDepth = ;
        p.externalReadDepth = ;
        const { type, object } = await p.readSlice({ start: offset });
        objectsByDepth[p.readDepth] += ;
        const oid = await shasum(GitObject.wrap({ type, object }));
        o.oid = oid;
        hashes.push(oid);
        offsets.set(oid, offset);
        crcs[oid] = o.crc;
      } catch (err) {
        continue;
      }
    }
    hashes.sort();
    return p;
  }
  async toBuffer() {
    const buffers = [];
    const write = (str, encoding) => {
      buffers.push(Buffer.from(str, encoding));
    };
    write("fff", "hex");
    write("", "hex");
    const fanoutBuffer = new BufferCursor(Buffer.alloc(  ));
    for (let i = ; i < ; i++) {
      let count = ;
      for (const hash of this.hashes) {
        if (parseInt(hash.slice(, ), ) <= i)
          count++;
      }
      fanoutBuffer.writeUIntBE(count);
    }
    buffers.push(fanoutBuffer.buffer);
    for (const hash of this.hashes) {
      write(hash, "hex");
    }
    const crcsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length  ));
    for (const hash of this.hashes) {
      crcsBuffer.writeUIntBE(this.crcs[hash]);
    }
    buffers.push(crcsBuffer.buffer);
    const offsetsBuffer = new BufferCursor(Buffer.alloc(this.hashes.length  ));
    for (const hash of this.hashes) {
      offsetsBuffer.writeUIntBE(this.offsets.get(hash));
    }
    buffers.push(offsetsBuffer.buffer);
    write(this.packfileSha, "hex");
    const totalBuffer = Buffer.concat(buffers);
    const sha = await shasum(totalBuffer);
    const shaBuffer = Buffer.alloc();
    shaBuffer.write(sha, "hex");
    return Buffer.concat([totalBuffer, shaBuffer]);
  }
  async load({ pack }) {
    this.pack = pack;
  }
  async unload() {
    this.pack = null;
  }
  async read({ oid }) {
    if (!this.offsets.get(oid)) {
      if (this.getExternalRefDelta) {
        this.externalReadDepth++;
        return this.getExternalRefDelta(oid);
      } else {
        throw new InternalError(`Could not read object ${oid} from packfile`);
      }
    }
    const start = this.offsets.get(oid);
    return this.readSlice({ start });
  }
  async readSlice({ start }) {
    if (this.offsetCache[start]) {
      return Object.assign({}, this.offsetCache[start]);
    }
    this.readDepth++;
    const types = {
      : "commit",
      : "tree",
      : "blob",
      : "tag",
      : "ofs_delta",
      : "ref_delta"
    };
    if (!this.pack) {
      throw new InternalError(
        "Tried to read from a GitPackIndex with no packfile loaded into memory"
      );
    }
    const raw = (await this.pack).slice(start);
    const reader = new BufferCursor(raw);
    const byte = reader.readUInt();
    const btype = byte & ;
    let type = types[btype];
    if (type === void ) {
      throw new InternalError("Unrecognized type: b" + btype.toString());
    }
    const lastFour = byte & ;
    let length = lastFour;
    const multibyte = byte & ;
    if (multibyte) {
      length = otherVarIntDecode(reader, lastFour);
    }
    let base = null;
    let object = null;
    if (type === "ofs_delta") {
      const offset = decodeVarInt(reader);
      const baseOffset = start - offset;
      ({ object: base, type } = await this.readSlice({ start: baseOffset }));
    }
    if (type === "ref_delta") {
      const oid = reader.slice().toString("hex");
      ({ object: base, type } = await this.read({ oid }));
    }
    const buffer = raw.slice(reader.tell());
    object = Buffer.from(await inflate(buffer));
    if (object.byteLength !== length) {
      throw new InternalError(
        `Packfile told us object would have length ${length} but it had length ${object.byteLength}`
      );
    }
    if (base) {
      object = Buffer.from(applyDelta(object, base));
    }
    if (this.readDepth > ) {
      this.offsetCache[start] = { type, object };
    }
    return { type, format: "content", object };
  }
};
var PackfileCache = Symbol("PackfileCache");
async function loadPackIndex({
  fs,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix
}) {
  const idx = await fs.read(filename);
  return GitPackIndex.fromIdx({ idx, getExternalRefDelta });
}
function readPackIndex({
  fs,
  cache,
  filename,
  getExternalRefDelta,
  emitter,
  emitterPrefix
}) {
  if (!cache[PackfileCache])
    cache[PackfileCache] = / @__PURE__ / new Map();
  let p = cache[PackfileCache].get(filename);
  if (!p) {
    p = loadPackIndex({
      fs,
      filename,
      getExternalRefDelta,
      emitter,
      emitterPrefix
    });
    cache[PackfileCache].set(filename, p);
  }
  return p;
}
async function readObjectPacked({
  fs,
  cache,
  gitdir,
  oid,
  format = "content",
  getExternalRefDelta
}) {
  let list = await fs.readdir(join(gitdir, "objects/pack"));
  list = list.filter((x) => x.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta
    });
    if (p.error)
      throw new InternalError(p.error);
    if (p.offsets.has(oid)) {
      if (!p.pack) {
        const packFile = indexFile.replace(/idx$/, "pack");
        p.pack = fs.read(packFile);
      }
      const result = await p.read({ oid, getExternalRefDelta });
      result.format = "content";
      result.source = `objects/pack/${filename.replace(/idx$/, "pack")}`;
      return result;
    }
  }
  return null;
}
async function _readObject({
  fs,
  cache,
  gitdir,
  oid,
  format = "content"
}) {
  const getExternalRefDelta = (oid) => _readObject({ fs, cache, gitdir, oid: oid });
  let result;
  if (oid === "bdccbebaebfdfbee") {
    result = { format: "wrapped", object: Buffer.from(`tree \`) };
  }
  if (!result) {
    result = await readObjectLoose({ fs, gitdir, oid });
  }
  if (!result) {
    result = await readObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta
    });
  }
  if (!result) {
    throw new NotFoundError(oid);
  }
  if (format === "deflated") {
    return result;
  }
  if (result.format === "deflated") {
    result.object = Buffer.from(await inflate(result.object));
    result.format = "wrapped";
  }
  if (result.format === "wrapped") {
    if (format === "wrapped" && result.format === "wrapped") {
      return result;
    }
    const sha = await shasum(result.object);
    if (sha !== oid) {
      throw new InternalError(
        `SHA check failed! Expected ${oid}, computed ${sha}`
      );
    }
    const { object, type } = GitObject.unwrap(result.object);
    result.type = type;
    result.object = object;
    result.format = "content";
  }
  if (result.format === "content") {
    if (format === "content")
      return result;
    return;
  }
  throw new InternalError(`invalid format "${result.format}"`);
}
var AlreadyExistsError = class extends BaseError {
  /
    @param {'note'|'remote'|'tag'|'branch'} noun
    @param {string} where
    @param {boolean} canForce
   /
  constructor(noun, where, canForce = true) {
    super(
      `Failed to create ${noun} at ${where} because it already exists.${canForce ? ` (Hint: use 'force: true' parameter to overwrite existing ${noun}.)` : ""}`
    );
    this.code = this.name = AlreadyExistsError.code;
    this.data = { noun, where, canForce };
  }
};
AlreadyExistsError.code = "AlreadyExistsError";
var AmbiguousError = class extends BaseError {
  /
    @param {'oids'|'refs'} nouns
    @param {string} short
    @param {string[]} matches
   /
  constructor(nouns, short, matches) {
    super(
      `Found multiple ${nouns} matching "${short}" (${matches.join(
        ", "
      )}). Use a longer abbreviation length to disambiguate them.`
    );
    this.code = this.name = AmbiguousError.code;
    this.data = { nouns, short, matches };
  }
};
AmbiguousError.code = "AmbiguousError";
var CheckoutConflictError = class extends BaseError {
  /
    @param {string[]} filepaths
   /
  constructor(filepaths) {
    super(
      `Your local changes to the following files would be overwritten by checkout: ${filepaths.join(
        ", "
      )}`
    );
    this.code = this.name = CheckoutConflictError.code;
    this.data = { filepaths };
  }
};
CheckoutConflictError.code = "CheckoutConflictError";
var CommitNotFetchedError = class extends BaseError {
  /
    @param {string} ref
    @param {string} oid
   /
  constructor(ref, oid) {
    super(
      `Failed to checkout "${ref}" because commit ${oid} is not available locally. Do a git fetch to make the branch available locally.`
    );
    this.code = this.name = CommitNotFetchedError.code;
    this.data = { ref, oid };
  }
};
CommitNotFetchedError.code = "CommitNotFetchedError";
var EmptyServerResponseError = class extends BaseError {
  constructor() {
    super(`Empty response from git server.`);
    this.code = this.name = EmptyServerResponseError.code;
    this.data = {};
  }
};
EmptyServerResponseError.code = "EmptyServerResponseError";
var FastForwardError = class extends BaseError {
  constructor() {
    super(`A simple fast-forward merge was not possible.`);
    this.code = this.name = FastForwardError.code;
    this.data = {};
  }
};
FastForwardError.code = "FastForwardError";
var GitPushError = class extends BaseError {
  /
    @param {string} prettyDetails
    @param {PushResult} result
   /
  constructor(prettyDetails, result) {
    super(`One or more branches were not updated: ${prettyDetails}`);
    this.code = this.name = GitPushError.code;
    this.data = { prettyDetails, result };
  }
};
GitPushError.code = "GitPushError";
var HttpError = class extends BaseError {
  /
    @param {number} statusCode
    @param {string} statusMessage
    @param {string} response
   /
  constructor(statusCode, statusMessage, response) {
    super(`HTTP Error: ${statusCode} ${statusMessage}`);
    this.code = this.name = HttpError.code;
    this.data = { statusCode, statusMessage, response };
  }
};
HttpError.code = "HttpError";
var InvalidFilepathError = class extends BaseError {
  /
    @param {'leading-slash'|'trailing-slash'|'directory'} [reason]
   /
  constructor(reason) {
    let message = "invalid filepath";
    if (reason === "leading-slash" || reason === "trailing-slash") {
      message = `"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.`;
    } else if (reason === "directory") {
      message = `"filepath" should not be a directory.`;
    }
    super(message);
    this.code = this.name = InvalidFilepathError.code;
    this.data = { reason };
  }
};
InvalidFilepathError.code = "InvalidFilepathError";
var InvalidRefNameError = class extends BaseError {
  /
    @param {string} ref
    @param {string} suggestion
    @param {boolean} canForce
   /
  constructor(ref, suggestion) {
    super(
      `"${ref}" would be an invalid git reference. (Hint: a valid alternative would be "${suggestion}".)`
    );
    this.code = this.name = InvalidRefNameError.code;
    this.data = { ref, suggestion };
  }
};
InvalidRefNameError.code = "InvalidRefNameError";
var MaxDepthError = class extends BaseError {
  /
    @param {number} depth
   /
  constructor(depth) {
    super(`Maximum search depth of ${depth} exceeded.`);
    this.code = this.name = MaxDepthError.code;
    this.data = { depth };
  }
};
MaxDepthError.code = "MaxDepthError";
var MergeNotSupportedError = class extends BaseError {
  constructor() {
    super(`Merges with conflicts are not supported yet.`);
    this.code = this.name = MergeNotSupportedError.code;
    this.data = {};
  }
};
MergeNotSupportedError.code = "MergeNotSupportedError";
var MergeConflictError = class extends BaseError {
  /
    @param {Array<string>} filepaths
   /
  constructor(filepaths) {
    super(
      `Automatic merge failed with one or more merge conflicts in the following files: ${filepaths.toString()}. Fix conflicts then commit the result.`
    );
    this.code = this.name = MergeConflictError.code;
    this.data = { filepaths };
  }
};
MergeConflictError.code = "MergeConflictError";
var MissingNameError = class extends BaseError {
  /
    @param {'author'|'committer'|'tagger'} role
   /
  constructor(role) {
    super(
      `No name was provided for ${role} in the argument or in the .git/config file.`
    );
    this.code = this.name = MissingNameError.code;
    this.data = { role };
  }
};
MissingNameError.code = "MissingNameError";
var MissingParameterError = class extends BaseError {
  /
    @param {string} parameter
   /
  constructor(parameter) {
    super(
      `The function requires a "${parameter}" parameter but none was provided.`
    );
    this.code = this.name = MissingParameterError.code;
    this.data = { parameter };
  }
};
MissingParameterError.code = "MissingParameterError";
var MultipleGitError = class extends BaseError {
  /
    @param {Error[]} errors
    @param {string} message
   /
  constructor(errors) {
    super(
      `There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more`
    );
    this.code = this.name = MultipleGitError.code;
    this.data = { errors };
    this.errors = errors;
  }
};
MultipleGitError.code = "MultipleGitError";
var ParseError = class extends BaseError {
  /
    @param {string} expected
    @param {string} actual
   /
  constructor(expected, actual) {
    super(`Expected "${expected}" but received "${actual}".`);
    this.code = this.name = ParseError.code;
    this.data = { expected, actual };
  }
};
ParseError.code = "ParseError";
var PushRejectedError = class extends BaseError {
  /
    @param {'not-fast-forward'|'tag-exists'} reason
   /
  constructor(reason) {
    let message = "";
    if (reason === "not-fast-forward") {
      message = " because it was not a simple fast-forward";
    } else if (reason === "tag-exists") {
      message = " because tag already exists";
    }
    super(`Push rejected${message}. Use "force: true" to override.`);
    this.code = this.name = PushRejectedError.code;
    this.data = { reason };
  }
};
PushRejectedError.code = "PushRejectedError";
var RemoteCapabilityError = class extends BaseError {
  /
    @param {'shallow'|'deepen-since'|'deepen-not'|'deepen-relative'} capability
    @param {'depth'|'since'|'exclude'|'relative'} parameter
   /
  constructor(capability, parameter) {
    super(
      `Remote does not support the "${capability}" so the "${parameter}" parameter cannot be used.`
    );
    this.code = this.name = RemoteCapabilityError.code;
    this.data = { capability, parameter };
  }
};
RemoteCapabilityError.code = "RemoteCapabilityError";
var SmartHttpError = class extends BaseError {
  /
    @param {string} preview
    @param {string} response
   /
  constructor(preview, response) {
    super(
      `Remote did not reply using the "smart" HTTP protocol. Expected "e service=git-upload-pack" but received: ${preview}`
    );
    this.code = this.name = SmartHttpError.code;
    this.data = { preview, response };
  }
};
SmartHttpError.code = "SmartHttpError";
var UnknownTransportError = class extends BaseError {
  /
    @param {string} url
    @param {string} transport
    @param {string} [suggestion]
   /
  constructor(url, transport, suggestion) {
    super(
      `Git remote "${url}" uses an unrecognized transport protocol: "${transport}"`
    );
    this.code = this.name = UnknownTransportError.code;
    this.data = { url, transport, suggestion };
  }
};
UnknownTransportError.code = "UnknownTransportError";
var UrlParseError = class extends BaseError {
  /
    @param {string} url
   /
  constructor(url) {
    super(`Cannot parse remote URL: "${url}"`);
    this.code = this.name = UrlParseError.code;
    this.data = { url };
  }
};
UrlParseError.code = "UrlParseError";
var UserCanceledError = class extends BaseError {
  constructor() {
    super(`The operation was canceled.`);
    this.code = this.name = UserCanceledError.code;
    this.data = {};
  }
};
UserCanceledError.code = "UserCanceledError";
var IndexResetError = class extends BaseError {
  /
    @param {Array<string>} filepaths
   /
  constructor(filepath) {
    super(
      `Could not merge index: Entry for '${filepath}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged chages.`
    );
    this.code = this.name = IndexResetError.code;
    this.data = { filepath };
  }
};
IndexResetError.code = "IndexResetError";
var Errors = / @__PURE__ / Object.freeze({
  __proto__: null,
  AlreadyExistsError,
  AmbiguousError,
  CheckoutConflictError,
  CommitNotFetchedError,
  EmptyServerResponseError,
  FastForwardError,
  GitPushError,
  HttpError,
  InternalError,
  InvalidFilepathError,
  InvalidOidError,
  InvalidRefNameError,
  MaxDepthError,
  MergeNotSupportedError,
  MergeConflictError,
  MissingNameError,
  MissingParameterError,
  MultipleGitError,
  NoRefspecError,
  NotFoundError,
  ObjectTypeError,
  ParseError,
  PushRejectedError,
  RemoteCapabilityError,
  SmartHttpError,
  UnknownTransportError,
  UnsafeFilepathError,
  UrlParseError,
  UserCanceledError,
  UnmergedPathsError,
  IndexResetError
});
function formatAuthor({ name, email, timestamp, timezoneOffset }) {
  timezoneOffset = formatTimezoneOffset(timezoneOffset);
  return `${name} <${email}> ${timestamp} ${timezoneOffset}`;
}
function formatTimezoneOffset(minutes) {
  const sign = simpleSign(negateExceptForZero(minutes));
  minutes = Math.abs(minutes);
  const hours = Math.floor(minutes / );
  minutes -= hours  ;
  let strHours = String(hours);
  let strMinutes = String(minutes);
  if (strHours.length < )
    strHours = "" + strHours;
  if (strMinutes.length < )
    strMinutes = "" + strMinutes;
  return (sign === - ? "-" : "+") + strHours + strMinutes;
}
function simpleSign(n) {
  return Math.sign(n) || (Object.is(n, -) ? - : );
}
function negateExceptForZero(n) {
  return n ===  ? n : -n;
}
function normalizeNewlines(str) {
  str = str.replace(/\r/g, "");
  str = str.replace(/^\n+/, "");
  str = str.replace(/\n+$/, "") + "\n";
  return str;
}
function parseAuthor(author) {
  const [, name, email, timestamp, offset] = author.match(
    /^(.) <(.)> (.) (.)$/
  );
  return {
    name,
    email,
    timestamp: Number(timestamp),
    timezoneOffset: parseTimezoneOffset(offset)
  };
}
function parseTimezoneOffset(offset) {
  let [, sign, hours, minutes] = offset.match(/(\+|-)(\d\d)(\d\d)/);
  minutes = (sign === "+" ?  : -)  (Number(hours)   + Number(minutes));
  return negateExceptForZero$(minutes);
}
function negateExceptForZero$(n) {
  return n ===  ? n : -n;
}
var GitAnnotatedTag = class {
  constructor(tag) {
    if (typeof tag === "string") {
      this._tag = tag;
    } else if (Buffer.isBuffer(tag)) {
      this._tag = tag.toString("utf");
    } else if (typeof tag === "object") {
      this._tag = GitAnnotatedTag.render(tag);
    } else {
      throw new InternalError(
        "invalid type passed to GitAnnotatedTag constructor"
      );
    }
  }
  static from(tag) {
    return new GitAnnotatedTag(tag);
  }
  static render(obj) {
    return `object ${obj.object}
type ${obj.type}
tag ${obj.tag}
tagger ${formatAuthor(obj.tagger)}

${obj.message}
${obj.gpgsig ? obj.gpgsig : ""}`;
  }
  justHeaders() {
    return this._tag.slice(, this._tag.indexOf("\n\n"));
  }
  message() {
    const tag = this.withoutSignature();
    return tag.slice(tag.indexOf("\n\n") + );
  }
  parse() {
    return Object.assign(this.headers(), {
      message: this.message(),
      gpgsig: this.gpgsig()
    });
  }
  render() {
    return this._tag;
  }
  headers() {
    const headers = this.justHeaders().split("\n");
    const hs = [];
    for (const h of headers) {
      if (h[] === " ") {
        hs[hs.length - ] += "\n" + h.slice();
      } else {
        hs.push(h);
      }
    }
    const obj = {};
    for (const h of hs) {
      const key = h.slice(, h.indexOf(" "));
      const value = h.slice(h.indexOf(" ") + );
      if (Array.isArray(obj[key])) {
        obj[key].push(value);
      } else {
        obj[key] = value;
      }
    }
    if (obj.tagger) {
      obj.tagger = parseAuthor(obj.tagger);
    }
    if (obj.committer) {
      obj.committer = parseAuthor(obj.committer);
    }
    return obj;
  }
  withoutSignature() {
    const tag = normalizeNewlines(this._tag);
    if (tag.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -)
      return tag;
    return tag.slice(, tag.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----"));
  }
  gpgsig() {
    if (this._tag.indexOf("\n-----BEGIN PGP SIGNATURE-----") === -)
      return;
    const signature = this._tag.slice(
      this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),
      this._tag.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length
    );
    return normalizeNewlines(signature);
  }
  payload() {
    return this.withoutSignature() + "\n";
  }
  toObject() {
    return Buffer.from(this._tag, "utf");
  }
  static async sign(tag, sign, secretKey) {
    const payload = tag.payload();
    let { signature } = await sign({ payload, secretKey });
    signature = normalizeNewlines(signature);
    const signedTag = payload + signature;
    return GitAnnotatedTag.from(signedTag);
  }
};
function indent(str) {
  return str.trim().split("\n").map((x) => " " + x).join("\n") + "\n";
}
function outdent(str) {
  return str.split("\n").map((x) => x.replace(/^ /, "")).join("\n");
}
var GitCommit = class {
  constructor(commit) {
    if (typeof commit === "string") {
      this._commit = commit;
    } else if (Buffer.isBuffer(commit)) {
      this._commit = commit.toString("utf");
    } else if (typeof commit === "object") {
      this._commit = GitCommit.render(commit);
    } else {
      throw new InternalError("invalid type passed to GitCommit constructor");
    }
  }
  static fromPayloadSignature({ payload, signature }) {
    const headers = GitCommit.justHeaders(payload);
    const message = GitCommit.justMessage(payload);
    const commit = normalizeNewlines(
      headers + "\ngpgsig" + indent(signature) + "\n" + message
    );
    return new GitCommit(commit);
  }
  static from(commit) {
    return new GitCommit(commit);
  }
  toObject() {
    return Buffer.from(this._commit, "utf");
  }
  // Todo: allow setting the headers and message
  headers() {
    return this.parseHeaders();
  }
  // Todo: allow setting the headers and message
  message() {
    return GitCommit.justMessage(this._commit);
  }
  parse() {
    return Object.assign({ message: this.message() }, this.headers());
  }
  static justMessage(commit) {
    return normalizeNewlines(commit.slice(commit.indexOf("\n\n") + ));
  }
  static justHeaders(commit) {
    return commit.slice(, commit.indexOf("\n\n"));
  }
  parseHeaders() {
    const headers = GitCommit.justHeaders(this._commit).split("\n");
    const hs = [];
    for (const h of headers) {
      if (h[] === " ") {
        hs[hs.length - ] += "\n" + h.slice();
      } else {
        hs.push(h);
      }
    }
    const obj = {
      parent: []
    };
    for (const h of hs) {
      const key = h.slice(, h.indexOf(" "));
      const value = h.slice(h.indexOf(" ") + );
      if (Array.isArray(obj[key])) {
        obj[key].push(value);
      } else {
        obj[key] = value;
      }
    }
    if (obj.author) {
      obj.author = parseAuthor(obj.author);
    }
    if (obj.committer) {
      obj.committer = parseAuthor(obj.committer);
    }
    return obj;
  }
  static renderHeaders(obj) {
    let headers = "";
    if (obj.tree) {
      headers += `tree ${obj.tree}
`;
    } else {
      headers += `tree bdccbebaebfdfbee
`;
    }
    if (obj.parent) {
      if (obj.parent.length === void ) {
        throw new InternalError(`commit 'parent' property should be an array`);
      }
      for (const p of obj.parent) {
        headers += `parent ${p}
`;
      }
    }
    const author = obj.author;
    headers += `author ${formatAuthor(author)}
`;
    const committer = obj.committer || obj.author;
    headers += `committer ${formatAuthor(committer)}
`;
    if (obj.gpgsig) {
      headers += "gpgsig" + indent(obj.gpgsig);
    }
    return headers;
  }
  static render(obj) {
    return GitCommit.renderHeaders(obj) + "\n" + normalizeNewlines(obj.message);
  }
  render() {
    return this._commit;
  }
  withoutSignature() {
    const commit = normalizeNewlines(this._commit);
    if (commit.indexOf("\ngpgsig") === -)
      return commit;
    const headers = commit.slice(, commit.indexOf("\ngpgsig"));
    const message = commit.slice(
      commit.indexOf("-----END PGP SIGNATURE-----\n") + "-----END PGP SIGNATURE-----\n".length
    );
    return normalizeNewlines(headers + "\n" + message);
  }
  isolateSignature() {
    const signature = this._commit.slice(
      this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),
      this._commit.indexOf("-----END PGP SIGNATURE-----") + "-----END PGP SIGNATURE-----".length
    );
    return outdent(signature);
  }
  static async sign(commit, sign, secretKey) {
    const payload = commit.withoutSignature();
    const message = GitCommit.justMessage(commit._commit);
    let { signature } = await sign({ payload, secretKey });
    signature = normalizeNewlines(signature);
    const headers = GitCommit.justHeaders(commit._commit);
    const signedCommit = headers + "\ngpgsig" + indent(signature) + "\n" + message;
    return GitCommit.from(signedCommit);
  }
};
async function resolveTree({ fs, cache, gitdir, oid }) {
  if (oid === "bdccbebaebfdfbee") {
    return { tree: GitTree.from([]), oid };
  }
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  if (type === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveTree({ fs, cache, gitdir, oid });
  }
  if (type === "commit") {
    oid = GitCommit.from(object).parse().tree;
    return resolveTree({ fs, cache, gitdir, oid });
  }
  if (type !== "tree") {
    throw new ObjectTypeError(oid, type, "tree");
  }
  return { tree: GitTree.from(object), oid };
}
var GitWalkerRepo = class {
  constructor({ fs, gitdir, ref, cache }) {
    this.fs = fs;
    this.cache = cache;
    this.gitdir = gitdir;
    this.mapPromise = (async () => {
      const map = / @__PURE__ / new Map();
      let oid;
      try {
        oid = await GitRefManager.resolve({ fs, gitdir, ref });
      } catch (e) {
        if (e instanceof NotFoundError) {
          oid = "bdccbebaebfdfbee";
        }
      }
      const tree = await resolveTree({ fs, cache: this.cache, gitdir, oid });
      tree.type = "tree";
      tree.mode = "";
      map.set(".", tree);
      return map;
    })();
    const walker = this;
    this.ConstructEntry = class TreeEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._content = false;
        this._oid = false;
      }
      async type() {
        return walker.type(this);
      }
      async mode() {
        return walker.mode(this);
      }
      async stat() {
        return walker.stat(this);
      }
      async content() {
        return walker.content(this);
      }
      async oid() {
        return walker.oid(this);
      }
    };
  }
  async readdir(entry) {
    const filepath = entry._fullpath;
    const { fs, cache, gitdir } = this;
    const map = await this.mapPromise;
    const obj = map.get(filepath);
    if (!obj)
      throw new Error(`No obj for ${filepath}`);
    const oid = obj.oid;
    if (!oid)
      throw new Error(`No oid for obj ${JSON.stringify(obj)}`);
    if (obj.type !== "tree") {
      return null;
    }
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type !== obj.type) {
      throw new ObjectTypeError(oid, type, obj.type);
    }
    const tree = GitTree.from(object);
    for (const entry of tree) {
      map.set(join(filepath, entry.path), entry);
    }
    return tree.entries().map((entry) => join(filepath, entry.path));
  }
  async type(entry) {
    if (entry._type === false) {
      const map = await this.mapPromise;
      const { type } = map.get(entry._fullpath);
      entry._type = type;
    }
    return entry._type;
  }
  async mode(entry) {
    if (entry._mode === false) {
      const map = await this.mapPromise;
      const { mode } = map.get(entry._fullpath);
      entry._mode = normalizeMode(parseInt(mode, ));
    }
    return entry._mode;
  }
  async stat(_entry) {
  }
  async content(entry) {
    if (entry._content === false) {
      const map = await this.mapPromise;
      const { fs, cache, gitdir } = this;
      const obj = map.get(entry._fullpath);
      const oid = obj.oid;
      const { type, object } = await _readObject({ fs, cache, gitdir, oid });
      if (type !== "blob") {
        entry._content = void ;
      } else {
        entry._content = new UintArray(object);
      }
    }
    return entry._content;
  }
  async oid(entry) {
    if (entry._oid === false) {
      const map = await this.mapPromise;
      const obj = map.get(entry._fullpath);
      entry._oid = obj.oid;
    }
    return entry._oid;
  }
};
function TREE({ ref = "HEAD" } = {}) {
  const o = / @__PURE__ / Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, gitdir, cache }) {
      return new GitWalkerRepo({ fs, gitdir, ref, cache });
    }
  });
  Object.freeze(o);
  return o;
}
var GitWalkerFs = class {
  constructor({ fs, dir, gitdir, cache }) {
    this.fs = fs;
    this.cache = cache;
    this.dir = dir;
    this.gitdir = gitdir;
    const walker = this;
    this.ConstructEntry = class WorkdirEntry {
      constructor(fullpath) {
        this._fullpath = fullpath;
        this._type = false;
        this._mode = false;
        this._stat = false;
        this._content = false;
        this._oid = false;
      }
      async type() {
        return walker.type(this);
      }
      async mode() {
        return walker.mode(this);
      }
      async stat() {
        return walker.stat(this);
      }
      async content() {
        return walker.content(this);
      }
      async oid() {
        return walker.oid(this);
      }
    };
  }
  async readdir(entry) {
    const filepath = entry._fullpath;
    const { fs, dir } = this;
    const names = await fs.readdir(join(dir, filepath));
    if (names === null)
      return null;
    return names.map((name) => join(filepath, name));
  }
  async type(entry) {
    if (entry._type === false) {
      await entry.stat();
    }
    return entry._type;
  }
  async mode(entry) {
    if (entry._mode === false) {
      await entry.stat();
    }
    return entry._mode;
  }
  async stat(entry) {
    if (entry._stat === false) {
      const { fs, dir } = this;
      let stat = await fs.lstat(`${dir}/${entry._fullpath}`);
      if (!stat) {
        throw new Error(
          `ENOENT: no such file or directory, lstat '${entry._fullpath}'`
        );
      }
      let type = stat.isDirectory() ? "tree" : "blob";
      if (type === "blob" && !stat.isFile() && !stat.isSymbolicLink()) {
        type = "special";
      }
      entry._type = type;
      stat = normalizeStats(stat);
      entry._mode = stat.mode;
      if (stat.size === - && entry._actualSize) {
        stat.size = entry._actualSize;
      }
      entry._stat = stat;
    }
    return entry._stat;
  }
  async content(entry) {
    if (entry._content === false) {
      const { fs, dir } = this;
      if (await entry.type() === "tree") {
        entry._content = void ;
      } else {
        const content = await fs.read(`${dir}/${entry._fullpath}`);
        entry._actualSize = content.length;
        if (entry._stat && entry._stat.size === -) {
          entry._stat.size = entry._actualSize;
        }
        entry._content = new UintArray(content);
      }
    }
    return entry._content;
  }
  async oid(entry) {
    if (entry._oid === false) {
      const { fs, gitdir, cache } = this;
      let oid;
      await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
        const stage = index.entriesMap.get(entry._fullpath);
        const stats = await entry.stat();
        if (!stage || compareStats(stats, stage)) {
          const content = await entry.content();
          if (content === void ) {
            oid = void ;
          } else {
            oid = await shasum(
              GitObject.wrap({ type: "blob", object: await entry.content() })
            );
            if (stage && oid === stage.oid && stats.mode === stage.mode && compareStats(stats, stage)) {
              index.insert({
                filepath: entry._fullpath,
                stats,
                oid
              });
            }
          }
        } else {
          oid = stage.oid;
        }
      });
      entry._oid = oid;
    }
    return entry._oid;
  }
};
function WORKDIR() {
  const o = / @__PURE__ / Object.create(null);
  Object.defineProperty(o, GitWalkSymbol, {
    value: function({ fs, dir, gitdir, cache }) {
      return new GitWalkerFs({ fs, dir, gitdir, cache });
    }
  });
  Object.freeze(o);
  return o;
}
function arrayRange(start, end) {
  const length = end - start;
  return Array.from({ length }, (_, i) => start + i);
}
var flat = typeof Array.prototype.flat === "undefined" ? (entries) => entries.reduce((acc, x) => acc.concat(x), []) : (entries) => entries.flat();
var RunningMinimum = class {
  constructor() {
    this.value = null;
  }
  consider(value) {
    if (value === null || value === void )
      return;
    if (this.value === null) {
      this.value = value;
    } else if (value < this.value) {
      this.value = value;
    }
  }
  reset() {
    this.value = null;
  }
};
function unionOfIterators(sets) {
  const min = new RunningMinimum();
  let minimum;
  const heads = [];
  const numsets = sets.length;
  for (let i = ; i < numsets; i++) {
    heads[i] = sets[i].next().value;
    if (heads[i] !== void ) {
      min.consider(heads[i]);
    }
  }
  if (min.value === null)
    return;
  while (true) {
    const result = [];
    minimum = min.value;
    min.reset();
    for (let i = ; i < numsets; i++) {
      if (heads[i] !== void  && heads[i] === minimum) {
        result[i] = heads[i];
        heads[i] = sets[i].next().value;
      } else {
        result[i] = null;
      }
      if (heads[i] !== void ) {
        min.consider(heads[i]);
      }
    }
    yield result;
    if (min.value === null)
      return;
  }
}
async function _walk({
  fs,
  cache,
  dir,
  gitdir,
  trees,
  // @ts-ignore
  map = async (_, entry) => entry,
  // The default reducer is a flatmap that filters out undefineds.
  reduce = async (parent, children) => {
    const flatten = flat(children);
    if (parent !== void )
      flatten.unshift(parent);
    return flatten;
  },
  // The default iterate function walks all children concurrently
  iterate = (walk, children) => Promise.all([...children].map(walk))
}) {
  const walkers = trees.map(
    (proxy) => proxy[GitWalkSymbol]({ fs, dir, gitdir, cache })
  );
  const root = new Array(walkers.length).fill(".");
  const range = arrayRange(, walkers.length);
  const unionWalkerFromReaddir = async (entries) => {
    range.map((i) => {
      entries[i] = entries[i] && new walkers[i].ConstructEntry(entries[i]);
    });
    const subdirs = await Promise.all(
      range.map((i) => entries[i] ? walkers[i].readdir(entries[i]) : [])
    );
    const iterators = subdirs.map((array) => array === null ? [] : array).map((array) => array[Symbol.iterator]());
    return {
      entries,
      children: unionOfIterators(iterators)
    };
  };
  const walk = async (root) => {
    const { entries, children: children } = await unionWalkerFromReaddir(root);
    const fullpath = entries.find((entry) => entry && entry._fullpath)._fullpath;
    const parent = await map(fullpath, entries);
    if (parent !== null) {
      let walkedChildren = await iterate(walk, children);
      walkedChildren = walkedChildren.filter((x) => x !== void );
      return reduce(parent, walkedChildren);
    }
  };
  return walk(root);
}
async function rmRecursive(fs, filepath) {
  const entries = await fs.readdir(filepath);
  if (entries == null) {
    await fs.rm(filepath);
  } else if (entries.length) {
    await Promise.all(
      entries.map((entry) => {
        const subpath = join(filepath, entry);
        return fs.lstat(subpath).then((stat) => {
          if (!stat)
            return;
          return stat.isDirectory() ? rmRecursive(fs, subpath) : fs.rm(subpath);
        });
      })
    ).then(() => fs.rmdir(filepath));
  } else {
    await fs.rmdir(filepath);
  }
}
var FileSystem = class {
  constructor(fs) {
    if (typeof fs._original_unwrapped_fs !== "undefined")
      return fs;
    const promises = Object.getOwnPropertyDescriptor(fs, "promises");
    if (promises && promises.enumerable) {
      this._readFile = fs.promises.readFile.bind(fs.promises);
      this._writeFile = fs.promises.writeFile.bind(fs.promises);
      this._mkdir = fs.promises.mkdir.bind(fs.promises);
      if (fs.promises.rm) {
        this._rm = fs.promises.rm.bind(fs.promises);
      } else if (fs.promises.rmdir.length > ) {
        this._rm = fs.promises.rmdir.bind(fs.promises);
      } else {
        this._rm = rmRecursive.bind(null, this);
      }
      this._rmdir = fs.promises.rmdir.bind(fs.promises);
      this._unlink = fs.promises.unlink.bind(fs.promises);
      this._stat = fs.promises.stat.bind(fs.promises);
      this._lstat = fs.promises.lstat.bind(fs.promises);
      this._readdir = fs.promises.readdir.bind(fs.promises);
      this._readlink = fs.promises.readlink.bind(fs.promises);
      this._symlink = fs.promises.symlink.bind(fs.promises);
    } else {
      this._readFile = (, import_pify.default)(fs.readFile.bind(fs));
      this._writeFile = (, import_pify.default)(fs.writeFile.bind(fs));
      this._mkdir = (, import_pify.default)(fs.mkdir.bind(fs));
      if (fs.rm) {
        this._rm = (, import_pify.default)(fs.rm.bind(fs));
      } else if (fs.rmdir.length > ) {
        this._rm = (, import_pify.default)(fs.rmdir.bind(fs));
      } else {
        this._rm = rmRecursive.bind(null, this);
      }
      this._rmdir = (, import_pify.default)(fs.rmdir.bind(fs));
      this._unlink = (, import_pify.default)(fs.unlink.bind(fs));
      this._stat = (, import_pify.default)(fs.stat.bind(fs));
      this._lstat = (, import_pify.default)(fs.lstat.bind(fs));
      this._readdir = (, import_pify.default)(fs.readdir.bind(fs));
      this._readlink = (, import_pify.default)(fs.readlink.bind(fs));
      this._symlink = (, import_pify.default)(fs.symlink.bind(fs));
    }
    this._original_unwrapped_fs = fs;
  }
  /
    Return true if a file exists, false if it doesn't exist.
    Rethrows errors that aren't related to file existance.
   /
  async exists(filepath, options = {}) {
    try {
      await this._stat(filepath);
      return true;
    } catch (err) {
      if (err.code === "ENOENT" || err.code === "ENOTDIR") {
        return false;
      } else {
        console.log('Unhandled error in "FileSystem.exists()" function', err);
        throw err;
      }
    }
  }
  /
    Return the contents of a file if it exists, otherwise returns null.
   
    @param {string} filepath
    @param {object} [options]
   
    @returns {Promise<Buffer|string|null>}
   /
  async read(filepath, options = {}) {
    try {
      let buffer = await this._readFile(filepath, options);
      if (typeof buffer !== "string") {
        buffer = Buffer.from(buffer);
      }
      return buffer;
    } catch (err) {
      return null;
    }
  }
  /
    Write a file (creating missing directories if need be) without throwing errors.
   
    @param {string} filepath
    @param {Buffer|UintArray|string} contents
    @param {object|string} [options]
   /
  async write(filepath, contents, options = {}) {
    try {
      await this._writeFile(filepath, contents, options);
      return;
    } catch (err) {
      await this.mkdir(dirname(filepath));
      await this._writeFile(filepath, contents, options);
    }
  }
  /
    Make a directory (or series of nested directories) without throwing an error if it already exists.
   /
  async mkdir(filepath, _selfCall = false) {
    try {
      await this._mkdir(filepath);
      return;
    } catch (err) {
      if (err === null)
        return;
      if (err.code === "EEXIST")
        return;
      if (_selfCall)
        throw err;
      if (err.code === "ENOENT") {
        const parent = dirname(filepath);
        if (parent === "." || parent === "/" || parent === filepath)
          throw err;
        await this.mkdir(parent);
        await this.mkdir(filepath, true);
      }
    }
  }
  /
    Delete a file without throwing an error if it is already deleted.
   /
  async rm(filepath) {
    try {
      await this._unlink(filepath);
    } catch (err) {
      if (err.code !== "ENOENT")
        throw err;
    }
  }
  /
    Delete a directory without throwing an error if it is already deleted.
   /
  async rmdir(filepath, opts) {
    try {
      if (opts && opts.recursive) {
        await this._rm(filepath, opts);
      } else {
        await this._rmdir(filepath);
      }
    } catch (err) {
      if (err.code !== "ENOENT")
        throw err;
    }
  }
  /
    Read a directory without throwing an error is the directory doesn't exist
   /
  async readdir(filepath) {
    try {
      const names = await this._readdir(filepath);
      names.sort(compareStrings);
      return names;
    } catch (err) {
      if (err.code === "ENOTDIR")
        return null;
      return [];
    }
  }
  /
    Return a flast list of all the files nested inside a directory
   
    Based on an elegant concurrent recursive solution from SO
    https://stackoverflow.com/a//
   /
  async readdirDeep(dir) {
    const subdirs = await this._readdir(dir);
    const files = await Promise.all(
      subdirs.map(async (subdir) => {
        const res = dir + "/" + subdir;
        return (await this._stat(res)).isDirectory() ? this.readdirDeep(res) : res;
      })
    );
    return files.reduce((a, f) => a.concat(f), []);
  }
  /
    Return the Stats of a file/symlink if it exists, otherwise returns null.
    Rethrows errors that aren't related to file existance.
   /
  async lstat(filename) {
    try {
      const stats = await this._lstat(filename);
      return stats;
    } catch (err) {
      if (err.code === "ENOENT") {
        return null;
      }
      throw err;
    }
  }
  /
    Reads the contents of a symlink if it exists, otherwise returns null.
    Rethrows errors that aren't related to file existance.
   /
  async readlink(filename, opts = { encoding: "buffer" }) {
    try {
      const link = await this._readlink(filename, opts);
      return Buffer.isBuffer(link) ? link : Buffer.from(link);
    } catch (err) {
      if (err.code === "ENOENT") {
        return null;
      }
      throw err;
    }
  }
  /
    Write the contents of buffer to a symlink.
   /
  async writelink(filename, buffer) {
    return this._symlink(buffer.toString("utf"), filename);
  }
};
function assertParameter(name, value) {
  if (value === void ) {
    throw new MissingParameterError(name);
  }
}
async function modified(entry, base) {
  if (!entry && !base)
    return false;
  if (entry && !base)
    return true;
  if (!entry && base)
    return true;
  if (await entry.type() === "tree" && await base.type() === "tree") {
    return false;
  }
  if (await entry.type() === await base.type() && await entry.mode() === await base.mode() && await entry.oid() === await base.oid()) {
    return false;
  }
  return true;
}
async function abortMerge({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  commit: commit = "HEAD",
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    const fs = new FileSystem(_fs);
    const trees = [TREE({ ref: commit }), WORKDIR(), STAGE()];
    let unmergedPaths = [];
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      unmergedPaths = index.unmergedPaths;
    });
    const results = await _walk({
      fs,
      cache,
      dir,
      gitdir,
      trees,
      map: async function(path, [head, workdir, index]) {
        const staged = !await modified(workdir, index);
        const unmerged = unmergedPaths.includes(path);
        const unmodified = !await modified(index, head);
        if (staged || unmerged) {
          return head ? {
            path: path,
            mode: await head.mode(),
            oid: await head.oid(),
            type: await head.type(),
            content: await head.content()
          } : void ;
        }
        if (unmodified)
          return false;
        else
          throw new IndexResetError(path);
      }
    });
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      for (const entry of results) {
        if (entry === false)
          continue;
        if (!entry) {
          await fs.rmdir(`${dir}/${entry.path}`, { recursive: true });
          index.delete({ filepath: entry.path });
          continue;
        }
        if (entry.type === "blob") {
          const content = new TextDecoder().decode(entry.content);
          await fs.write(`${dir}/${entry.path}`, content, { mode: entry.mode });
          index.insert({
            filepath: entry.path,
            oid: entry.oid,
            stage: 
          });
        }
      }
    });
  } catch (err) {
    err.caller = "git.abortMerge";
    throw err;
  }
}
var GitIgnoreManager = class {
  static async isIgnored({ fs, dir, gitdir = join(dir, ".git"), filepath }) {
    if (basename(filepath) === ".git")
      return true;
    if (filepath === ".")
      return false;
    let excludes = "";
    const excludesFile = join(gitdir, "info", "exclude");
    if (await fs.exists(excludesFile)) {
      excludes = await fs.read(excludesFile, "utf");
    }
    const pairs = [
      {
        gitignore: join(dir, ".gitignore"),
        filepath
      }
    ];
    const pieces = filepath.split("/").filter(Boolean);
    for (let i = ; i < pieces.length; i++) {
      const folder = pieces.slice(, i).join("/");
      const file = pieces.slice(i).join("/");
      pairs.push({
        gitignore: join(dir, folder, ".gitignore"),
        filepath: file
      });
    }
    let ignoredStatus = false;
    for (const p of pairs) {
      let file;
      try {
        file = await fs.read(p.gitignore, "utf");
      } catch (err) {
        if (err.code === "NOENT")
          continue;
      }
      const ign = (, import_ignore.default)().add(excludes);
      ign.add(file);
      const parentdir = dirname(p.filepath);
      if (parentdir !== "." && ign.ignores(parentdir))
        return true;
      if (ignoredStatus) {
        ignoredStatus = !ign.test(p.filepath).unignored;
      } else {
        ignoredStatus = ign.test(p.filepath).ignored;
      }
    }
    return ignoredStatus;
  }
};
async function writeObjectLoose({ fs, gitdir, object, format, oid }) {
  if (format !== "deflated") {
    throw new InternalError(
      "GitObjectStoreLoose expects objects to write to be in deflated format"
    );
  }
  const source = `objects/${oid.slice(, )}/${oid.slice()}`;
  const filepath = `${gitdir}/${source}`;
  if (!await fs.exists(filepath))
    await fs.write(filepath, object);
}
var supportsCompressionStream = null;
async function deflate(buffer) {
  if (supportsCompressionStream === null) {
    supportsCompressionStream = testCompressionStream();
  }
  return supportsCompressionStream ? browserDeflate(buffer) : import_pako.default.deflate(buffer);
}
async function browserDeflate(buffer) {
  const cs = new CompressionStream("deflate");
  const c = new Blob([buffer]).stream().pipeThrough(cs);
  return new UintArray(await new Response(c).arrayBuffer());
}
function testCompressionStream() {
  try {
    const cs = new CompressionStream("deflate");
    new Blob([]).stream();
    if (cs)
      return true;
  } catch (_) {
  }
  return false;
}
async function _writeObject({
  fs,
  gitdir,
  type,
  object,
  format = "content",
  oid = void ,
  dryRun = false
}) {
  if (format !== "deflated") {
    if (format !== "wrapped") {
      object = GitObject.wrap({ type, object });
    }
    oid = await shasum(object);
    object = Buffer.from(await deflate(object));
  }
  if (!dryRun) {
    await writeObjectLoose({ fs, gitdir, object, format: "deflated", oid });
  }
  return oid;
}
function posixifyPathBuffer(buffer) {
  let idx;
  while (~(idx = buffer.indexOf()))
    buffer[idx] = ;
  return buffer;
}
async function add({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {},
  force = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    await GitIndexManager.acquire({ fs, gitdir, cache }, async (index) => {
      return addToIndex({ dir, gitdir, fs, filepath, index: index, force });
    });
  } catch (err) {
    err.caller = "git.add";
    throw err;
  }
}
async function addToIndex({ dir, gitdir, fs, filepath, index: index, force }) {
  filepath = Array.isArray(filepath) ? filepath : [filepath];
  const promises = filepath.map(async (currentFilepath) => {
    if (!force) {
      const ignored = await GitIgnoreManager.isIgnored({
        fs,
        dir,
        gitdir,
        filepath: currentFilepath
      });
      if (ignored)
        return;
    }
    const stats = await fs.lstat(join(dir, currentFilepath));
    if (!stats)
      throw new NotFoundError(currentFilepath);
    if (stats.isDirectory()) {
      const children = await fs.readdir(join(dir, currentFilepath));
      const promises = children.map(
        (child) => addToIndex({
          dir,
          gitdir,
          fs,
          filepath: [join(currentFilepath, child)],
          index: index,
          force
        })
      );
      await Promise.all(promises);
    } else {
      const object = stats.isSymbolicLink() ? await fs.readlink(join(dir, currentFilepath)).then(posixifyPathBuffer) : await fs.read(join(dir, currentFilepath));
      if (object === null)
        throw new NotFoundError(currentFilepath);
      const oid = await _writeObject({ fs, gitdir, type: "blob", object });
      index.insert({ filepath: currentFilepath, stats, oid });
    }
  });
  const settledPromises = await Promise.allSettled(promises);
  const rejectedPromises = settledPromises.filter((settle) => settle.status === "rejected").map((settle) => settle.reason);
  if (rejectedPromises.length > ) {
    throw new MultipleGitError(rejectedPromises);
  }
  if (rejectedPromises.length === ) {
    throw rejectedPromises[];
  }
  const fulfilledPromises = settledPromises.filter((settle) => settle.status === "fulfilled" && settle.value).map((settle) => settle.value);
  return fulfilledPromises;
}
async function _commit({
  fs,
  cache,
  onSign,
  gitdir,
  message,
  author,
  committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree
}) {
  if (!ref) {
    ref = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: "HEAD",
      depth: 
    });
  }
  return GitIndexManager.acquire(
    { fs, gitdir, cache, allowUnmerged: false },
    async function(index) {
      const inodes = flatFileListToDirectoryStructure(index.entries);
      const inode = inodes.get(".");
      if (!tree) {
        tree = await constructTree({ fs, gitdir, inode, dryRun });
      }
      if (!parent) {
        try {
          parent = [
            await GitRefManager.resolve({
              fs,
              gitdir,
              ref
            })
          ];
        } catch (err) {
          parent = [];
        }
      } else {
        parent = await Promise.all(
          parent.map((p) => {
            return GitRefManager.resolve({ fs, gitdir, ref: p });
          })
        );
      }
      let comm = GitCommit.from({
        tree,
        parent,
        author,
        committer,
        message
      });
      if (signingKey) {
        comm = await GitCommit.sign(comm, onSign, signingKey);
      }
      const oid = await _writeObject({
        fs,
        gitdir,
        type: "commit",
        object: comm.toObject(),
        dryRun
      });
      if (!noUpdateBranch && !dryRun) {
        await GitRefManager.writeRef({
          fs,
          gitdir,
          ref,
          value: oid
        });
      }
      return oid;
    }
  );
}
async function constructTree({ fs, gitdir, inode, dryRun }) {
  const children = inode.children;
  for (const inode of children) {
    if (inode.type === "tree") {
      inode.metadata.mode = "";
      inode.metadata.oid = await constructTree({ fs, gitdir, inode: inode, dryRun });
    }
  }
  const entries = children.map((inode) => ({
    mode: inode.metadata.mode,
    path: inode.basename,
    oid: inode.metadata.oid,
    type: inode.type
  }));
  const tree = GitTree.from(entries);
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tree",
    object: tree.toObject(),
    dryRun
  });
  return oid;
}
async function resolveFilepath({ fs, cache, gitdir, oid, filepath }) {
  if (filepath.startsWith("/")) {
    throw new InvalidFilepathError("leading-slash");
  } else if (filepath.endsWith("/")) {
    throw new InvalidFilepathError("trailing-slash");
  }
  const _oid = oid;
  const result = await resolveTree({ fs, cache, gitdir, oid });
  const tree = result.tree;
  if (filepath === "") {
    oid = result.oid;
  } else {
    const pathArray = filepath.split("/");
    oid = await _resolveFilepath({
      fs,
      cache,
      gitdir,
      tree,
      pathArray,
      oid: _oid,
      filepath
    });
  }
  return oid;
}
async function _resolveFilepath({
  fs,
  cache,
  gitdir,
  tree,
  pathArray,
  oid,
  filepath
}) {
  const name = pathArray.shift();
  for (const entry of tree) {
    if (entry.path === name) {
      if (pathArray.length === ) {
        return entry.oid;
      } else {
        const { type, object } = await _readObject({
          fs,
          cache,
          gitdir,
          oid: entry.oid
        });
        if (type !== "tree") {
          throw new ObjectTypeError(oid, type, "tree", filepath);
        }
        tree = GitTree.from(object);
        return _resolveFilepath({
          fs,
          cache,
          gitdir,
          tree,
          pathArray,
          oid,
          filepath
        });
      }
    }
  }
  throw new NotFoundError(`file or directory found at "${oid}:${filepath}"`);
}
async function _readTree({
  fs,
  cache,
  gitdir,
  oid,
  filepath = void 
}) {
  if (filepath !== void ) {
    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
  }
  const { tree, oid: treeOid } = await resolveTree({ fs, cache, gitdir, oid });
  const result = {
    oid: treeOid,
    tree: tree.entries()
  };
  return result;
}
async function _writeTree({ fs, gitdir, tree }) {
  const object = GitTree.from(tree).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tree",
    object,
    format: "content"
  });
  return oid;
}
async function _addNote({
  fs,
  cache,
  onSign,
  gitdir,
  ref,
  oid,
  note,
  force,
  author,
  committer,
  signingKey
}) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (!(err instanceof NotFoundError)) {
      throw err;
    }
  }
  const result = await _readTree({
    fs,
    cache,
    gitdir,
    oid: parent || "bdccbebaebfdfbee"
  });
  let tree = result.tree;
  if (force) {
    tree = tree.filter((entry) => entry.path !== oid);
  } else {
    for (const entry of tree) {
      if (entry.path === oid) {
        throw new AlreadyExistsError("note", oid);
      }
    }
  }
  if (typeof note === "string") {
    note = Buffer.from(note, "utf");
  }
  const noteOid = await _writeObject({
    fs,
    gitdir,
    type: "blob",
    object: note,
    format: "content"
  });
  tree.push({ mode: "", path: oid, oid: noteOid, type: "blob" });
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree
  });
  const commitOid = await _commit({
    fs,
    cache,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note added by 'isomorphic-git addNote'
`,
    author,
    committer,
    signingKey
  });
  return commitOid;
}
async function _getConfig({ fs, gitdir, path: path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.get(path);
}
async function normalizeAuthorObject({ fs, gitdir, author = {} }) {
  let { name, email, timestamp, timezoneOffset } = author;
  name = name || await _getConfig({ fs, gitdir, path: "user.name" });
  email = email || await _getConfig({ fs, gitdir, path: "user.email" }) || "";
  if (name === void ) {
    return void ;
  }
  timestamp = timestamp != null ? timestamp : Math.floor(Date.now() / e);
  timezoneOffset = timezoneOffset != null ? timezoneOffset : new Date(timestamp  e).getTimezoneOffset();
  return { name, email, timestamp, timezoneOffset };
}
async function normalizeCommitterObject({
  fs,
  gitdir,
  author,
  committer
}) {
  committer = Object.assign({}, committer || author);
  if (author) {
    committer.timestamp = committer.timestamp || author.timestamp;
    committer.timezoneOffset = committer.timezoneOffset || author.timezoneOffset;
  }
  committer = await normalizeAuthorObject({ fs, gitdir, author: committer });
  return committer;
}
async function addNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  note,
  force,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    assertParameter("note", note);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _addNote({
      fs: new FileSystem(fs),
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      note,
      force,
      author,
      committer,
      signingKey
    });
  } catch (err) {
    err.caller = "git.addNote";
    throw err;
  }
}
async function _addRemote({ fs, gitdir, remote, url, force }) {
  if (remote !== import_clean_git_ref.default.clean(remote)) {
    throw new InvalidRefNameError(remote, import_clean_git_ref.default.clean(remote));
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  if (!force) {
    const remoteNames = await config.getSubsections("remote");
    if (remoteNames.includes(remote)) {
      if (url !== await config.get(`remote.${remote}.url`)) {
        throw new AlreadyExistsError("remote", remote);
      }
    }
  }
  await config.set(`remote.${remote}.url`, url);
  await config.set(
    `remote.${remote}.fetch`,
    `+refs/heads/:refs/remotes/${remote}/`
  );
  await GitConfigManager.save({ fs, gitdir, config });
}
async function addRemote({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  remote,
  url,
  force = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("remote", remote);
    assertParameter("url", url);
    return await _addRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote,
      url,
      force
    });
  } catch (err) {
    err.caller = "git.addRemote";
    throw err;
  }
}
async function _annotatedTag({
  fs,
  cache,
  onSign,
  gitdir,
  ref,
  tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false
}) {
  ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
  if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
    throw new AlreadyExistsError("tag", ref);
  }
  const oid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: object || "HEAD"
  });
  const { type } = await _readObject({ fs, cache, gitdir, oid });
  let tagObject = GitAnnotatedTag.from({
    object: oid,
    type,
    tag: ref.replace("refs/tags/", ""),
    tagger,
    message,
    gpgsig
  });
  if (signingKey) {
    tagObject = await GitAnnotatedTag.sign(tagObject, onSign, signingKey);
  }
  const value = await _writeObject({
    fs,
    gitdir,
    type: "tag",
    object: tagObject.toObject()
  });
  await GitRefManager.writeRef({ fs, gitdir, ref, value });
}
async function annotatedTag({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  tagger: _tagger,
  message = ref,
  gpgsig,
  object,
  signingKey,
  force = false,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const tagger = await normalizeAuthorObject({ fs, gitdir, author: _tagger });
    if (!tagger)
      throw new MissingNameError("tagger");
    return await _annotatedTag({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      tagger,
      message,
      gpgsig,
      object,
      signingKey,
      force
    });
  } catch (err) {
    err.caller = "git.annotatedTag";
    throw err;
  }
}
async function _branch({
  fs,
  gitdir,
  ref,
  object,
  checkout: checkout = false,
  force = false
}) {
  if (ref !== import_clean_git_ref.default.clean(ref)) {
    throw new InvalidRefNameError(ref, import_clean_git_ref.default.clean(ref));
  }
  const fullref = `refs/heads/${ref}`;
  if (!force) {
    const exist = await GitRefManager.exists({ fs, gitdir, ref: fullref });
    if (exist) {
      throw new AlreadyExistsError("branch", ref, false);
    }
  }
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: object || "HEAD" });
  } catch (e) {
  }
  if (oid) {
    await GitRefManager.writeRef({ fs, gitdir, ref: fullref, value: oid });
  }
  if (checkout) {
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: "HEAD",
      value: fullref
    });
  }
}
async function branch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  object,
  checkout: checkout = false,
  force = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _branch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      object,
      checkout: checkout,
      force
    });
  } catch (err) {
    err.caller = "git.branch";
    throw err;
  }
}
var worthWalking = (filepath, root) => {
  if (filepath === "." || root == null || root.length ===  || root === ".") {
    return true;
  }
  if (root.length >= filepath.length) {
    return root.startsWith(filepath);
  } else {
    return filepath.startsWith(root);
  }
};
async function _checkout({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  remote,
  ref,
  filepaths,
  noCheckout,
  noUpdateHead,
  dryRun,
  force,
  track = true
}) {
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref });
  } catch (err) {
    if (ref === "HEAD")
      throw err;
    const remoteRef = `${remote}/${ref}`;
    oid = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: remoteRef
    });
    if (track) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`branch.${ref}.remote`, remote);
      await config.set(`branch.${ref}.merge`, `refs/heads/${ref}`);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    await GitRefManager.writeRef({
      fs,
      gitdir,
      ref: `refs/heads/${ref}`,
      value: oid
    });
  }
  if (!noCheckout) {
    let ops;
    try {
      ops = await analyze({
        fs,
        cache,
        onProgress,
        dir,
        gitdir,
        ref,
        force,
        filepaths
      });
    } catch (err) {
      if (err instanceof NotFoundError && err.data.what === oid) {
        throw new CommitNotFetchedError(ref, oid);
      } else {
        throw err;
      }
    }
    const conflicts = ops.filter(([method]) => method === "conflict").map(([method, fullpath]) => fullpath);
    if (conflicts.length > ) {
      throw new CheckoutConflictError(conflicts);
    }
    const errors = ops.filter(([method]) => method === "error").map(([method, fullpath]) => fullpath);
    if (errors.length > ) {
      throw new InternalError(errors.join(", "));
    }
    if (dryRun) {
      return;
    }
    let count = ;
    const total = ops.length;
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      await Promise.all(
        ops.filter(
          ([method]) => method === "delete" || method === "delete-index"
        ).map(async function([method, fullpath]) {
          const filepath = `${dir}/${fullpath}`;
          if (method === "delete") {
            await fs.rm(filepath);
          }
          index.delete({ filepath: fullpath });
          if (onProgress) {
            await onProgress({
              phase: "Updating workdir",
              loaded: ++count,
              total
            });
          }
        })
      );
    });
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      for (const [method, fullpath] of ops) {
        if (method === "rmdir" || method === "rmdir-index") {
          const filepath = `${dir}/${fullpath}`;
          try {
            if (method === "rmdir-index") {
              index.delete({ filepath: fullpath });
            }
            await fs.rmdir(filepath);
            if (onProgress) {
              await onProgress({
                phase: "Updating workdir",
                loaded: ++count,
                total
              });
            }
          } catch (e) {
            if (e.code === "ENOTEMPTY") {
              console.log(
                `Did not delete ${fullpath} because directory is not empty`
              );
            } else {
              throw e;
            }
          }
        }
      }
    });
    await Promise.all(
      ops.filter(([method]) => method === "mkdir" || method === "mkdir-index").map(async function([_, fullpath]) {
        const filepath = `${dir}/${fullpath}`;
        await fs.mkdir(filepath);
        if (onProgress) {
          await onProgress({
            phase: "Updating workdir",
            loaded: ++count,
            total
          });
        }
      })
    );
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      await Promise.all(
        ops.filter(
          ([method]) => method === "create" || method === "create-index" || method === "update" || method === "mkdir-index"
        ).map(async function([method, fullpath, oid, mode, chmod]) {
          const filepath = `${dir}/${fullpath}`;
          try {
            if (method !== "create-index" && method !== "mkdir-index") {
              const { object } = await _readObject({ fs, cache, gitdir, oid: oid });
              if (chmod) {
                await fs.rm(filepath);
              }
              if (mode === ) {
                await fs.write(filepath, object);
              } else if (mode === ) {
                await fs.write(filepath, object, { mode:  });
              } else if (mode === ) {
                await fs.writelink(filepath, object);
              } else {
                throw new InternalError(
                  `Invalid mode o${mode.toString()} detected in blob ${oid}`
                );
              }
            }
            const stats = await fs.lstat(filepath);
            if (mode === ) {
              stats.mode = ;
            }
            if (method === "mkdir-index") {
              stats.mode = ;
            }
            index.insert({
              filepath: fullpath,
              stats,
              oid: oid
            });
            if (onProgress) {
              await onProgress({
                phase: "Updating workdir",
                loaded: ++count,
                total
              });
            }
          } catch (e) {
            console.log(e);
          }
        })
      );
    });
  }
  if (!noUpdateHead) {
    const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
    if (fullRef.startsWith("refs/heads")) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref: "HEAD",
        value: fullRef
      });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value: oid });
    }
  }
}
async function analyze({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  ref,
  force,
  filepaths
}) {
  let count = ;
  return _walk({
    fs,
    cache,
    dir,
    gitdir,
    trees: [TREE({ ref }), WORKDIR(), STAGE()],
    map: async function(fullpath, [commit, workdir, stage]) {
      if (fullpath === ".")
        return;
      if (filepaths && !filepaths.some((base) => worthWalking(fullpath, base))) {
        return null;
      }
      if (onProgress) {
        await onProgress({ phase: "Analyzing workdir", loaded: ++count });
      }
      const key = [!!stage, !!commit, !!workdir].map(Number).join("");
      switch (key) {
        case "":
          return;
        case "":
          if (force && filepaths && filepaths.includes(fullpath)) {
            return ["delete", fullpath];
          }
          return;
        case "": {
          switch (await commit.type()) {
            case "tree": {
              return ["mkdir", fullpath];
            }
            case "blob": {
              return [
                "create",
                fullpath,
                await commit.oid(),
                await commit.mode()
              ];
            }
            case "commit": {
              return [
                "mkdir-index",
                fullpath,
                await commit.oid(),
                await commit.mode()
              ];
            }
            default: {
              return [
                "error",
                `new entry Unhandled type ${await commit.type()}`
              ];
            }
          }
        }
        case "": {
          switch (`${await commit.type()}-${await workdir.type()}`) {
            case "tree-tree": {
              return;
            }
            case "tree-blob":
            case "blob-tree": {
              return ["conflict", fullpath];
            }
            case "blob-blob": {
              if (await commit.oid() !== await workdir.oid()) {
                if (force) {
                  return [
                    "update",
                    fullpath,
                    await commit.oid(),
                    await commit.mode(),
                    await commit.mode() !== await workdir.mode()
                  ];
                } else {
                  return ["conflict", fullpath];
                }
              } else {
                if (await commit.mode() !== await workdir.mode()) {
                  if (force) {
                    return [
                      "update",
                      fullpath,
                      await commit.oid(),
                      await commit.mode(),
                      true
                    ];
                  } else {
                    return ["conflict", fullpath];
                  }
                } else {
                  return [
                    "create-index",
                    fullpath,
                    await commit.oid(),
                    await commit.mode()
                  ];
                }
              }
            }
            case "commit-tree": {
              return;
            }
            case "commit-blob": {
              return ["conflict", fullpath];
            }
            default: {
              return ["error", `new entry Unhandled type ${commit.type}`];
            }
          }
        }
        case "": {
          return ["delete-index", fullpath];
        }
        case "": {
          switch (await stage.type()) {
            case "tree": {
              return ["rmdir", fullpath];
            }
            case "blob": {
              if (await stage.oid() !== await workdir.oid()) {
                if (force) {
                  return ["delete", fullpath];
                } else {
                  return ["conflict", fullpath];
                }
              } else {
                return ["delete", fullpath];
              }
            }
            case "commit": {
              return ["rmdir-index", fullpath];
            }
            default: {
              return [
                "error",
                `delete entry Unhandled type ${await stage.type()}`
              ];
            }
          }
        }
        case "":
        case "": {
          switch (`${await stage.type()}-${await commit.type()}`) {
            case "tree-tree": {
              return;
            }
            case "blob-blob": {
              if (await stage.oid() === await commit.oid() && await stage.mode() === await commit.mode() && !force) {
                return;
              }
              if (workdir) {
                if (await workdir.oid() !== await stage.oid() && await workdir.oid() !== await commit.oid()) {
                  if (force) {
                    return [
                      "update",
                      fullpath,
                      await commit.oid(),
                      await commit.mode(),
                      await commit.mode() !== await workdir.mode()
                    ];
                  } else {
                    return ["conflict", fullpath];
                  }
                }
              } else if (force) {
                return [
                  "update",
                  fullpath,
                  await commit.oid(),
                  await commit.mode(),
                  await commit.mode() !== await stage.mode()
                ];
              }
              if (await commit.mode() !== await stage.mode()) {
                return [
                  "update",
                  fullpath,
                  await commit.oid(),
                  await commit.mode(),
                  true
                ];
              }
              if (await commit.oid() !== await stage.oid()) {
                return [
                  "update",
                  fullpath,
                  await commit.oid(),
                  await commit.mode(),
                  false
                ];
              } else {
                return;
              }
            }
            case "tree-blob": {
              return ["update-dir-to-blob", fullpath, await commit.oid()];
            }
            case "blob-tree": {
              return ["update-blob-to-tree", fullpath];
            }
            case "commit-commit": {
              return [
                "mkdir-index",
                fullpath,
                await commit.oid(),
                await commit.mode()
              ];
            }
            default: {
              return [
                "error",
                `update entry Unhandled type ${await stage.type()}-${await commit.type()}`
              ];
            }
          }
        }
      }
    },
    // Modify the default flat mapping
    reduce: async function(parent, children) {
      children = flat(children);
      if (!parent) {
        return children;
      } else if (parent && parent[] === "rmdir") {
        children.push(parent);
        return children;
      } else {
        children.unshift(parent);
        return children;
      }
    }
  });
}
async function checkout({
  fs,
  onProgress,
  dir,
  gitdir = join(dir, ".git"),
  remote = "origin",
  ref: _ref,
  filepaths,
  noCheckout = false,
  noUpdateHead = _ref === void ,
  dryRun = false,
  force = false,
  track = true,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    const ref = _ref || "HEAD";
    return await _checkout({
      fs: new FileSystem(fs),
      cache,
      onProgress,
      dir,
      gitdir,
      remote,
      ref,
      filepaths,
      noCheckout,
      noUpdateHead,
      dryRun,
      force,
      track
    });
  } catch (err) {
    err.caller = "git.checkout";
    throw err;
  }
}
var abbreviateRx = new RegExp("^refs/(heads/|tags/|remotes/)?(.)");
function abbreviateRef(ref) {
  const match = abbreviateRx.exec(ref);
  if (match) {
    if (match[] === "remotes/" && ref.endsWith("/HEAD")) {
      return match[].slice(, -);
    } else {
      return match[];
    }
  }
  return ref;
}
async function _currentBranch({
  fs,
  gitdir,
  fullname = false,
  test = false
}) {
  const ref = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: "HEAD",
    depth: 
  });
  if (test) {
    try {
      await GitRefManager.resolve({ fs, gitdir, ref });
    } catch (_) {
      return;
    }
  }
  if (!ref.startsWith("refs/"))
    return;
  return fullname ? ref : abbreviateRef(ref);
}
function translateSSHtoHTTP(url) {
  url = url.replace(/^git@([^:]+):/, "https://$/");
  url = url.replace(/^ssh:\/\//, "https://");
  return url;
}
function calculateBasicAuthHeader({ username = "", password = "" }) {
  return `Basic ${Buffer.from(`${username}:${password}`).toString("base")}`;
}
async function forAwait(iterable, cb) {
  const iter = getIterator(iterable);
  while (true) {
    const { value, done } = await iter.next();
    if (value)
      await cb(value);
    if (done)
      break;
  }
  if (iter.return)
    iter.return();
}
async function collect(iterable) {
  let size = ;
  const buffers = [];
  await forAwait(iterable, (value) => {
    buffers.push(value);
    size += value.byteLength;
  });
  const result = new UintArray(size);
  let nextIndex = ;
  for (const buffer of buffers) {
    result.set(buffer, nextIndex);
    nextIndex += buffer.byteLength;
  }
  return result;
}
function extractAuthFromUrl(url) {
  let userpass = url.match(/^https?:\/\/([^/]+)@/);
  if (userpass == null)
    return { url, auth: {} };
  userpass = userpass[];
  const [username, password] = userpass.split(":");
  url = url.replace(`${userpass}@`, "");
  return { url, auth: { username, password } };
}
function padHex(b, n) {
  const s = n.toString();
  return "".repeat(b - s.length) + s;
}
var GitPktLine = class {
  static flush() {
    return Buffer.from("", "utf");
  }
  static delim() {
    return Buffer.from("", "utf");
  }
  static encode(line) {
    if (typeof line === "string") {
      line = Buffer.from(line);
    }
    const length = line.length + ;
    const hexlength = padHex(, length);
    return Buffer.concat([Buffer.from(hexlength, "utf"), line]);
  }
  static streamReader(stream) {
    const reader = new StreamReader(stream);
    return async function read() {
      try {
        let length = await reader.read();
        if (length == null)
          return true;
        length = parseInt(length.toString("utf"), );
        if (length === )
          return null;
        if (length === )
          return null;
        const buffer = await reader.read(length - );
        if (buffer == null)
          return true;
        return buffer;
      } catch (err) {
        console.log("error", err);
        return true;
      }
    };
  }
};
async function parseCapabilitiesV(read) {
  const capabilities = {};
  let line;
  while (true) {
    line = await read();
    if (line === true)
      break;
    if (line === null)
      continue;
    line = line.toString("utf").replace(/\n$/, "");
    const i = line.indexOf("=");
    if (i > -) {
      const key = line.slice(, i);
      const value = line.slice(i + );
      capabilities[key] = value;
    } else {
      capabilities[line] = true;
    }
  }
  return { protocolVersion: , capabilities };
}
async function parseRefsAdResponse(stream, { service }) {
  const capabilities = / @__PURE__ / new Set();
  const refs = / @__PURE__ / new Map();
  const symrefs = / @__PURE__ / new Map();
  const read = GitPktLine.streamReader(stream);
  let lineOne = await read();
  while (lineOne === null)
    lineOne = await read();
  if (lineOne === true)
    throw new EmptyServerResponseError();
  if (lineOne.includes("version ")) {
    return parseCapabilitiesV(read);
  }
  if (lineOne.toString("utf").replace(/\n$/, "") !== ` service=${service}`) {
    throw new ParseError(` service=${service}\\n`, lineOne.toString("utf"));
  }
  let lineTwo = await read();
  while (lineTwo === null)
    lineTwo = await read();
  if (lineTwo === true)
    return { capabilities, refs, symrefs };
  lineTwo = lineTwo.toString("utf");
  if (lineTwo.includes("version ")) {
    return parseCapabilitiesV(read);
  }
  const [firstRef, capabilitiesLine] = splitAndAssert(lineTwo, "\", "\\x");
  capabilitiesLine.split(" ").map((x) => capabilities.add(x));
  const [ref, name] = splitAndAssert(firstRef, " ", " ");
  refs.set(name, ref);
  while (true) {
    const line = await read();
    if (line === true)
      break;
    if (line !== null) {
      const [ref, name] = splitAndAssert(line.toString("utf"), " ", " ");
      refs.set(name, ref);
    }
  }
  for (const cap of capabilities) {
    if (cap.startsWith("symref=")) {
      const m = cap.match(/symref=([^:]+):(.)/);
      if (m.length === ) {
        symrefs.set(m[], m[]);
      }
    }
  }
  return { protocolVersion: , capabilities, refs, symrefs };
}
function splitAndAssert(line, sep, expected) {
  const split = line.trim().split(sep);
  if (split.length !== ) {
    throw new ParseError(
      `Two strings separated by '${expected}'`,
      line.toString("utf")
    );
  }
  return split;
}
var corsProxify = (corsProxy, url) => corsProxy.endsWith("?") ? `${corsProxy}${url}` : `${corsProxy}/${url.replace(/^https?:\/\//, "")}`;
var updateHeaders = (headers, auth) => {
  if (auth.username || auth.password) {
    headers.Authorization = calculateBasicAuthHeader(auth);
  }
  if (auth.headers) {
    Object.assign(headers, auth.headers);
  }
};
var stringifyBody = async (res) => {
  try {
    const data = Buffer.from(await collect(res.body));
    const response = data.toString("utf");
    const preview = response.length <  ? response : response.slice(, ) + "...";
    return { preview, response, data };
  } catch (e) {
    return {};
  }
};
var GitRemoteHTTP = class {
  static async capabilities() {
    return ["discover", "connect"];
  }
  /
    @param {Object} args
    @param {HttpClient} args.http
    @param {ProgressCallback} [args.onProgress]
    @param {AuthCallback} [args.onAuth]
    @param {AuthFailureCallback} [args.onAuthFailure]
    @param {AuthSuccessCallback} [args.onAuthSuccess]
    @param {string} [args.corsProxy]
    @param {string} args.service
    @param {string} args.url
    @param {Object<string, string>} args.headers
    @param { | } args.protocolVersion - Git Protocol Version
   /
  static async discover({
    http,
    onProgress,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service,
    url: _origUrl,
    headers,
    protocolVersion
  }) {
    let { url, auth } = extractAuthFromUrl(_origUrl);
    const proxifiedURL = corsProxy ? corsProxify(corsProxy, url) : url;
    if (auth.username || auth.password) {
      headers.Authorization = calculateBasicAuthHeader(auth);
    }
    if (protocolVersion === ) {
      headers["Git-Protocol"] = "version=";
    }
    let res;
    let tryAgain;
    let providedAuthBefore = false;
    do {
      res = await http.request({
        onProgress,
        method: "GET",
        url: `${proxifiedURL}/info/refs?service=${service}`,
        headers
      });
      tryAgain = false;
      if (res.statusCode ===  || res.statusCode === ) {
        const getAuth = providedAuthBefore ? onAuthFailure : onAuth;
        if (getAuth) {
          auth = await getAuth(url, {
            ...auth,
            headers: { ...headers }
          });
          if (auth && auth.cancel) {
            throw new UserCanceledError();
          } else if (auth) {
            updateHeaders(headers, auth);
            providedAuthBefore = true;
            tryAgain = true;
          }
        }
      } else if (res.statusCode ===  && providedAuthBefore && onAuthSuccess) {
        await onAuthSuccess(url, auth);
      }
    } while (tryAgain);
    if (res.statusCode !== ) {
      const { response } = await stringifyBody(res);
      throw new HttpError(res.statusCode, res.statusMessage, response);
    }
    if (res.headers["content-type"] === `application/x-${service}-advertisement`) {
      const remoteHTTP = await parseRefsAdResponse(res.body, { service });
      remoteHTTP.auth = auth;
      return remoteHTTP;
    } else {
      const { preview, response, data } = await stringifyBody(res);
      try {
        const remoteHTTP = await parseRefsAdResponse([data], { service });
        remoteHTTP.auth = auth;
        return remoteHTTP;
      } catch (e) {
        throw new SmartHttpError(preview, response);
      }
    }
  }
  /
    @param {Object} args
    @param {HttpClient} args.http
    @param {ProgressCallback} [args.onProgress]
    @param {string} [args.corsProxy]
    @param {string} args.service
    @param {string} args.url
    @param {Object<string, string>} [args.headers]
    @param {any} args.body
    @param {any} args.auth
   /
  static async connect({
    http,
    onProgress,
    corsProxy,
    service,
    url,
    auth,
    body,
    headers
  }) {
    const urlAuth = extractAuthFromUrl(url);
    if (urlAuth)
      url = urlAuth.url;
    if (corsProxy)
      url = corsProxify(corsProxy, url);
    headers["content-type"] = `application/x-${service}-request`;
    headers.accept = `application/x-${service}-result`;
    updateHeaders(headers, auth);
    const res = await http.request({
      onProgress,
      method: "POST",
      url: `${url}/${service}`,
      body,
      headers
    });
    if (res.statusCode !== ) {
      const { response } = stringifyBody(res);
      throw new HttpError(res.statusCode, res.statusMessage, response);
    }
    return res;
  }
};
function parseRemoteUrl({ url }) {
  if (url.startsWith("git@")) {
    return {
      transport: "ssh",
      address: url
    };
  }
  const matches = url.match(/(\w+)(:\/\/|::)(.)/);
  if (matches === null)
    return;
  if (matches[] === "://") {
    return {
      transport: matches[],
      address: matches[]
    };
  }
  if (matches[] === "::") {
    return {
      transport: matches[],
      address: matches[]
    };
  }
}
var GitRemoteManager = class {
  static getRemoteHelperFor({ url }) {
    const remoteHelpers = / @__PURE__ / new Map();
    remoteHelpers.set("http", GitRemoteHTTP);
    remoteHelpers.set("https", GitRemoteHTTP);
    const parts = parseRemoteUrl({ url });
    if (!parts) {
      throw new UrlParseError(url);
    }
    if (remoteHelpers.has(parts.transport)) {
      return remoteHelpers.get(parts.transport);
    }
    throw new UnknownTransportError(
      url,
      parts.transport,
      parts.transport === "ssh" ? translateSSHtoHTTP(url) : void 
    );
  }
};
var lock$ = null;
var GitShallowManager = class {
  static async read({ fs, gitdir }) {
    if (lock$ === null)
      lock$ = new import_async_lock.default();
    const filepath = join(gitdir, "shallow");
    const oids = / @__PURE__ / new Set();
    await lock$.acquire(filepath, async function() {
      const text = await fs.read(filepath, { encoding: "utf" });
      if (text === null)
        return oids;
      if (text.trim() === "")
        return oids;
      text.trim().split("\n").map((oid) => oids.add(oid));
    });
    return oids;
  }
  static async write({ fs, gitdir, oids }) {
    if (lock$ === null)
      lock$ = new import_async_lock.default();
    const filepath = join(gitdir, "shallow");
    if (oids.size > ) {
      const text = [...oids].join("\n") + "\n";
      await lock$.acquire(filepath, async function() {
        await fs.write(filepath, text, {
          encoding: "utf"
        });
      });
    } else {
      await lock$.acquire(filepath, async function() {
        await fs.rm(filepath);
      });
    }
  }
};
async function hasObjectLoose({ fs, gitdir, oid }) {
  const source = `objects/${oid.slice(, )}/${oid.slice()}`;
  return fs.exists(`${gitdir}/${source}`);
}
async function hasObjectPacked({
  fs,
  cache,
  gitdir,
  oid,
  getExternalRefDelta
}) {
  let list = await fs.readdir(join(gitdir, "objects/pack"));
  list = list.filter((x) => x.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta
    });
    if (p.error)
      throw new InternalError(p.error);
    if (p.offsets.has(oid)) {
      return true;
    }
  }
  return false;
}
async function hasObject({
  fs,
  cache,
  gitdir,
  oid,
  format = "content"
}) {
  const getExternalRefDelta = (oid) => _readObject({ fs, cache, gitdir, oid: oid });
  let result = await hasObjectLoose({ fs, gitdir, oid });
  if (!result) {
    result = await hasObjectPacked({
      fs,
      cache,
      gitdir,
      oid,
      getExternalRefDelta
    });
  }
  return result;
}
function emptyPackfile(pack) {
  const pheader = "b";
  const version = "";
  const obCount = "";
  const header = pheader + version + obCount;
  return pack.slice(, ).toString("hex") === header;
}
function filterCapabilities(server, client) {
  const serverNames = server.map((cap) => cap.split("=", )[]);
  return client.filter((cap) => {
    const name = cap.split("=", )[];
    return serverNames.includes(name);
  });
}
var pkg = {
  name: "isomorphic-git",
  version: "..",
  agent: "git/isomorphic-git@.."
};
var FIFO = class {
  constructor() {
    this._queue = [];
  }
  write(chunk) {
    if (this._ended) {
      throw Error("You cannot write to a FIFO that has already been ended!");
    }
    if (this._waiting) {
      const resolve = this._waiting;
      this._waiting = null;
      resolve({ value: chunk });
    } else {
      this._queue.push(chunk);
    }
  }
  end() {
    this._ended = true;
    if (this._waiting) {
      const resolve = this._waiting;
      this._waiting = null;
      resolve({ done: true });
    }
  }
  destroy(err) {
    this._ended = true;
    this.error = err;
  }
  async next() {
    if (this._queue.length > ) {
      return { value: this._queue.shift() };
    }
    if (this._ended) {
      return { done: true };
    }
    if (this._waiting) {
      throw Error(
        "You cannot call read until the previous call to read has returned!"
      );
    }
    return new Promise((resolve) => {
      this._waiting = resolve;
    });
  }
};
function findSplit(str) {
  const r = str.indexOf("\r");
  const n = str.indexOf("\n");
  if (r === - && n === -)
    return -;
  if (r === -)
    return n + ;
  if (n === -)
    return r + ;
  if (n === r + )
    return n + ;
  return Math.min(r, n) + ;
}
function splitLines(input) {
  const output = new FIFO();
  let tmp = "";
  (async () => {
    await forAwait(input, (chunk) => {
      chunk = chunk.toString("utf");
      tmp += chunk;
      while (true) {
        const i = findSplit(tmp);
        if (i === -)
          break;
        output.write(tmp.slice(, i));
        tmp = tmp.slice(i);
      }
    });
    if (tmp.length > ) {
      output.write(tmp);
    }
    output.end();
  })();
  return output;
}
var GitSideBand = class {
  static demux(input) {
    const read = GitPktLine.streamReader(input);
    const packetlines = new FIFO();
    const packfile = new FIFO();
    const progress = new FIFO();
    const nextBit = async function() {
      const line = await read();
      if (line === null)
        return nextBit();
      if (line === true) {
        packetlines.end();
        progress.end();
        packfile.end();
        return;
      }
      switch (line[]) {
        case : {
          packfile.write(line.slice());
          break;
        }
        case : {
          progress.write(line.slice());
          break;
        }
        case : {
          const error = line.slice();
          progress.write(error);
          packfile.destroy(new Error(error.toString("utf")));
          return;
        }
        default: {
          packetlines.write(line.slice());
        }
      }
      nextBit();
    };
    nextBit();
    return {
      packetlines,
      packfile,
      progress
    };
  }
  // static mux ({
  //   protocol, // 'side-band' or 'side-band-k'
  //   packetlines,
  //   packfile,
  //   progress,
  //   error
  // }) {
  //   const MAX_PACKET_LENGTH = protocol === 'side-band-k' ?  : 
  //   let output = new PassThrough()
  //   packetlines.on('data', data => {
  //     if (data === null) {
  //       output.write(GitPktLine.flush())
  //     } else {
  //       output.write(GitPktLine.encode(data))
  //     }
  //   })
  //   let packfileWasEmpty = true
  //   let packfileEnded = false
  //   let progressEnded = false
  //   let errorEnded = false
  //   let goodbye = Buffer.concat([
  //     GitPktLine.encode(Buffer.from('A', 'hex')),
  //     GitPktLine.flush()
  //   ])
  //   packfile
  //     .on('data', data => {
  //       packfileWasEmpty = false
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       packfileEnded = true
  //       if (!packfileWasEmpty) output.write(goodbye)
  //       if (progressEnded && errorEnded) output.end()
  //     })
  //   progress
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       progressEnded = true
  //       if (packfileEnded && errorEnded) output.end()
  //     })
  //   error
  //     .on('data', data => {
  //       const buffers = splitBuffer(data, MAX_PACKET_LENGTH)
  //       for (const buffer of buffers) {
  //         output.write(
  //           GitPktLine.encode(Buffer.concat([Buffer.from('', 'hex'), buffer]))
  //         )
  //       }
  //     })
  //     .on('end', () => {
  //       errorEnded = true
  //       if (progressEnded && packfileEnded) output.end()
  //     })
  //   return output
  // }
};
async function parseUploadPackResponse(stream) {
  const { packetlines, packfile, progress } = GitSideBand.demux(stream);
  const shallows = [];
  const unshallows = [];
  const acks = [];
  let nak = false;
  let done = false;
  return new Promise((resolve, reject) => {
    forAwait(packetlines, (data) => {
      const line = data.toString("utf").trim();
      if (line.startsWith("shallow")) {
        const oid = line.slice(-).trim();
        if (oid.length !== ) {
          reject(new InvalidOidError(oid));
        }
        shallows.push(oid);
      } else if (line.startsWith("unshallow")) {
        const oid = line.slice(-).trim();
        if (oid.length !== ) {
          reject(new InvalidOidError(oid));
        }
        unshallows.push(oid);
      } else if (line.startsWith("ACK")) {
        const [, oid, status] = line.split(" ");
        acks.push({ oid, status: status });
        if (!status)
          done = true;
      } else if (line.startsWith("NAK")) {
        nak = true;
        done = true;
      }
      if (done) {
        resolve({ shallows, unshallows, acks, nak, packfile, progress });
      }
    });
  });
}
function writeUploadPackRequest({
  capabilities = [],
  wants = [],
  haves = [],
  shallows = [],
  depth = null,
  since = null,
  exclude = []
}) {
  const packstream = [];
  wants = [...new Set(wants)];
  let firstLineCapabilities = ` ${capabilities.join(" ")}`;
  for (const oid of wants) {
    packstream.push(GitPktLine.encode(`want ${oid}${firstLineCapabilities}
`));
    firstLineCapabilities = "";
  }
  for (const oid of shallows) {
    packstream.push(GitPktLine.encode(`shallow ${oid}
`));
  }
  if (depth !== null) {
    packstream.push(GitPktLine.encode(`deepen ${depth}
`));
  }
  if (since !== null) {
    packstream.push(
      GitPktLine.encode(`deepen-since ${Math.floor(since.valueOf() / e)}
`)
    );
  }
  for (const oid of exclude) {
    packstream.push(GitPktLine.encode(`deepen-not ${oid}
`));
  }
  packstream.push(GitPktLine.flush());
  for (const oid of haves) {
    packstream.push(GitPktLine.encode(`have ${oid}
`));
  }
  packstream.push(GitPktLine.encode(`done
`));
  return packstream;
}
async function _fetch({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote: _remote,
  url: _url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false
}) {
  const ref = _ref || await _currentBranch({ fs, gitdir, test: true });
  const config = await GitConfigManager.get({ fs, gitdir });
  const remote = _remote || ref && await config.get(`branch.${ref}.remote`) || "origin";
  const url = _url || await config.get(`remote.${remote}.url`);
  if (typeof url === "undefined") {
    throw new MissingParameterError("remote OR url");
  }
  const remoteRef = _remoteRef || ref && await config.get(`branch.${ref}.merge`) || _ref || "HEAD";
  if (corsProxy === void ) {
    corsProxy = await config.get("http.corsProxy");
  }
  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
  const remoteHTTP = await GitRemoteHTTP.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: "git-upload-pack",
    url,
    headers,
    protocolVersion: 
  });
  const auth = remoteHTTP.auth;
  const remoteRefs = remoteHTTP.refs;
  if (remoteRefs.size === ) {
    return {
      defaultBranch: null,
      fetchHead: null,
      fetchHeadDescription: null
    };
  }
  if (depth !== null && !remoteHTTP.capabilities.has("shallow")) {
    throw new RemoteCapabilityError("shallow", "depth");
  }
  if (since !== null && !remoteHTTP.capabilities.has("deepen-since")) {
    throw new RemoteCapabilityError("deepen-since", "since");
  }
  if (exclude.length >  && !remoteHTTP.capabilities.has("deepen-not")) {
    throw new RemoteCapabilityError("deepen-not", "exclude");
  }
  if (relative === true && !remoteHTTP.capabilities.has("deepen-relative")) {
    throw new RemoteCapabilityError("deepen-relative", "relative");
  }
  const { oid, fullref } = GitRefManager.resolveAgainstMap({
    ref: remoteRef,
    map: remoteRefs
  });
  for (const remoteRef of remoteRefs.keys()) {
    if (remoteRef === fullref || remoteRef === "HEAD" || remoteRef.startsWith("refs/heads/") || tags && remoteRef.startsWith("refs/tags/")) {
      continue;
    }
    remoteRefs.delete(remoteRef);
  }
  const capabilities = filterCapabilities(
    [...remoteHTTP.capabilities],
    [
      "multi_ack_detailed",
      "no-done",
      "side-band-k",
      // Note: I removed 'thin-pack' option since our code doesn't "fatten" packfiles,
      // which is necessary for compatibility with git. It was the cause of mysterious
      // 'fatal: pack has [x] unresolved deltas' errors that plagued us for some time.
      // isomorphic-git is perfectly happy with thin packfiles in .git/objects/pack but
      // canonical git it turns out is NOT.
      "ofs-delta",
      `agent=${pkg.agent}`
    ]
  );
  if (relative)
    capabilities.push("deepen-relative");
  const wants = singleBranch ? [oid] : remoteRefs.values();
  const haveRefs = singleBranch ? [ref] : await GitRefManager.listRefs({
    fs,
    gitdir,
    filepath: `refs`
  });
  let haves = [];
  for (let ref of haveRefs) {
    try {
      ref = await GitRefManager.expand({ fs, gitdir, ref: ref });
      const oid = await GitRefManager.resolve({ fs, gitdir, ref: ref });
      if (await hasObject({ fs, cache, gitdir, oid: oid })) {
        haves.push(oid);
      }
    } catch (err) {
    }
  }
  haves = [...new Set(haves)];
  const oids = await GitShallowManager.read({ fs, gitdir });
  const shallows = remoteHTTP.capabilities.has("shallow") ? [...oids] : [];
  const packstream = writeUploadPackRequest({
    capabilities,
    wants,
    haves,
    shallows,
    depth,
    since,
    exclude
  });
  const packbuffer = Buffer.from(await collect(packstream));
  const raw = await GitRemoteHTTP.connect({
    http,
    onProgress,
    corsProxy,
    service: "git-upload-pack",
    url,
    auth,
    body: [packbuffer],
    headers
  });
  const response = await parseUploadPackResponse(raw.body);
  if (raw.headers) {
    response.headers = raw.headers;
  }
  for (const oid of response.shallows) {
    if (!oids.has(oid)) {
      try {
        const { object } = await _readObject({ fs, cache, gitdir, oid: oid });
        const commit = new GitCommit(object);
        const hasParents = await Promise.all(
          commit.headers().parent.map((oid) => hasObject({ fs, cache, gitdir, oid: oid }))
        );
        const haveAllParents = hasParents.length ===  || hasParents.every((has) => has);
        if (!haveAllParents) {
          oids.add(oid);
        }
      } catch (err) {
        oids.add(oid);
      }
    }
  }
  for (const oid of response.unshallows) {
    oids.delete(oid);
  }
  await GitShallowManager.write({ fs, gitdir, oids });
  if (singleBranch) {
    const refs = / @__PURE__ / new Map([[fullref, oid]]);
    const symrefs = / @__PURE__ / new Map();
    let bail = ;
    let key = fullref;
    while (bail--) {
      const value = remoteHTTP.symrefs.get(key);
      if (value === void )
        break;
      symrefs.set(key, value);
      key = value;
    }
    const realRef = remoteRefs.get(key);
    if (realRef) {
      refs.set(key, realRef);
    }
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs,
      symrefs,
      tags,
      prune
    });
    if (prune) {
      response.pruned = pruned;
    }
  } else {
    const { pruned } = await GitRefManager.updateRemoteRefs({
      fs,
      gitdir,
      remote,
      refs: remoteRefs,
      symrefs: remoteHTTP.symrefs,
      tags,
      prune,
      pruneTags
    });
    if (prune) {
      response.pruned = pruned;
    }
  }
  response.HEAD = remoteHTTP.symrefs.get("HEAD");
  if (response.HEAD === void ) {
    const { oid: oid } = GitRefManager.resolveAgainstMap({
      ref: "HEAD",
      map: remoteRefs
    });
    for (const [key, value] of remoteRefs.entries()) {
      if (key !== "HEAD" && value === oid) {
        response.HEAD = key;
        break;
      }
    }
  }
  const noun = fullref.startsWith("refs/tags") ? "tag" : "branch";
  response.FETCH_HEAD = {
    oid,
    description: `${noun} '${abbreviateRef(fullref)}' of ${url}`
  };
  if (onProgress || onMessage) {
    const lines = splitLines(response.progress);
    forAwait(lines, async (line) => {
      if (onMessage)
        await onMessage(line);
      if (onProgress) {
        const matches = line.match(/([^:]).\((\d+?)\/(\d+?)\)/);
        if (matches) {
          await onProgress({
            phase: matches[].trim(),
            loaded: parseInt(matches[], ),
            total: parseInt(matches[], )
          });
        }
      }
    });
  }
  const packfile = Buffer.from(await collect(response.packfile));
  const packfileSha = packfile.slice(-).toString("hex");
  const res = {
    defaultBranch: response.HEAD,
    fetchHead: response.FETCH_HEAD.oid,
    fetchHeadDescription: response.FETCH_HEAD.description
  };
  if (response.headers) {
    res.headers = response.headers;
  }
  if (prune) {
    res.pruned = response.pruned;
  }
  if (packfileSha !== "" && !emptyPackfile(packfile)) {
    res.packfile = `objects/pack/pack-${packfileSha}.pack`;
    const fullpath = join(gitdir, res.packfile);
    await fs.write(fullpath, packfile);
    const getExternalRefDelta = (oid) => _readObject({ fs, cache, gitdir, oid: oid });
    const idx = await GitPackIndex.fromPack({
      pack: packfile,
      getExternalRefDelta,
      onProgress
    });
    await fs.write(fullpath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
  }
  return res;
}
async function _init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join(dir, ".git"),
  defaultBranch = "master"
}) {
  if (await fs.exists(gitdir + "/config"))
    return;
  let folders = [
    "hooks",
    "info",
    "objects/info",
    "objects/pack",
    "refs/heads",
    "refs/tags"
  ];
  folders = folders.map((dir) => gitdir + "/" + dir);
  for (const folder of folders) {
    await fs.mkdir(folder);
  }
  await fs.write(
    gitdir + "/config",
    `[core]
	repositoryformatversion = 
	filemode = false
	bare = ${bare}
` + (bare ? "" : "	logallrefupdates = true\n") + "	symlinks = false\n	ignorecase = true\n"
  );
  await fs.write(gitdir + "/HEAD", `ref: refs/heads/${defaultBranch}
`);
}
async function _clone({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  url,
  corsProxy,
  ref,
  remote,
  depth,
  since,
  exclude,
  relative,
  singleBranch,
  noCheckout,
  noTags,
  headers
}) {
  try {
    await _init({ fs, gitdir });
    await _addRemote({ fs, gitdir, remote, url, force: false });
    if (corsProxy) {
      const config = await GitConfigManager.get({ fs, gitdir });
      await config.set(`http.corsProxy`, corsProxy);
      await GitConfigManager.save({ fs, gitdir, config });
    }
    const { defaultBranch, fetchHead } = await _fetch({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      headers,
      tags: !noTags
    });
    if (fetchHead === null)
      return;
    ref = ref || defaultBranch;
    ref = ref.replace("refs/heads/", "");
    await _checkout({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout
    });
  } catch (err) {
    await fs.rmdir(gitdir, { recursive: true, maxRetries:  }).catch(() => void );
    throw err;
  }
}
async function clone({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  url,
  corsProxy = void ,
  ref = void ,
  remote = "origin",
  depth = void ,
  since = void ,
  exclude = [],
  relative = false,
  singleBranch = false,
  noCheckout = false,
  noTags = false,
  headers = {},
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    if (!noCheckout) {
      assertParameter("dir", dir);
    }
    assertParameter("url", url);
    return await _clone({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      url,
      corsProxy,
      ref,
      remote,
      depth,
      since,
      exclude,
      relative,
      singleBranch,
      noCheckout,
      noTags,
      headers
    });
  } catch (err) {
    err.caller = "git.clone";
    throw err;
  }
}
async function commit({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  message,
  author: _author,
  committer: _committer,
  signingKey,
  dryRun = false,
  noUpdateBranch = false,
  ref,
  parent,
  tree,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("message", message);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _commit({
      fs,
      cache,
      onSign,
      gitdir,
      message,
      author,
      committer,
      signingKey,
      dryRun,
      noUpdateBranch,
      ref,
      parent,
      tree
    });
  } catch (err) {
    err.caller = "git.commit";
    throw err;
  }
}
async function currentBranch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  fullname = false,
  test = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _currentBranch({
      fs: new FileSystem(fs),
      gitdir,
      fullname,
      test
    });
  } catch (err) {
    err.caller = "git.currentBranch";
    throw err;
  }
}
async function _deleteBranch({ fs, gitdir, ref }) {
  const exist = await GitRefManager.exists({ fs, gitdir, ref });
  if (!exist) {
    throw new NotFoundError(ref);
  }
  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const currentRef = await _currentBranch({ fs, gitdir, fullname: true });
  if (fullRef === currentRef) {
    const value = await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
    await GitRefManager.writeRef({ fs, gitdir, ref: "HEAD", value });
  }
  await GitRefManager.deleteRef({ fs, gitdir, ref: fullRef });
}
async function deleteBranch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    return await _deleteBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref
    });
  } catch (err) {
    err.caller = "git.deleteBranch";
    throw err;
  }
}
async function deleteRef({ fs, dir, gitdir = join(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    await GitRefManager.deleteRef({ fs: new FileSystem(fs), gitdir, ref });
  } catch (err) {
    err.caller = "git.deleteRef";
    throw err;
  }
}
async function _deleteRemote({ fs, gitdir, remote }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  await config.deleteSection("remote", remote);
  await GitConfigManager.save({ fs, gitdir, config });
}
async function deleteRemote({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  remote
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("remote", remote);
    return await _deleteRemote({
      fs: new FileSystem(fs),
      gitdir,
      remote
    });
  } catch (err) {
    err.caller = "git.deleteRemote";
    throw err;
  }
}
async function _deleteTag({ fs, gitdir, ref }) {
  ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
  await GitRefManager.deleteRef({ fs, gitdir, ref });
}
async function deleteTag({ fs, dir, gitdir = join(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("ref", ref);
    return await _deleteTag({
      fs: new FileSystem(fs),
      gitdir,
      ref
    });
  } catch (err) {
    err.caller = "git.deleteTag";
    throw err;
  }
}
async function expandOidLoose({ fs, gitdir, oid: short }) {
  const prefix = short.slice(, );
  const objectsSuffixes = await fs.readdir(`${gitdir}/objects/${prefix}`);
  return objectsSuffixes.map((suffix) => `${prefix}${suffix}`).filter((_oid) => _oid.startsWith(short));
}
async function expandOidPacked({
  fs,
  cache,
  gitdir,
  oid: short,
  getExternalRefDelta
}) {
  const results = [];
  let list = await fs.readdir(join(gitdir, "objects/pack"));
  list = list.filter((x) => x.endsWith(".idx"));
  for (const filename of list) {
    const indexFile = `${gitdir}/objects/pack/${filename}`;
    const p = await readPackIndex({
      fs,
      cache,
      filename: indexFile,
      getExternalRefDelta
    });
    if (p.error)
      throw new InternalError(p.error);
    for (const oid of p.offsets.keys()) {
      if (oid.startsWith(short))
        results.push(oid);
    }
  }
  return results;
}
async function _expandOid({ fs, cache, gitdir, oid: short }) {
  const getExternalRefDelta = (oid) => _readObject({ fs, cache, gitdir, oid });
  const results = await expandOidLoose({ fs, gitdir, oid: short });
  const results = await expandOidPacked({
    fs,
    cache,
    gitdir,
    oid: short,
    getExternalRefDelta
  });
  const results = results.concat(results);
  if (results.length === ) {
    return results[];
  }
  if (results.length > ) {
    throw new AmbiguousError("oids", short, results);
  }
  throw new NotFoundError(`an object matching "${short}"`);
}
async function expandOid({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _expandOid({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid
    });
  } catch (err) {
    err.caller = "git.expandOid";
    throw err;
  }
}
async function expandRef({ fs, dir, gitdir = join(dir, ".git"), ref }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await GitRefManager.expand({
      fs: new FileSystem(fs),
      gitdir,
      ref
    });
  } catch (err) {
    err.caller = "git.expandRef";
    throw err;
  }
}
async function _findMergeBase({ fs, cache, gitdir, oids }) {
  const visits = {};
  const passes = oids.length;
  let heads = oids.map((oid, index) => ({ index: index, oid }));
  while (heads.length) {
    const result = / @__PURE__ / new Set();
    for (const { oid, index: index } of heads) {
      if (!visits[oid])
        visits[oid] = / @__PURE__ / new Set();
      visits[oid].add(index);
      if (visits[oid].size === passes) {
        result.add(oid);
      }
    }
    if (result.size > ) {
      return [...result];
    }
    const newheads = / @__PURE__ / new Map();
    for (const { oid, index: index } of heads) {
      try {
        const { object } = await _readObject({ fs, cache, gitdir, oid });
        const commit = GitCommit.from(object);
        const { parent } = commit.parseHeaders();
        for (const oid of parent) {
          if (!visits[oid] || !visits[oid].has(index)) {
            newheads.set(oid + ":" + index, { oid: oid, index: index });
          }
        }
      } catch (err) {
      }
    }
    heads = Array.from(newheads.values());
  }
  return [];
}
var LINEBREAKS = /^.(\r?\n|$)/gm;
function mergeFile({ branches, contents }) {
  const ourName = branches[];
  const theirName = branches[];
  const baseContent = contents[];
  const ourContent = contents[];
  const theirContent = contents[];
  const ours = ourContent.match(LINEBREAKS);
  const base = baseContent.match(LINEBREAKS);
  const theirs = theirContent.match(LINEBREAKS);
  const result = (, import_diff.default)(ours, base, theirs);
  const markerSize = ;
  let mergedText = "";
  let cleanMerge = true;
  for (const item of result) {
    if (item.ok) {
      mergedText += item.ok.join("");
    }
    if (item.conflict) {
      cleanMerge = false;
      mergedText += `${"<".repeat(markerSize)} ${ourName}
`;
      mergedText += item.conflict.a.join("");
      mergedText += `${"=".repeat(markerSize)}
`;
      mergedText += item.conflict.b.join("");
      mergedText += `${">".repeat(markerSize)} ${theirName}
`;
    }
  }
  return { cleanMerge, mergedText };
}
async function mergeTree({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  index: index,
  ourOid,
  baseOid,
  theirOid,
  ourName = "ours",
  baseName = "base",
  theirName = "theirs",
  dryRun = false,
  abortOnConflict = true,
  mergeDriver
}) {
  const ourTree = TREE({ ref: ourOid });
  const baseTree = TREE({ ref: baseOid });
  const theirTree = TREE({ ref: theirOid });
  const unmergedFiles = [];
  const results = await _walk({
    fs,
    cache,
    dir,
    gitdir,
    trees: [ourTree, baseTree, theirTree],
    map: async function(filepath, [ours, base, theirs]) {
      const path = basename(filepath);
      const ourChange = await modified(ours, base);
      const theirChange = await modified(theirs, base);
      switch (`${ourChange}-${theirChange}`) {
        case "false-false": {
          return {
            mode: await base.mode(),
            path: path,
            oid: await base.oid(),
            type: await base.type()
          };
        }
        case "false-true": {
          return theirs ? {
            mode: await theirs.mode(),
            path: path,
            oid: await theirs.oid(),
            type: await theirs.type()
          } : void ;
        }
        case "true-false": {
          return ours ? {
            mode: await ours.mode(),
            path: path,
            oid: await ours.oid(),
            type: await ours.type()
          } : void ;
        }
        case "true-true": {
          if (ours && base && theirs && await ours.type() === "blob" && await base.type() === "blob" && await theirs.type() === "blob") {
            return mergeBlobs({
              fs,
              gitdir,
              path: path,
              ours,
              base,
              theirs,
              ourName,
              baseName,
              theirName,
              mergeDriver
            }).then(async (r) => {
              if (!r.cleanMerge) {
                unmergedFiles.push(filepath);
                if (!abortOnConflict) {
                  const baseOid = await base.oid();
                  const ourOid = await ours.oid();
                  const theirOid = await theirs.oid();
                  index.delete({ filepath });
                  index.insert({ filepath, oid: baseOid, stage:  });
                  index.insert({ filepath, oid: ourOid, stage:  });
                  index.insert({ filepath, oid: theirOid, stage:  });
                }
              } else if (!abortOnConflict) {
                index.insert({ filepath, oid: r.mergeResult.oid, stage:  });
              }
              return r.mergeResult;
            });
          }
          throw new MergeNotSupportedError();
        }
      }
    },
    /
      @param {TreeEntry} [parent]
      @param {Array<TreeEntry>} children
     /
    reduce: unmergedFiles.length !==  && (!dir || abortOnConflict) ? void  : async (parent, children) => {
      const entries = children.filter(Boolean);
      if (!parent)
        return;
      if (parent && parent.type === "tree" && entries.length === )
        return;
      if (entries.length > ) {
        const tree = new GitTree(entries);
        const object = tree.toObject();
        const oid = await _writeObject({
          fs,
          gitdir,
          type: "tree",
          object,
          dryRun
        });
        parent.oid = oid;
      }
      return parent;
    }
  });
  if (unmergedFiles.length !== ) {
    if (dir && !abortOnConflict) {
      await _walk({
        fs,
        cache,
        dir,
        gitdir,
        trees: [TREE({ ref: results.oid })],
        map: async function(filepath, [entry]) {
          const path = `${dir}/${filepath}`;
          if (await entry.type() === "blob") {
            const mode = await entry.mode();
            const content = new TextDecoder().decode(await entry.content());
            await fs.write(path, content, { mode });
          }
          return true;
        }
      });
    }
    return new MergeConflictError(unmergedFiles);
  }
  return results.oid;
}
async function mergeBlobs({
  fs,
  gitdir,
  path: path,
  ours,
  base,
  theirs,
  ourName,
  theirName,
  baseName,
  dryRun,
  mergeDriver = mergeFile
}) {
  const type = "blob";
  const mode = await base.mode() === await ours.mode() ? await theirs.mode() : await ours.mode();
  if (await ours.oid() === await theirs.oid()) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path: path, oid: await ours.oid(), type }
    };
  }
  if (await ours.oid() === await base.oid()) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path: path, oid: await theirs.oid(), type }
    };
  }
  if (await theirs.oid() === await base.oid()) {
    return {
      cleanMerge: true,
      mergeResult: { mode, path: path, oid: await ours.oid(), type }
    };
  }
  const ourContent = Buffer.from(await ours.content()).toString("utf");
  const baseContent = Buffer.from(await base.content()).toString("utf");
  const theirContent = Buffer.from(await theirs.content()).toString("utf");
  const { mergedText, cleanMerge } = await mergeDriver({
    branches: [baseName, ourName, theirName],
    contents: [baseContent, ourContent, theirContent],
    path: path
  });
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "blob",
    object: Buffer.from(mergedText, "utf"),
    dryRun
  });
  return { cleanMerge, mergeResult: { mode, path: path, oid, type } };
}
async function _merge({
  fs,
  cache,
  dir,
  gitdir,
  ours,
  theirs,
  fastForward: fastForward = true,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  abortOnConflict = true,
  message,
  author,
  committer,
  signingKey,
  onSign,
  mergeDriver
}) {
  if (ours === void ) {
    ours = await _currentBranch({ fs, gitdir, fullname: true });
  }
  ours = await GitRefManager.expand({
    fs,
    gitdir,
    ref: ours
  });
  theirs = await GitRefManager.expand({
    fs,
    gitdir,
    ref: theirs
  });
  const ourOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: ours
  });
  const theirOid = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: theirs
  });
  const baseOids = await _findMergeBase({
    fs,
    cache,
    gitdir,
    oids: [ourOid, theirOid]
  });
  if (baseOids.length !== ) {
    throw new MergeNotSupportedError();
  }
  const baseOid = baseOids[];
  if (baseOid === theirOid) {
    return {
      oid: ourOid,
      alreadyMerged: true
    };
  }
  if (fastForward && baseOid === ourOid) {
    if (!dryRun && !noUpdateBranch) {
      await GitRefManager.writeRef({ fs, gitdir, ref: ours, value: theirOid });
    }
    return {
      oid: theirOid,
      fastForward: true
    };
  } else {
    if (fastForwardOnly) {
      throw new FastForwardError();
    }
    const tree = await GitIndexManager.acquire(
      { fs, gitdir, cache, allowUnmerged: false },
      async (index) => {
        return mergeTree({
          fs,
          cache,
          dir,
          gitdir,
          index: index,
          ourOid,
          theirOid,
          baseOid,
          ourName: abbreviateRef(ours),
          baseName: "base",
          theirName: abbreviateRef(theirs),
          dryRun,
          abortOnConflict,
          mergeDriver
        });
      }
    );
    if (tree instanceof MergeConflictError)
      throw tree;
    if (!message) {
      message = `Merge branch '${abbreviateRef(theirs)}' into ${abbreviateRef(
        ours
      )}`;
    }
    const oid = await _commit({
      fs,
      cache,
      gitdir,
      message,
      ref: ours,
      tree,
      parent: [ourOid, theirOid],
      author,
      committer,
      signingKey,
      onSign,
      dryRun,
      noUpdateBranch
    });
    return {
      oid,
      tree,
      mergeCommit: true
    };
  }
}
async function _pull({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir,
  ref,
  url,
  remote,
  remoteRef,
  prune,
  pruneTags,
  fastForward: fastForward,
  fastForwardOnly,
  corsProxy,
  singleBranch,
  headers,
  author,
  committer,
  signingKey
}) {
  try {
    if (!ref) {
      const head = await _currentBranch({ fs, gitdir });
      if (!head) {
        throw new MissingParameterError("ref");
      }
      ref = head;
    }
    const { fetchHead, fetchHeadDescription } = await _fetch({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      corsProxy,
      ref,
      url,
      remote,
      remoteRef,
      singleBranch,
      headers,
      prune,
      pruneTags
    });
    await _merge({
      fs,
      cache,
      gitdir,
      ours: ref,
      theirs: fetchHead,
      fastForward: fastForward,
      fastForwardOnly,
      message: `Merge ${fetchHeadDescription}`,
      author,
      committer,
      signingKey,
      dryRun: false,
      noUpdateBranch: false
    });
    await _checkout({
      fs,
      cache,
      onProgress,
      dir,
      gitdir,
      ref,
      remote,
      noCheckout: false
    });
  } catch (err) {
    err.caller = "git.pull";
    throw err;
  }
}
async function fastForward({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  url,
  remote,
  remoteRef,
  corsProxy,
  singleBranch,
  headers = {},
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    const thisWillNotBeUsed = {
      name: "",
      email: "",
      timestamp: Date.now(),
      timezoneOffset: 
    };
    return await _pull({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForwardOnly: true,
      corsProxy,
      singleBranch,
      headers,
      author: thisWillNotBeUsed,
      committer: thisWillNotBeUsed
    });
  } catch (err) {
    err.caller = "git.fastForward";
    throw err;
  }
}
async function fetch({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  remote,
  remoteRef,
  url,
  corsProxy,
  depth = null,
  since = null,
  exclude = [],
  relative = false,
  tags = false,
  singleBranch = false,
  headers = {},
  prune = false,
  pruneTags = false,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    return await _fetch({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remote,
      remoteRef,
      url,
      corsProxy,
      depth,
      since,
      exclude,
      relative,
      tags,
      singleBranch,
      headers,
      prune,
      pruneTags
    });
  } catch (err) {
    err.caller = "git.fetch";
    throw err;
  }
}
async function findMergeBase({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oids,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oids", oids);
    return await _findMergeBase({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oids
    });
  } catch (err) {
    err.caller = "git.findMergeBase";
    throw err;
  }
}
async function _findRoot({ fs, filepath }) {
  if (await fs.exists(join(filepath, ".git"))) {
    return filepath;
  } else {
    const parent = dirname(filepath);
    if (parent === filepath) {
      throw new NotFoundError(`git root for ${filepath}`);
    }
    return _findRoot({ fs, filepath: parent });
  }
}
async function findRoot({ fs, filepath }) {
  try {
    assertParameter("fs", fs);
    assertParameter("filepath", filepath);
    return await _findRoot({ fs: new FileSystem(fs), filepath });
  } catch (err) {
    err.caller = "git.findRoot";
    throw err;
  }
}
async function getConfig({ fs, dir, gitdir = join(dir, ".git"), path: path }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    return await _getConfig({
      fs: new FileSystem(fs),
      gitdir,
      path: path
    });
  } catch (err) {
    err.caller = "git.getConfig";
    throw err;
  }
}
async function _getConfigAll({ fs, gitdir, path: path }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  return config.getall(path);
}
async function getConfigAll({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  path: path
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    return await _getConfigAll({
      fs: new FileSystem(fs),
      gitdir,
      path: path
    });
  } catch (err) {
    err.caller = "git.getConfigAll";
    throw err;
  }
}
async function getRemoteInfo({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion: 
    });
    const result = {
      capabilities: [...remote.capabilities]
    };
    for (const [ref, oid] of remote.refs) {
      const parts = ref.split("/");
      const last = parts.pop();
      let o = result;
      for (const part of parts) {
        o[part] = o[part] || {};
        o = o[part];
      }
      o[last] = oid;
    }
    for (const [symref, ref] of remote.symrefs) {
      const parts = symref.split("/");
      const last = parts.pop();
      let o = result;
      for (const part of parts) {
        o[part] = o[part] || {};
        o = o[part];
      }
      o[last] = ref;
    }
    return result;
  } catch (err) {
    err.caller = "git.getRemoteInfo";
    throw err;
  }
}
function formatInfoRefs(remote, prefix, symrefs, peelTags) {
  const refs = [];
  for (const [key, value] of remote.refs) {
    if (prefix && !key.startsWith(prefix))
      continue;
    if (key.endsWith("^{}")) {
      if (peelTags) {
        const _key = key.replace("^{}", "");
        const last = refs[refs.length - ];
        const r = last.ref === _key ? last : refs.find((x) => x.ref === _key);
        if (r === void ) {
          throw new Error("I did not expect this to happen");
        }
        r.peeled = value;
      }
      continue;
    }
    const ref = { ref: key, oid: value };
    if (symrefs) {
      if (remote.symrefs.has(key)) {
        ref.target = remote.symrefs.get(key);
      }
    }
    refs.push(ref);
  }
  return refs;
}
async function getRemoteInfo({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = 
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion
    });
    if (remote.protocolVersion === ) {
      return {
        protocolVersion: remote.protocolVersion,
        capabilities: remote.capabilities
      };
    }
    const capabilities = {};
    for (const cap of remote.capabilities) {
      const [key, value] = cap.split("=");
      if (value) {
        capabilities[key] = value;
      } else {
        capabilities[key] = true;
      }
    }
    return {
      protocolVersion: ,
      capabilities,
      refs: formatInfoRefs(remote, void , true, true)
    };
  } catch (err) {
    err.caller = "git.getRemoteInfo";
    throw err;
  }
}
async function hashObject({
  type,
  object,
  format = "content",
  oid = void 
}) {
  if (format !== "deflated") {
    if (format !== "wrapped") {
      object = GitObject.wrap({ type, object });
    }
    oid = await shasum(object);
  }
  return { oid, object };
}
async function hashBlob({ object }) {
  try {
    assertParameter("object", object);
    if (typeof object === "string") {
      object = Buffer.from(object, "utf");
    } else {
      object = Buffer.from(object);
    }
    const type = "blob";
    const { oid, object: _object } = await hashObject({
      type: "blob",
      format: "content",
      object
    });
    return { oid, type, object: new UintArray(_object), format: "wrapped" };
  } catch (err) {
    err.caller = "git.hashBlob";
    throw err;
  }
}
async function _indexPack({
  fs,
  cache,
  onProgress,
  dir,
  gitdir,
  filepath
}) {
  try {
    filepath = join(dir, filepath);
    const pack = await fs.read(filepath);
    const getExternalRefDelta = (oid) => _readObject({ fs, cache, gitdir, oid });
    const idx = await GitPackIndex.fromPack({
      pack,
      getExternalRefDelta,
      onProgress
    });
    await fs.write(filepath.replace(/\.pack$/, ".idx"), await idx.toBuffer());
    return {
      oids: [...idx.hashes]
    };
  } catch (err) {
    err.caller = "git.indexPack";
    throw err;
  }
}
async function indexPack({
  fs,
  onProgress,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", dir);
    assertParameter("filepath", filepath);
    return await _indexPack({
      fs: new FileSystem(fs),
      cache,
      onProgress,
      dir,
      gitdir,
      filepath
    });
  } catch (err) {
    err.caller = "git.indexPack";
    throw err;
  }
}
async function init({
  fs,
  bare = false,
  dir,
  gitdir = bare ? dir : join(dir, ".git"),
  defaultBranch = "master"
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    if (!bare) {
      assertParameter("dir", dir);
    }
    return await _init({
      fs: new FileSystem(fs),
      bare,
      dir,
      gitdir,
      defaultBranch
    });
  } catch (err) {
    err.caller = "git.init";
    throw err;
  }
}
async function _isDescendent({
  fs,
  cache,
  gitdir,
  oid,
  ancestor,
  depth
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  if (!oid) {
    throw new MissingParameterError("oid");
  }
  if (!ancestor) {
    throw new MissingParameterError("ancestor");
  }
  if (oid === ancestor)
    return false;
  const queue = [oid];
  const visited = / @__PURE__ / new Set();
  let searchdepth = ;
  while (queue.length) {
    if (searchdepth++ === depth) {
      throw new MaxDepthError(depth);
    }
    const oid = queue.shift();
    const { type, object } = await _readObject({
      fs,
      cache,
      gitdir,
      oid: oid
    });
    if (type !== "commit") {
      throw new ObjectTypeError(oid, type, "commit");
    }
    const commit = GitCommit.from(object).parse();
    for (const parent of commit.parent) {
      if (parent === ancestor)
        return true;
    }
    if (!shallows.has(oid)) {
      for (const parent of commit.parent) {
        if (!visited.has(parent)) {
          queue.push(parent);
          visited.add(parent);
        }
      }
    }
  }
  return false;
}
async function isDescendent({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  ancestor,
  depth = -,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    assertParameter("ancestor", ancestor);
    return await _isDescendent({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      ancestor,
      depth
    });
  } catch (err) {
    err.caller = "git.isDescendent";
    throw err;
  }
}
async function isIgnored({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("dir", dir);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    return GitIgnoreManager.isIgnored({
      fs: new FileSystem(fs),
      dir,
      gitdir,
      filepath
    });
  } catch (err) {
    err.caller = "git.isIgnored";
    throw err;
  }
}
async function listBranches({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  remote
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return GitRefManager.listBranches({
      fs: new FileSystem(fs),
      gitdir,
      remote
    });
  } catch (err) {
    err.caller = "git.listBranches";
    throw err;
  }
}
async function _listFiles({ fs, gitdir, ref, cache }) {
  if (ref) {
    const oid = await GitRefManager.resolve({ gitdir, fs, ref });
    const filenames = [];
    await accumulateFilesFromOid({
      fs,
      cache,
      gitdir,
      oid,
      filenames,
      prefix: ""
    });
    return filenames;
  } else {
    return GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      return index.entries.map((x) => x.path);
    });
  }
}
async function accumulateFilesFromOid({
  fs,
  cache,
  gitdir,
  oid,
  filenames,
  prefix
}) {
  const { tree } = await _readTree({ fs, cache, gitdir, oid });
  for (const entry of tree) {
    if (entry.type === "tree") {
      await accumulateFilesFromOid({
        fs,
        cache,
        gitdir,
        oid: entry.oid,
        filenames,
        prefix: join(prefix, entry.path)
      });
    } else {
      filenames.push(join(prefix, entry.path));
    }
  }
}
async function listFiles({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _listFiles({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref
    });
  } catch (err) {
    err.caller = "git.listFiles";
    throw err;
  }
}
async function _listNotes({ fs, cache, gitdir, ref }) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (err instanceof NotFoundError) {
      return [];
    }
  }
  const result = await _readTree({
    fs,
    cache,
    gitdir,
    oid: parent
  });
  const notes = result.tree.map((entry) => ({
    target: entry.path,
    note: entry.oid
  }));
  return notes;
}
async function listNotes({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _listNotes({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref
    });
  } catch (err) {
    err.caller = "git.listNotes";
    throw err;
  }
}
async function _listRemotes({ fs, gitdir }) {
  const config = await GitConfigManager.get({ fs, gitdir });
  const remoteNames = await config.getSubsections("remote");
  const remotes = Promise.all(
    remoteNames.map(async (remote) => {
      const url = await config.get(`remote.${remote}.url`);
      return { remote, url };
    })
  );
  return remotes;
}
async function listRemotes({ fs, dir, gitdir = join(dir, ".git") }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return await _listRemotes({
      fs: new FileSystem(fs),
      gitdir
    });
  } catch (err) {
    err.caller = "git.listRemotes";
    throw err;
  }
}
async function parseListRefsResponse(stream) {
  const read = GitPktLine.streamReader(stream);
  const refs = [];
  let line;
  while (true) {
    line = await read();
    if (line === true)
      break;
    if (line === null)
      continue;
    line = line.toString("utf").replace(/\n$/, "");
    const [oid, ref, ...attrs] = line.split(" ");
    const r = { ref, oid };
    for (const attr of attrs) {
      const [name, value] = attr.split(":");
      if (name === "symref-target") {
        r.target = value;
      } else if (name === "peeled") {
        r.peeled = value;
      }
    }
    refs.push(r);
  }
  return refs;
}
async function writeListRefsRequest({ prefix, symrefs, peelTags }) {
  const packstream = [];
  packstream.push(GitPktLine.encode("command=ls-refs\n"));
  packstream.push(GitPktLine.encode(`agent=${pkg.agent}
`));
  if (peelTags || symrefs || prefix) {
    packstream.push(GitPktLine.delim());
  }
  if (peelTags)
    packstream.push(GitPktLine.encode("peel"));
  if (symrefs)
    packstream.push(GitPktLine.encode("symrefs"));
  if (prefix)
    packstream.push(GitPktLine.encode(`ref-prefix ${prefix}`));
  packstream.push(GitPktLine.flush());
  return packstream;
}
async function listServerRefs({
  http,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  corsProxy,
  url,
  headers = {},
  forPush = false,
  protocolVersion = ,
  prefix,
  symrefs,
  peelTags
}) {
  try {
    assertParameter("http", http);
    assertParameter("url", url);
    const remote = await GitRemoteHTTP.discover({
      http,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      headers,
      protocolVersion
    });
    if (remote.protocolVersion === ) {
      return formatInfoRefs(remote, prefix, symrefs, peelTags);
    }
    const body = await writeListRefsRequest({ prefix, symrefs, peelTags });
    const res = await GitRemoteHTTP.connect({
      http,
      auth: remote.auth,
      headers,
      corsProxy,
      service: forPush ? "git-receive-pack" : "git-upload-pack",
      url,
      body
    });
    return parseListRefsResponse(res.body);
  } catch (err) {
    err.caller = "git.listServerRefs";
    throw err;
  }
}
async function listTags({ fs, dir, gitdir = join(dir, ".git") }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    return GitRefManager.listTags({ fs: new FileSystem(fs), gitdir });
  } catch (err) {
    err.caller = "git.listTags";
    throw err;
  }
}
async function resolveCommit({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  if (type === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveCommit({ fs, cache, gitdir, oid });
  }
  if (type !== "commit") {
    throw new ObjectTypeError(oid, type, "commit");
  }
  return { commit: GitCommit.from(object), oid };
}
async function _readCommit({ fs, cache, gitdir, oid }) {
  const { commit: commit, oid: commitOid } = await resolveCommit({
    fs,
    cache,
    gitdir,
    oid
  });
  const result = {
    oid: commitOid,
    commit: commit.parse(),
    payload: commit.withoutSignature()
  };
  return result;
}
function compareAge(a, b) {
  return a.committer.timestamp - b.committer.timestamp;
}
var EMPTY_OID = "edebbddbbaeadcec";
async function resolveFileIdInTree({ fs, cache, gitdir, oid, fileId }) {
  if (fileId === EMPTY_OID)
    return;
  const _oid = oid;
  let filepath;
  const result = await resolveTree({ fs, cache, gitdir, oid });
  const tree = result.tree;
  if (fileId === result.oid) {
    filepath = result.path;
  } else {
    filepath = await _resolveFileId({
      fs,
      cache,
      gitdir,
      tree,
      fileId,
      oid: _oid
    });
    if (Array.isArray(filepath)) {
      if (filepath.length === )
        filepath = void ;
      else if (filepath.length === )
        filepath = filepath[];
    }
  }
  return filepath;
}
async function _resolveFileId({
  fs,
  cache,
  gitdir,
  tree,
  fileId,
  oid,
  filepaths = [],
  parentPath = ""
}) {
  const walks = tree.entries().map(function(entry) {
    let result;
    if (entry.oid === fileId) {
      result = join(parentPath, entry.path);
      filepaths.push(result);
    } else if (entry.type === "tree") {
      result = _readObject({
        fs,
        cache,
        gitdir,
        oid: entry.oid
      }).then(function({ object }) {
        return _resolveFileId({
          fs,
          cache,
          gitdir,
          tree: GitTree.from(object),
          fileId,
          oid,
          filepaths,
          parentPath: join(parentPath, entry.path)
        });
      });
    }
    return result;
  });
  await Promise.all(walks);
  return filepaths;
}
async function _log({
  fs,
  cache,
  gitdir,
  filepath,
  ref,
  depth,
  since,
  force,
  follow
}) {
  const sinceTimestamp = typeof since === "undefined" ? void  : Math.floor(since.valueOf() / e);
  const commits = [];
  const shallowCommits = await GitShallowManager.read({ fs, gitdir });
  const oid = await GitRefManager.resolve({ fs, gitdir, ref });
  const tips = [await _readCommit({ fs, cache, gitdir, oid })];
  let lastFileOid;
  let lastCommit;
  let isOk;
  function endCommit(commit) {
    if (isOk && filepath)
      commits.push(commit);
  }
  while (tips.length > ) {
    const commit = tips.pop();
    if (sinceTimestamp !== void  && commit.commit.committer.timestamp <= sinceTimestamp) {
      break;
    }
    if (filepath) {
      let vFileOid;
      try {
        vFileOid = await resolveFilepath({
          fs,
          cache,
          gitdir,
          oid: commit.commit.tree,
          filepath
        });
        if (lastCommit && lastFileOid !== vFileOid) {
          commits.push(lastCommit);
        }
        lastFileOid = vFileOid;
        lastCommit = commit;
        isOk = true;
      } catch (e) {
        if (e instanceof NotFoundError) {
          let found = follow && lastFileOid;
          if (found) {
            found = await resolveFileIdInTree({
              fs,
              cache,
              gitdir,
              oid: commit.commit.tree,
              fileId: lastFileOid
            });
            if (found) {
              if (Array.isArray(found)) {
                if (lastCommit) {
                  const lastFound = await resolveFileIdInTree({
                    fs,
                    cache,
                    gitdir,
                    oid: lastCommit.commit.tree,
                    fileId: lastFileOid
                  });
                  if (Array.isArray(lastFound)) {
                    found = found.filter((p) => lastFound.indexOf(p) === -);
                    if (found.length === ) {
                      found = found[];
                      filepath = found;
                      if (lastCommit)
                        commits.push(lastCommit);
                    } else {
                      found = false;
                      if (lastCommit)
                        commits.push(lastCommit);
                      break;
                    }
                  }
                }
              } else {
                filepath = found;
                if (lastCommit)
                  commits.push(lastCommit);
              }
            }
          }
          if (!found) {
            if (isOk && lastFileOid) {
              commits.push(lastCommit);
              if (!force)
                break;
            }
            if (!force && !follow)
              throw e;
          }
          lastCommit = commit;
          isOk = false;
        } else
          throw e;
      }
    } else {
      commits.push(commit);
    }
    if (depth !== void  && commits.length === depth) {
      endCommit(commit);
      break;
    }
    if (!shallowCommits.has(commit.oid)) {
      for (const oid of commit.commit.parent) {
        const commit = await _readCommit({ fs, cache, gitdir, oid: oid });
        if (!tips.map((commit) => commit.oid).includes(commit.oid)) {
          tips.push(commit);
        }
      }
    }
    if (tips.length === ) {
      endCommit(commit);
    }
    tips.sort((a, b) => compareAge(a.commit, b.commit));
  }
  return commits;
}
async function log({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  ref = "HEAD",
  depth,
  since,
  // Date
  force,
  follow,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    return await _log({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      filepath,
      ref,
      depth,
      since,
      force,
      follow
    });
  } catch (err) {
    err.caller = "git.log";
    throw err;
  }
}
async function merge({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ours,
  theirs,
  fastForward: fastForward = true,
  fastForwardOnly = false,
  dryRun = false,
  noUpdateBranch = false,
  abortOnConflict = true,
  message,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {},
  mergeDriver
}) {
  try {
    assertParameter("fs", _fs);
    if (signingKey) {
      assertParameter("onSign", onSign);
    }
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author && (!fastForwardOnly || !fastForward)) {
      throw new MissingNameError("author");
    }
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer && (!fastForwardOnly || !fastForward)) {
      throw new MissingNameError("committer");
    }
    return await _merge({
      fs,
      cache,
      dir,
      gitdir,
      ours,
      theirs,
      fastForward: fastForward,
      fastForwardOnly,
      dryRun,
      noUpdateBranch,
      abortOnConflict,
      message,
      author,
      committer,
      signingKey,
      onSign,
      mergeDriver
    });
  } catch (err) {
    err.caller = "git.merge";
    throw err;
  }
}
var types = {
  commit: ,
  tree: ,
  blob: ,
  tag: ,
  ofs_delta: ,
  ref_delta: 
};
async function _pack({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  oids
}) {
  const hash = new import_sha.default();
  const outputStream = [];
  function write(chunk, enc) {
    const buff = Buffer.from(chunk, enc);
    outputStream.push(buff);
    hash.update(buff);
  }
  async function writeObject({ stype, object }) {
    const type = types[stype];
    let length = object.length;
    let multibyte = length >  ?  : ;
    const lastFour = length & ;
    length = length >>> ;
    let byte = (multibyte | type | lastFour).toString();
    write(byte, "hex");
    while (multibyte) {
      multibyte = length >  ?  : ;
      byte = multibyte | length & ;
      write(padHex(, byte), "hex");
      length = length >>> ;
    }
    write(Buffer.from(await deflate(object)));
  }
  write("PACK");
  write("", "hex");
  write(padHex(, oids.length), "hex");
  for (const oid of oids) {
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    await writeObject({ write, object, stype: type });
  }
  const digest = hash.digest();
  outputStream.push(digest);
  return outputStream;
}
async function _packObjects({ fs, cache, gitdir, oids, write }) {
  const buffers = await _pack({ fs, cache, gitdir, oids });
  const packfile = Buffer.from(await collect(buffers));
  const packfileSha = packfile.slice(-).toString("hex");
  const filename = `pack-${packfileSha}.pack`;
  if (write) {
    await fs.write(join(gitdir, `objects/pack/${filename}`), packfile);
    return { filename };
  }
  return {
    filename,
    packfile: new UintArray(packfile)
  };
}
async function packObjects({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oids,
  write = false,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oids", oids);
    return await _packObjects({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oids,
      write
    });
  } catch (err) {
    err.caller = "git.packObjects";
    throw err;
  }
}
async function pull({
  fs: _fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  url,
  remote,
  remoteRef,
  prune = false,
  pruneTags = false,
  fastForward: fastForward = true,
  fastForwardOnly = false,
  corsProxy,
  singleBranch,
  headers = {},
  author: _author,
  committer: _committer,
  signingKey,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _pull({
      fs,
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      dir,
      gitdir,
      ref,
      url,
      remote,
      remoteRef,
      fastForward: fastForward,
      fastForwardOnly,
      corsProxy,
      singleBranch,
      headers,
      author,
      committer,
      signingKey,
      prune,
      pruneTags
    });
  } catch (err) {
    err.caller = "git.pull";
    throw err;
  }
}
async function listCommitsAndTags({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  start,
  finish
}) {
  const shallows = await GitShallowManager.read({ fs, gitdir });
  const startingSet = / @__PURE__ / new Set();
  const finishingSet = / @__PURE__ / new Set();
  for (const ref of start) {
    startingSet.add(await GitRefManager.resolve({ fs, gitdir, ref }));
  }
  for (const ref of finish) {
    try {
      const oid = await GitRefManager.resolve({ fs, gitdir, ref });
      finishingSet.add(oid);
    } catch (err) {
    }
  }
  const visited = / @__PURE__ / new Set();
  async function walk(oid) {
    visited.add(oid);
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type === "tag") {
      const tag = GitAnnotatedTag.from(object);
      const commit = tag.headers().object;
      return walk(commit);
    }
    if (type !== "commit") {
      throw new ObjectTypeError(oid, type, "commit");
    }
    if (!shallows.has(oid)) {
      const commit = GitCommit.from(object);
      const parents = commit.headers().parent;
      for (oid of parents) {
        if (!finishingSet.has(oid) && !visited.has(oid)) {
          await walk(oid);
        }
      }
    }
  }
  for (const oid of startingSet) {
    await walk(oid);
  }
  return visited;
}
async function listObjects({
  fs,
  cache,
  dir,
  gitdir = join(dir, ".git"),
  oids
}) {
  const visited = / @__PURE__ / new Set();
  async function walk(oid) {
    if (visited.has(oid))
      return;
    visited.add(oid);
    const { type, object } = await _readObject({ fs, cache, gitdir, oid });
    if (type === "tag") {
      const tag = GitAnnotatedTag.from(object);
      const obj = tag.headers().object;
      await walk(obj);
    } else if (type === "commit") {
      const commit = GitCommit.from(object);
      const tree = commit.headers().tree;
      await walk(tree);
    } else if (type === "tree") {
      const tree = GitTree.from(object);
      for (const entry of tree) {
        if (entry.type === "blob") {
          visited.add(entry.oid);
        }
        if (entry.type === "tree") {
          await walk(entry.oid);
        }
      }
    }
  }
  for (const oid of oids) {
    await walk(oid);
  }
  return visited;
}
async function parseReceivePackResponse(packfile) {
  const result = {};
  let response = "";
  const read = GitPktLine.streamReader(packfile);
  let line = await read();
  while (line !== true) {
    if (line !== null)
      response += line.toString("utf") + "\n";
    line = await read();
  }
  const lines = response.toString("utf").split("\n");
  line = lines.shift();
  if (!line.startsWith("unpack ")) {
    throw new ParseError('unpack ok" or "unpack [error message]', line);
  }
  result.ok = line === "unpack ok";
  if (!result.ok) {
    result.error = line.slice("unpack ".length);
  }
  result.refs = {};
  for (const line of lines) {
    if (line.trim() === "")
      continue;
    const status = line.slice(, );
    const refAndMessage = line.slice();
    let space = refAndMessage.indexOf(" ");
    if (space === -)
      space = refAndMessage.length;
    const ref = refAndMessage.slice(, space);
    const error = refAndMessage.slice(space + );
    result.refs[ref] = {
      ok: status === "ok",
      error
    };
  }
  return result;
}
async function writeReceivePackRequest({
  capabilities = [],
  triplets = []
}) {
  const packstream = [];
  let capsFirstLine = `\ ${capabilities.join(" ")}`;
  for (const trip of triplets) {
    packstream.push(
      GitPktLine.encode(
        `${trip.oldoid} ${trip.oid} ${trip.fullRef}${capsFirstLine}
`
      )
    );
    capsFirstLine = "";
  }
  packstream.push(GitPktLine.flush());
  return packstream;
}
async function _push({
  fs,
  cache,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  gitdir,
  ref: _ref,
  remoteRef: _remoteRef,
  remote,
  url: _url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {}
}) {
  const ref = _ref || await _currentBranch({ fs, gitdir });
  if (typeof ref === "undefined") {
    throw new MissingParameterError("ref");
  }
  const config = await GitConfigManager.get({ fs, gitdir });
  remote = remote || await config.get(`branch.${ref}.pushRemote`) || await config.get("remote.pushDefault") || await config.get(`branch.${ref}.remote`) || "origin";
  const url = _url || await config.get(`remote.${remote}.pushurl`) || await config.get(`remote.${remote}.url`);
  if (typeof url === "undefined") {
    throw new MissingParameterError("remote OR url");
  }
  const remoteRef = _remoteRef || await config.get(`branch.${ref}.merge`);
  if (typeof url === "undefined") {
    throw new MissingParameterError("remoteRef");
  }
  if (corsProxy === void ) {
    corsProxy = await config.get("http.corsProxy");
  }
  const fullRef = await GitRefManager.expand({ fs, gitdir, ref });
  const oid = _delete ? "" : await GitRefManager.resolve({ fs, gitdir, ref: fullRef });
  const GitRemoteHTTP = GitRemoteManager.getRemoteHelperFor({ url });
  const httpRemote = await GitRemoteHTTP.discover({
    http,
    onAuth,
    onAuthSuccess,
    onAuthFailure,
    corsProxy,
    service: "git-receive-pack",
    url,
    headers,
    protocolVersion: 
  });
  const auth = httpRemote.auth;
  let fullRemoteRef;
  if (!remoteRef) {
    fullRemoteRef = fullRef;
  } else {
    try {
      fullRemoteRef = await GitRefManager.expandAgainstMap({
        ref: remoteRef,
        map: httpRemote.refs
      });
    } catch (err) {
      if (err instanceof NotFoundError) {
        fullRemoteRef = remoteRef.startsWith("refs/") ? remoteRef : `refs/heads/${remoteRef}`;
      } else {
        throw err;
      }
    }
  }
  const oldoid = httpRemote.refs.get(fullRemoteRef) || "";
  const thinPack = !httpRemote.capabilities.has("no-thin");
  let objects = / @__PURE__ / new Set();
  if (!_delete) {
    const finish = [...httpRemote.refs.values()];
    let skipObjects = / @__PURE__ / new Set();
    if (oldoid !== "") {
      const mergebase = await _findMergeBase({
        fs,
        cache,
        gitdir,
        oids: [oid, oldoid]
      });
      for (const oid of mergebase)
        finish.push(oid);
      if (thinPack) {
        skipObjects = await listObjects({ fs, cache, gitdir, oids: mergebase });
      }
    }
    if (!finish.includes(oid)) {
      const commits = await listCommitsAndTags({
        fs,
        cache,
        gitdir,
        start: [oid],
        finish
      });
      objects = await listObjects({ fs, cache, gitdir, oids: commits });
    }
    if (thinPack) {
      try {
        const ref = await GitRefManager.resolve({
          fs,
          gitdir,
          ref: `refs/remotes/${remote}/HEAD`,
          depth: 
        });
        const { oid: oid } = await GitRefManager.resolveAgainstMap({
          ref: ref.replace(`refs/remotes/${remote}/`, ""),
          fullref: ref,
          map: httpRemote.refs
        });
        const oids = [oid];
        for (const oid of await listObjects({ fs, cache, gitdir, oids })) {
          skipObjects.add(oid);
        }
      } catch (e) {
      }
      for (const oid of skipObjects) {
        objects.delete(oid);
      }
    }
    if (oid === oldoid)
      force = true;
    if (!force) {
      if (fullRef.startsWith("refs/tags") && oldoid !== "") {
        throw new PushRejectedError("tag-exists");
      }
      if (oid !== "" && oldoid !== "" && !await _isDescendent({
        fs,
        cache,
        gitdir,
        oid,
        ancestor: oldoid,
        depth: -
      })) {
        throw new PushRejectedError("not-fast-forward");
      }
    }
  }
  const capabilities = filterCapabilities(
    [...httpRemote.capabilities],
    ["report-status", "side-band-k", `agent=${pkg.agent}`]
  );
  const packstream = await writeReceivePackRequest({
    capabilities,
    triplets: [{ oldoid, oid, fullRef: fullRemoteRef }]
  });
  const packstream = _delete ? [] : await _pack({
    fs,
    cache,
    gitdir,
    oids: [...objects]
  });
  const res = await GitRemoteHTTP.connect({
    http,
    onProgress,
    corsProxy,
    service: "git-receive-pack",
    url,
    auth,
    headers,
    body: [...packstream, ...packstream]
  });
  const { packfile, progress } = await GitSideBand.demux(res.body);
  if (onMessage) {
    const lines = splitLines(progress);
    forAwait(lines, async (line) => {
      await onMessage(line);
    });
  }
  const result = await parseReceivePackResponse(packfile);
  if (res.headers) {
    result.headers = res.headers;
  }
  if (remote && result.ok && result.refs[fullRemoteRef].ok) {
    const ref = `refs/remotes/${remote}/${fullRemoteRef.replace(
      "refs/heads",
      ""
    )}`;
    if (_delete) {
      await GitRefManager.deleteRef({ fs, gitdir, ref: ref });
    } else {
      await GitRefManager.writeRef({ fs, gitdir, ref: ref, value: oid });
    }
  }
  if (result.ok && Object.values(result.refs).every((result) => result.ok)) {
    return result;
  } else {
    const prettyDetails = Object.entries(result.refs).filter(([k, v]) => !v.ok).map(([k, v]) => `
  - ${k}: ${v.error}`).join("");
    throw new GitPushError(prettyDetails, result);
  }
}
async function push({
  fs,
  http,
  onProgress,
  onMessage,
  onAuth,
  onAuthSuccess,
  onAuthFailure,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  remoteRef,
  remote = "origin",
  url,
  force = false,
  delete: _delete = false,
  corsProxy,
  headers = {},
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("http", http);
    assertParameter("gitdir", gitdir);
    return await _push({
      fs: new FileSystem(fs),
      cache,
      http,
      onProgress,
      onMessage,
      onAuth,
      onAuthSuccess,
      onAuthFailure,
      gitdir,
      ref,
      remoteRef,
      remote,
      url,
      force,
      delete: _delete,
      corsProxy,
      headers
    });
  } catch (err) {
    err.caller = "git.push";
    throw err;
  }
}
async function resolveBlob({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({ fs, cache, gitdir, oid });
  if (type === "tag") {
    oid = GitAnnotatedTag.from(object).parse().object;
    return resolveBlob({ fs, cache, gitdir, oid });
  }
  if (type !== "blob") {
    throw new ObjectTypeError(oid, type, "blob");
  }
  return { oid, blob: new UintArray(object) };
}
async function _readBlob({
  fs,
  cache,
  gitdir,
  oid,
  filepath = void 
}) {
  if (filepath !== void ) {
    oid = await resolveFilepath({ fs, cache, gitdir, oid, filepath });
  }
  const blob = await resolveBlob({
    fs,
    cache,
    gitdir,
    oid
  });
  return blob;
}
async function readBlob({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  filepath,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readBlob({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      filepath
    });
  } catch (err) {
    err.caller = "git.readBlob";
    throw err;
  }
}
async function readCommit({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readCommit({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid
    });
  } catch (err) {
    err.caller = "git.readCommit";
    throw err;
  }
}
async function _readNote({
  fs,
  cache,
  gitdir,
  ref = "refs/notes/commits",
  oid
}) {
  const parent = await GitRefManager.resolve({ gitdir, fs, ref });
  const { blob } = await _readBlob({
    fs,
    cache,
    gitdir,
    oid: parent,
    filepath: oid
  });
  return blob;
}
async function readNote({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("oid", oid);
    return await _readNote({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      ref,
      oid
    });
  } catch (err) {
    err.caller = "git.readNote";
    throw err;
  }
}
async function readObject({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  format = "parsed",
  filepath = void ,
  encoding = void ,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    const fs = new FileSystem(_fs);
    if (filepath !== void ) {
      oid = await resolveFilepath({
        fs,
        cache,
        gitdir,
        oid,
        filepath
      });
    }
    const _format = format === "parsed" ? "content" : format;
    const result = await _readObject({
      fs,
      cache,
      gitdir,
      oid,
      format: _format
    });
    result.oid = oid;
    if (format === "parsed") {
      result.format = "parsed";
      switch (result.type) {
        case "commit":
          result.object = GitCommit.from(result.object).parse();
          break;
        case "tree":
          result.object = GitTree.from(result.object).entries();
          break;
        case "blob":
          if (encoding) {
            result.object = result.object.toString(encoding);
          } else {
            result.object = new UintArray(result.object);
            result.format = "content";
          }
          break;
        case "tag":
          result.object = GitAnnotatedTag.from(result.object).parse();
          break;
        default:
          throw new ObjectTypeError(
            result.oid,
            result.type,
            "blob|commit|tag|tree"
          );
      }
    } else if (result.format === "deflated" || result.format === "wrapped") {
      result.type = result.format;
    }
    return result;
  } catch (err) {
    err.caller = "git.readObject";
    throw err;
  }
}
async function _readTag({ fs, cache, gitdir, oid }) {
  const { type, object } = await _readObject({
    fs,
    cache,
    gitdir,
    oid,
    format: "content"
  });
  if (type !== "tag") {
    throw new ObjectTypeError(oid, type, "tag");
  }
  const tag = GitAnnotatedTag.from(object);
  const result = {
    oid,
    tag: tag.parse(),
    payload: tag.payload()
  };
  return result;
}
async function readTag({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readTag({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid
    });
  } catch (err) {
    err.caller = "git.readTag";
    throw err;
  }
}
async function readTree({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  oid,
  filepath = void ,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    return await _readTree({
      fs: new FileSystem(fs),
      cache,
      gitdir,
      oid,
      filepath
    });
  } catch (err) {
    err.caller = "git.readTree";
    throw err;
  }
}
async function remove({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    await GitIndexManager.acquire(
      { fs: new FileSystem(_fs), gitdir, cache },
      async function(index) {
        index.delete({ filepath });
      }
    );
  } catch (err) {
    err.caller = "git.remove";
    throw err;
  }
}
async function _removeNote({
  fs,
  cache,
  onSign,
  gitdir,
  ref = "refs/notes/commits",
  oid,
  author,
  committer,
  signingKey
}) {
  let parent;
  try {
    parent = await GitRefManager.resolve({ gitdir, fs, ref });
  } catch (err) {
    if (!(err instanceof NotFoundError)) {
      throw err;
    }
  }
  const result = await _readTree({
    fs,
    gitdir,
    oid: parent || "bdccbebaebfdfbee"
  });
  let tree = result.tree;
  tree = tree.filter((entry) => entry.path !== oid);
  const treeOid = await _writeTree({
    fs,
    gitdir,
    tree
  });
  const commitOid = await _commit({
    fs,
    cache,
    onSign,
    gitdir,
    ref,
    tree: treeOid,
    parent: parent && [parent],
    message: `Note removed by 'isomorphic-git removeNote'
`,
    author,
    committer,
    signingKey
  });
  return commitOid;
}
async function removeNote({
  fs: _fs,
  onSign,
  dir,
  gitdir = join(dir, ".git"),
  ref = "refs/notes/commits",
  oid,
  author: _author,
  committer: _committer,
  signingKey,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("oid", oid);
    const fs = new FileSystem(_fs);
    const author = await normalizeAuthorObject({ fs, gitdir, author: _author });
    if (!author)
      throw new MissingNameError("author");
    const committer = await normalizeCommitterObject({
      fs,
      gitdir,
      author,
      committer: _committer
    });
    if (!committer)
      throw new MissingNameError("committer");
    return await _removeNote({
      fs,
      cache,
      onSign,
      gitdir,
      ref,
      oid,
      author,
      committer,
      signingKey
    });
  } catch (err) {
    err.caller = "git.removeNote";
    throw err;
  }
}
async function _renameBranch({
  fs,
  gitdir,
  oldref,
  ref,
  checkout: checkout = false
}) {
  if (ref !== import_clean_git_ref.default.clean(ref)) {
    throw new InvalidRefNameError(ref, import_clean_git_ref.default.clean(ref));
  }
  if (oldref !== import_clean_git_ref.default.clean(oldref)) {
    throw new InvalidRefNameError(oldref, import_clean_git_ref.default.clean(oldref));
  }
  const fulloldref = `refs/heads/${oldref}`;
  const fullnewref = `refs/heads/${ref}`;
  const newexist = await GitRefManager.exists({ fs, gitdir, ref: fullnewref });
  if (newexist) {
    throw new AlreadyExistsError("branch", ref, false);
  }
  const value = await GitRefManager.resolve({
    fs,
    gitdir,
    ref: fulloldref,
    depth: 
  });
  await GitRefManager.writeRef({ fs, gitdir, ref: fullnewref, value });
  await GitRefManager.deleteRef({ fs, gitdir, ref: fulloldref });
  if (checkout) {
    await GitRefManager.writeSymbolicRef({
      fs,
      gitdir,
      ref: "HEAD",
      value: fullnewref
    });
  }
}
async function renameBranch({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  oldref,
  checkout: checkout = false
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("oldref", oldref);
    return await _renameBranch({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      oldref,
      checkout: checkout
    });
  } catch (err) {
    err.caller = "git.renameBranch";
    throw err;
  }
}
async function hashObject$({ gitdir, type, object }) {
  return shasum(GitObject.wrap({ type, object }));
}
async function resetIndex({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  ref,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    let oid;
    let workdirOid;
    try {
      oid = await GitRefManager.resolve({ fs, gitdir, ref: ref || "HEAD" });
    } catch (e) {
      if (ref) {
        throw e;
      }
    }
    if (oid) {
      try {
        oid = await resolveFilepath({
          fs,
          cache,
          gitdir,
          oid,
          filepath
        });
      } catch (e) {
        oid = null;
      }
    }
    let stats = {
      ctime: / @__PURE__ / new Date(),
      mtime: / @__PURE__ / new Date(),
      dev: ,
      ino: ,
      mode: ,
      uid: ,
      gid: ,
      size: 
    };
    const object = dir && await fs.read(join(dir, filepath));
    if (object) {
      workdirOid = await hashObject$({
        gitdir,
        type: "blob",
        object
      });
      if (oid === workdirOid) {
        stats = await fs.lstat(join(dir, filepath));
      }
    }
    await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      index.delete({ filepath });
      if (oid) {
        index.insert({ filepath, stats, oid });
      }
    });
  } catch (err) {
    err.caller = "git.reset";
    throw err;
  }
}
async function resolveRef({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  depth
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const oid = await GitRefManager.resolve({
      fs: new FileSystem(fs),
      gitdir,
      ref,
      depth
    });
    return oid;
  } catch (err) {
    err.caller = "git.resolveRef";
    throw err;
  }
}
async function setConfig({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  path: path,
  value,
  append: append = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("path", path);
    const fs = new FileSystem(_fs);
    const config = await GitConfigManager.get({ fs, gitdir });
    if (append) {
      await config.append(path, value);
    } else {
      await config.set(path, value);
    }
    await GitConfigManager.save({ fs, gitdir, config });
  } catch (err) {
    err.caller = "git.setConfig";
    throw err;
  }
}
async function status({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  filepath,
  cache = {}
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    const ignored = await GitIgnoreManager.isIgnored({
      fs,
      gitdir,
      dir,
      filepath
    });
    if (ignored) {
      return "ignored";
    }
    const headTree = await getHeadTree({ fs, cache, gitdir });
    const treeOid = await getOidAtPath({
      fs,
      cache,
      gitdir,
      tree: headTree,
      path: filepath
    });
    const indexEntry = await GitIndexManager.acquire(
      { fs, gitdir, cache },
      async function(index) {
        for (const entry of index) {
          if (entry.path === filepath)
            return entry;
        }
        return null;
      }
    );
    const stats = await fs.lstat(join(dir, filepath));
    const H = treeOid !== null;
    const I = indexEntry !== null;
    const W = stats !== null;
    const getWorkdirOid = async () => {
      if (I && !compareStats(indexEntry, stats)) {
        return indexEntry.oid;
      } else {
        const object = await fs.read(join(dir, filepath));
        const workdirOid = await hashObject$({
          gitdir,
          type: "blob",
          object
        });
        if (I && indexEntry.oid === workdirOid) {
          if (stats.size !== -) {
            GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
              index.insert({ filepath, stats, oid: workdirOid });
            });
          }
        }
        return workdirOid;
      }
    };
    if (!H && !W && !I)
      return "absent";
    if (!H && !W && I)
      return "absent";
    if (!H && W && !I)
      return "added";
    if (!H && W && I) {
      const workdirOid = await getWorkdirOid();
      return workdirOid === indexEntry.oid ? "added" : "added";
    }
    if (H && !W && !I)
      return "deleted";
    if (H && !W && I) {
      return treeOid === indexEntry.oid ? "deleted" : "deleted";
    }
    if (H && W && !I) {
      const workdirOid = await getWorkdirOid();
      return workdirOid === treeOid ? "undeleted" : "undeletemodified";
    }
    if (H && W && I) {
      const workdirOid = await getWorkdirOid();
      if (workdirOid === treeOid) {
        return workdirOid === indexEntry.oid ? "unmodified" : "unmodified";
      } else {
        return workdirOid === indexEntry.oid ? "modified" : "modified";
      }
    }
  } catch (err) {
    err.caller = "git.status";
    throw err;
  }
}
async function getOidAtPath({ fs, cache, gitdir, tree, path: path }) {
  if (typeof path === "string")
    path = path.split("/");
  const dirname = path.shift();
  for (const entry of tree) {
    if (entry.path === dirname) {
      if (path.length === ) {
        return entry.oid;
      }
      const { type, object } = await _readObject({
        fs,
        cache,
        gitdir,
        oid: entry.oid
      });
      if (type === "tree") {
        const tree = GitTree.from(object);
        return getOidAtPath({ fs, cache, gitdir, tree: tree, path: path });
      }
      if (type === "blob") {
        throw new ObjectTypeError(entry.oid, type, "blob", path.join("/"));
      }
    }
  }
  return null;
}
async function getHeadTree({ fs, cache, gitdir }) {
  let oid;
  try {
    oid = await GitRefManager.resolve({ fs, gitdir, ref: "HEAD" });
  } catch (e) {
    if (e instanceof NotFoundError) {
      return [];
    }
  }
  const { tree } = await _readTree({ fs, cache, gitdir, oid });
  return tree;
}
async function statusMatrix({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  ref = "HEAD",
  filepaths = ["."],
  filter,
  cache = {},
  ignored: shouldIgnore = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const fs = new FileSystem(_fs);
    return await _walk({
      fs,
      cache,
      dir,
      gitdir,
      trees: [TREE({ ref }), WORKDIR(), STAGE()],
      map: async function(filepath, [head, workdir, stage]) {
        if (!head && !stage && workdir) {
          if (!shouldIgnore) {
            const isIgnored = await GitIgnoreManager.isIgnored({
              fs,
              dir,
              filepath
            });
            if (isIgnored) {
              return null;
            }
          }
        }
        if (!filepaths.some((base) => worthWalking(filepath, base))) {
          return null;
        }
        if (filter) {
          if (!filter(filepath))
            return;
        }
        const [headType, workdirType, stageType] = await Promise.all([
          head && head.type(),
          workdir && workdir.type(),
          stage && stage.type()
        ]);
        const isBlob = [headType, workdirType, stageType].includes("blob");
        if ((headType === "tree" || headType === "special") && !isBlob)
          return;
        if (headType === "commit")
          return null;
        if ((workdirType === "tree" || workdirType === "special") && !isBlob)
          return;
        if (stageType === "commit")
          return null;
        if ((stageType === "tree" || stageType === "special") && !isBlob)
          return;
        const headOid = headType === "blob" ? await head.oid() : void ;
        const stageOid = stageType === "blob" ? await stage.oid() : void ;
        let workdirOid;
        if (headType !== "blob" && workdirType === "blob" && stageType !== "blob") {
          workdirOid = "";
        } else if (workdirType === "blob") {
          workdirOid = await workdir.oid();
        }
        const entry = [void , headOid, workdirOid, stageOid];
        const result = entry.map((value) => entry.indexOf(value));
        result.shift();
        return [filepath, ...result];
      }
    });
  } catch (err) {
    err.caller = "git.statusMatrix";
    throw err;
  }
}
async function tag({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  object,
  force = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    const fs = new FileSystem(_fs);
    if (ref === void ) {
      throw new MissingParameterError("ref");
    }
    ref = ref.startsWith("refs/tags/") ? ref : `refs/tags/${ref}`;
    const value = await GitRefManager.resolve({
      fs,
      gitdir,
      ref: object || "HEAD"
    });
    if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
      throw new AlreadyExistsError("tag", ref);
    }
    await GitRefManager.writeRef({ fs, gitdir, ref, value });
  } catch (err) {
    err.caller = "git.tag";
    throw err;
  }
}
async function updateIndex({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  cache = {},
  filepath,
  oid,
  mode,
  add: add,
  remove: remove,
  force
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("filepath", filepath);
    const fs = new FileSystem(_fs);
    if (remove) {
      return await GitIndexManager.acquire(
        { fs, gitdir, cache },
        async function(index) {
          let fileStats;
          if (!force) {
            fileStats = await fs.lstat(join(dir, filepath));
            if (fileStats) {
              if (fileStats.isDirectory()) {
                throw new InvalidFilepathError("directory");
              }
              return;
            }
          }
          if (index.has({ filepath })) {
            index.delete({
              filepath
            });
          }
        }
      );
    }
    let fileStats;
    if (!oid) {
      fileStats = await fs.lstat(join(dir, filepath));
      if (!fileStats) {
        throw new NotFoundError(
          `file at "${filepath}" on disk and "remove" not set`
        );
      }
      if (fileStats.isDirectory()) {
        throw new InvalidFilepathError("directory");
      }
    }
    return await GitIndexManager.acquire({ fs, gitdir, cache }, async function(index) {
      if (!add && !index.has({ filepath })) {
        throw new NotFoundError(
          `file at "${filepath}" in index and "add" not set`
        );
      }
      let stats = {
        ctime: / @__PURE__ / new Date(),
        mtime: / @__PURE__ / new Date(),
        dev: ,
        ino: ,
        mode,
        uid: ,
        gid: ,
        size: 
      };
      if (!oid) {
        stats = fileStats;
        const object = stats.isSymbolicLink() ? await fs.readlink(join(dir, filepath)) : await fs.read(join(dir, filepath));
        oid = await _writeObject({
          fs,
          gitdir,
          type: "blob",
          format: "content",
          object
        });
      }
      index.insert({
        filepath,
        oid,
        stats
      });
      return oid;
    });
  } catch (err) {
    err.caller = "git.updateIndex";
    throw err;
  }
}
function version() {
  try {
    return pkg.version;
  } catch (err) {
    err.caller = "git.version";
    throw err;
  }
}
async function walk({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  trees,
  map,
  reduce,
  iterate,
  cache = {}
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("trees", trees);
    return await _walk({
      fs: new FileSystem(fs),
      cache,
      dir,
      gitdir,
      trees,
      map,
      reduce,
      iterate
    });
  } catch (err) {
    err.caller = "git.walk";
    throw err;
  }
}
async function writeBlob({ fs, dir, gitdir = join(dir, ".git"), blob }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("blob", blob);
    return await _writeObject({
      fs: new FileSystem(fs),
      gitdir,
      type: "blob",
      object: blob,
      format: "content"
    });
  } catch (err) {
    err.caller = "git.writeBlob";
    throw err;
  }
}
async function _writeCommit({ fs, gitdir, commit: commit }) {
  const object = GitCommit.from(commit).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "commit",
    object,
    format: "content"
  });
  return oid;
}
async function writeCommit({
  fs,
  dir,
  gitdir = join(dir, ".git"),
  commit: commit
}) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("commit", commit);
    return await _writeCommit({
      fs: new FileSystem(fs),
      gitdir,
      commit: commit
    });
  } catch (err) {
    err.caller = "git.writeCommit";
    throw err;
  }
}
async function writeObject({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  type,
  object,
  format = "parsed",
  oid,
  encoding = void 
}) {
  try {
    const fs = new FileSystem(_fs);
    if (format === "parsed") {
      switch (type) {
        case "commit":
          object = GitCommit.from(object).toObject();
          break;
        case "tree":
          object = GitTree.from(object).toObject();
          break;
        case "blob":
          object = Buffer.from(object, encoding);
          break;
        case "tag":
          object = GitAnnotatedTag.from(object).toObject();
          break;
        default:
          throw new ObjectTypeError(oid || "", type, "blob|commit|tag|tree");
      }
      format = "content";
    }
    oid = await _writeObject({
      fs,
      gitdir,
      type,
      object,
      oid,
      format
    });
    return oid;
  } catch (err) {
    err.caller = "git.writeObject";
    throw err;
  }
}
async function writeRef({
  fs: _fs,
  dir,
  gitdir = join(dir, ".git"),
  ref,
  value,
  force = false,
  symbolic = false
}) {
  try {
    assertParameter("fs", _fs);
    assertParameter("gitdir", gitdir);
    assertParameter("ref", ref);
    assertParameter("value", value);
    const fs = new FileSystem(_fs);
    if (ref !== import_clean_git_ref.default.clean(ref)) {
      throw new InvalidRefNameError(ref, import_clean_git_ref.default.clean(ref));
    }
    if (!force && await GitRefManager.exists({ fs, gitdir, ref })) {
      throw new AlreadyExistsError("ref", ref);
    }
    if (symbolic) {
      await GitRefManager.writeSymbolicRef({
        fs,
        gitdir,
        ref,
        value
      });
    } else {
      value = await GitRefManager.resolve({
        fs,
        gitdir,
        ref: value
      });
      await GitRefManager.writeRef({
        fs,
        gitdir,
        ref,
        value
      });
    }
  } catch (err) {
    err.caller = "git.writeRef";
    throw err;
  }
}
async function _writeTag({ fs, gitdir, tag: tag }) {
  const object = GitAnnotatedTag.from(tag).toObject();
  const oid = await _writeObject({
    fs,
    gitdir,
    type: "tag",
    object,
    format: "content"
  });
  return oid;
}
async function writeTag({ fs, dir, gitdir = join(dir, ".git"), tag: tag }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("tag", tag);
    return await _writeTag({
      fs: new FileSystem(fs),
      gitdir,
      tag: tag
    });
  } catch (err) {
    err.caller = "git.writeTag";
    throw err;
  }
}
async function writeTree({ fs, dir, gitdir = join(dir, ".git"), tree }) {
  try {
    assertParameter("fs", fs);
    assertParameter("gitdir", gitdir);
    assertParameter("tree", tree);
    return await _writeTree({
      fs: new FileSystem(fs),
      gitdir,
      tree
    });
  } catch (err) {
    err.caller = "git.writeTree";
    throw err;
  }
}
var index = {
  Errors,
  STAGE,
  TREE,
  WORKDIR,
  add,
  abortMerge,
  addNote,
  addRemote,
  annotatedTag,
  branch,
  checkout,
  clone,
  commit,
  getConfig,
  getConfigAll,
  setConfig,
  currentBranch,
  deleteBranch,
  deleteRef,
  deleteRemote,
  deleteTag,
  expandOid,
  expandRef,
  fastForward,
  fetch,
  findMergeBase,
  findRoot,
  getRemoteInfo,
  getRemoteInfo,
  hashBlob,
  indexPack,
  init,
  isDescendent,
  isIgnored,
  listBranches,
  listFiles,
  listNotes,
  listRemotes,
  listServerRefs,
  listTags,
  log,
  merge,
  packObjects,
  pull,
  push,
  readBlob,
  readCommit,
  readNote,
  readObject,
  readTag,
  readTree,
  remove,
  removeNote,
  renameBranch,
  resetIndex,
  updateIndex,
  resolveRef,
  status,
  statusMatrix,
  tag,
  version,
  walk,
  writeBlob,
  writeCommit,
  writeObject,
  writeRef,
  writeTag,
  writeTree
};
var isomorphic_git_default = index;

// src/main.ts
var import_obsidian = require("obsidian");

// src/promiseQueue.ts
init_polyfill_buffer();
var PromiseQueue = class {
  constructor() {
    this.tasks = [];
  }
  addTask(task) {
    this.tasks.push(task);
    if (this.tasks.length === ) {
      this.handleTask();
    }
  }
  async handleTask() {
    if (this.tasks.length > ) {
      this.tasks[]().finally(() => {
        this.tasks.shift();
        this.handleTask();
      });
    }
  }
};

// src/settings.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");

// src/isomorphicGit.ts
init_polyfill_buffer();

// node_modules/.pnpm/diff@../node_modules/diff/lib/index.mjs
init_polyfill_buffer();
function Diff() {
}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var options = arguments.length >  && arguments[] !== void  ? arguments[] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    this.options = options;
    var self = this;
    function done(value) {
      if (callback) {
        setTimeout(function() {
          callback(void , value);
        }, );
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);
    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = ;
    var maxEditLength = newLen + oldLen;
    if (options.maxEditLength) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    var bestPath = [{
      newPos: -,
      components: []
    }];
    var oldPos = this.extractCommon(bestPath[], newString, oldString, );
    if (bestPath[].newPos +  >= newLen && oldPos +  >= oldLen) {
      return done([{
        value: this.join(newString),
        count: newString.length
      }]);
    }
    function execEditLength() {
      for (var diagonalPath = -  editLength; diagonalPath <= editLength; diagonalPath += ) {
        var basePath = void ;
        var addPath = bestPath[diagonalPath - ], removePath = bestPath[diagonalPath + ], _oldPos = (removePath ? removePath.newPos : ) - diagonalPath;
        if (addPath) {
          bestPath[diagonalPath - ] = void ;
        }
        var canAdd = addPath && addPath.newPos +  < newLen, canRemove = removePath &&  <= _oldPos && _oldPos < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void ;
          continue;
        }
        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, void , true);
        } else {
          basePath = addPath;
          basePath.newPos++;
          self.pushComponent(basePath.components, true, void );
        }
        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);
        if (basePath.newPos +  >= newLen && _oldPos +  >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, );
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - ];
    if (last && last.added === added && last.removed === removed) {
      components[components.length - ] = {
        count: last.count + ,
        added,
        removed
      };
    } else {
      components.push({
        count: ,
        added,
        removed
      });
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length, oldLen = oldString.length, newPos = basePath.newPos, oldPos = newPos - diagonalPath, commonCount = ;
    while (newPos +  < newLen && oldPos +  < oldLen && this.equals(newString[newPos + ], oldString[oldPos + ])) {
      newPos++;
      oldPos++;
      commonCount++;
    }
    if (commonCount) {
      basePath.components.push({
        count: commonCount
      });
    }
    basePath.newPos = newPos;
    return oldPos;
  },
  equals: function equals(left, right) {
    if (this.options.comparator) {
      return this.options.comparator(left, right);
    } else {
      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i = ; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return value.split("");
  },
  join: function join(chars) {
    return chars.join("");
  }
};
function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = , componentLen = components.length, newPos = , oldPos = ;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });
        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
      if (componentPos && components[componentPos - ].added) {
        var tmp = components[componentPos - ];
        components[componentPos - ] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  }
  var lastComponent = components[componentLen - ];
  if (componentLen >  && typeof lastComponent.value === "string" && (lastComponent.added || lastComponent.removed) && diff.equals("", lastComponent.value)) {
    components[componentLen - ].value += lastComponent.value;
    components.pop();
  }
  return components;
}
function clonePath(path) {
  return {
    newPos: path.newPos,
    components: path.components.slice()
  };
}
var characterDiff = new Diff();
function diffChars(oldStr, newStr, options) {
  return characterDiff.diff(oldStr, newStr, options);
}
var extendedWordChars = /^[A-Za-z\xC-\uC\uC-\uD\uDE-\uFF\uE-\uEFF]+$/;
var reWhitespace = /\S/;
var wordDiff = new Diff();
wordDiff.equals = function(left, right) {
  if (this.options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};
wordDiff.tokenize = function(value) {
  var tokens = value.split(/([^\S\r\n]+|[()[\]{}'"\r\n]|\b)/);
  for (var i = ; i < tokens.length - ; i++) {
    if (!tokens[i + ] && tokens[i + ] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + ])) {
      tokens[i] += tokens[i + ];
      tokens.splice(i + , );
      i--;
    }
  }
  return tokens;
};
function diffWordsWithSpace(oldStr, newStr, options) {
  return wordDiff.diff(oldStr, newStr, options);
}
var lineDiff = new Diff();
lineDiff.tokenize = function(value) {
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - ]) {
    linesAndNewlines.pop();
  }
  for (var i = ; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];
    if (i %  && !this.options.newlineIsToken) {
      retLines[retLines.length - ] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }
      retLines.push(line);
    }
  }
  return retLines;
};
function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(, -);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:||)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = , arr = new Array(len); i < len; i++)
    arr[i] = arr[i];
  return arr;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var objectPrototypeToString = Object.prototype.toString;
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value) {
  var _this$options = this.options, undefinedReplacement = _this$options.undefinedReplacement, _this$options$stringi = _this$options.stringifyReplacer, stringifyReplacer = _this$options$stringi === void  ? function(k, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _this$options$stringi;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$"), right.replace(/,([\r\n])/g, "$"));
};
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i;
  for (i = ; i < stack.length; i += ) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = ; i < obj.length; i += ) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (obj.hasOwnProperty(_key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i = ; i < sortedKeys.length; i += ) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};
function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }
  if (typeof options.context === "undefined") {
    options.context = ;
  }
  var diff = diffLines(oldStr, newStr, options);
  if (!diff) {
    return;
  }
  diff.push({
    value: "",
    lines: []
  });
  function contextLines(lines) {
    return lines.map(function(entry) {
      return " " + entry;
    });
  }
  var hunks = [];
  var oldRangeStart = , newRangeStart = , curRange = [], oldLine = , newLine = ;
  var _loop = function _loop(i) {
    var current = diff[i], lines = current.lines || current.value.replace(/\n$/, "").split("\n");
    current.lines = lines;
    if (current.added || current.removed) {
      var _curRange;
      if (!oldRangeStart) {
        var prev = diff[i - ];
        oldRangeStart = oldLine;
        newRangeStart = newLine;
        if (prev) {
          curRange = options.context >  ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      }
      (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function(entry) {
        return (current.added ? "+" : "-") + entry;
      })));
      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      if (oldRangeStart) {
        if (lines.length <= options.context   && i < diff.length - ) {
          var _curRange;
          (_curRange = curRange).push.apply(_curRange, _toConsumableArray(contextLines(lines)));
        } else {
          var _curRange;
          var contextSize = Math.min(lines.length, options.context);
          (_curRange = curRange).push.apply(_curRange, _toConsumableArray(contextLines(lines.slice(, contextSize))));
          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };
          if (i >= diff.length -  && lines.length <= options.context) {
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            var noNlBeforeAdds = lines.length ==  && curRange.length > hunk.oldLines;
            if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > ) {
              curRange.splice(hunk.oldLines, , "\\ No newline at end of file");
            }
            if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
              curRange.push("\\ No newline at end of file");
            }
          }
          hunks.push(hunk);
          oldRangeStart = ;
          newRangeStart = ;
          curRange = [];
        }
      }
      oldLine += lines.length;
      newLine += lines.length;
    }
  };
  for (var i = ; i < diff.length; i++) {
    _loop(i);
  }
  return {
    oldFileName,
    newFileName,
    oldHeader,
    newHeader,
    hunks
  };
}
function formatPatch(diff) {
  var ret = [];
  if (diff.oldFileName == diff.newFileName) {
    ret.push("Index: " + diff.oldFileName);
  }
  ret.push("===================================================================");
  ret.push("--- " + diff.oldFileName + (typeof diff.oldHeader === "undefined" ? "" : "	" + diff.oldHeader));
  ret.push("+++ " + diff.newFileName + (typeof diff.newHeader === "undefined" ? "" : "	" + diff.newHeader));
  for (var i = ; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i];
    if (hunk.oldLines === ) {
      hunk.oldStart -= ;
    }
    if (hunk.newLines === ) {
      hunk.newStart -= ;
    }
    ret.push("@@ -" + hunk.oldStart + "," + hunk.oldLines + " +" + hunk.newStart + "," + hunk.newLines + " @@");
    ret.push.apply(ret, hunk.lines);
  }
  return ret.join("\n") + "\n";
}
function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));
}
function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}

// src/isomorphicGit.ts
var import_obsidian = require("obsidian");

// src/gitManager.ts
init_polyfill_buffer();
var GitManager = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.app = plugin.app;
  }
  getVaultPath(path) {
    if (this.plugin.settings.basePath) {
      return this.plugin.settings.basePath + "/" + path;
    } else {
      return path;
    }
  }
  getPath(path, relativeToVault) {
    return relativeToVault && this.plugin.settings.basePath.length >  ? path.substring(this.plugin.settings.basePath.length + ) : path;
  }
  _getTreeStructure(children, beginLength = ) {
    const list = [];
    children = [...children];
    while (children.length > ) {
      const first = children.first();
      const restPath = first.path.substring(beginLength);
      if (restPath.contains("/")) {
        const title = restPath.substring(, restPath.indexOf("/"));
        const childrenWithSameTitle = children.filter((item) => {
          return item.path.substring(beginLength).startsWith(title + "/");
        });
        childrenWithSameTitle.forEach((item) => children.remove(item));
        const path = first.path.substring(
          ,
          restPath.indexOf("/") + beginLength
        );
        list.push({
          title,
          path: path,
          vaultPath: this.getVaultPath(path),
          children: this._getTreeStructure(
            childrenWithSameTitle,
            (beginLength >  ? beginLength + title.length : title.length) + 
          )
        });
      } else {
        list.push({
          title: restPath,
          data: first,
          path: first.path,
          vaultPath: this.getVaultPath(first.path)
        });
        children.remove(first);
      }
    }
    return list;
  }
  /
    Sorts the children and simplifies the title
    If a node only contains another subdirectory, that subdirectory is moved up one level and integrated into the parent node
   /
  simplify(tree) {
    var _a, _b, _c, _d;
    for (const node of tree) {
      while (true) {
        const singleChild = ((_a = node.children) == null ? void  : _a.length) == ;
        const singleChildIsDir = ((_c = (_b = node.children) == null ? void  : _b.first()) == null ? void  : _c.data) == void ;
        if (!(node.children != void  && singleChild && singleChildIsDir))
          break;
        const child = node.children.first();
        node.title += "/" + child.title;
        node.data = child.data;
        node.path = child.path;
        node.vaultPath = child.vaultPath;
        node.children = child.children;
      }
      if (node.children != void ) {
        this.simplify(node.children);
      }
      (_d = node.children) == null ? void  : _d.sort((a, b) => {
        const dirCompare = (b.data == void  ?  : ) - (a.data == void  ?  : );
        if (dirCompare != ) {
          return dirCompare;
        } else {
          return a.title.localeCompare(b.title);
        }
      });
    }
    return tree.sort((a, b) => {
      const dirCompare = (b.data == void  ?  : ) - (a.data == void  ?  : );
      if (dirCompare != ) {
        return dirCompare;
      } else {
        return a.title.localeCompare(b.title);
      }
    });
  }
  getTreeStructure(children) {
    const tree = this._getTreeStructure(children);
    const res = this.simplify(tree);
    return res;
  }
  async formatCommitMessage(template) {
    let status;
    if (template.includes("{{numFiles}}")) {
      status = await this.status();
      const numFiles = status.staged.length;
      template = template.replace("{{numFiles}}", String(numFiles));
    }
    if (template.includes("{{hostname}}")) {
      const hostname = this.plugin.localStorage.getHostname() || "";
      template = template.replace("{{hostname}}", hostname);
    }
    if (template.includes("{{files}}")) {
      status = status != null ? status : await this.status();
      const changeset = {};
      status.staged.forEach((value) => {
        if (value.index in changeset) {
          changeset[value.index].push(value.path);
        } else {
          changeset[value.index] = [value.path];
        }
      });
      const chunks = [];
      for (const [action, files] of Object.entries(changeset)) {
        chunks.push(action + " " + files.join(" "));
      }
      const files = chunks.join(", ");
      template = template.replace("{{files}}", files);
    }
    const moment = window.moment;
    template = template.replace(
      "{{date}}",
      moment().format(this.plugin.settings.commitDateFormat)
    );
    if (this.plugin.settings.listChangedFilesInMessageBody) {
      template = template + "\n\nAffected files:\n" + (status != null ? status : await this.status()).staged.map((e) => e.path).join("\n");
    }
    return template;
  }
};

// src/myAdapter.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
var MyAdapter = class {
  constructor(vault, plugin) {
    this.plugin = plugin;
    this.promises = {};
    this.adapter = vault.adapter;
    this.vault = vault;
    this.lastBasePath = this.plugin.settings.basePath;
    this.promises.readFile = this.readFile.bind(this);
    this.promises.writeFile = this.writeFile.bind(this);
    this.promises.readdir = this.readdir.bind(this);
    this.promises.mkdir = this.mkdir.bind(this);
    this.promises.rmdir = this.rmdir.bind(this);
    this.promises.stat = this.stat.bind(this);
    this.promises.unlink = this.unlink.bind(this);
    this.promises.lstat = this.lstat.bind(this);
    this.promises.readlink = this.readlink.bind(this);
    this.promises.symlink = this.symlink.bind(this);
  }
  async readFile(path, opts) {
    var _a;
    this.maybeLog("Read: " + path + JSON.stringify(opts));
    if (opts == "utf" || opts.encoding == "utf") {
      const file = this.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian.TFile) {
        this.maybeLog("Reuse");
        return this.vault.read(file);
      } else {
        return this.adapter.read(path);
      }
    } else {
      if (path.endsWith(this.gitDir + "/index")) {
        if (this.plugin.settings.basePath != this.lastBasePath) {
          this.clearIndex();
          this.lastBasePath = this.plugin.settings.basePath;
          return this.adapter.readBinary(path);
        }
        return (_a = this.index) != null ? _a : this.adapter.readBinary(path);
      }
      const file = this.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian.TFile) {
        this.maybeLog("Reuse");
        return this.vault.readBinary(file);
      } else {
        return this.adapter.readBinary(path);
      }
    }
  }
  async writeFile(path, data) {
    this.maybeLog("Write: " + path);
    if (typeof data === "string") {
      const file = this.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian.TFile) {
        return this.vault.modify(file, data);
      } else {
        return this.adapter.write(path, data);
      }
    } else {
      if (path.endsWith(this.gitDir + "/index")) {
        this.index = data;
        this.indexmtime = Date.now();
      } else {
        const file = this.vault.getAbstractFileByPath(path);
        if (file instanceof import_obsidian.TFile) {
          return this.vault.modifyBinary(file, data);
        } else {
          return this.adapter.writeBinary(path, data);
        }
      }
    }
  }
  async readdir(path) {
    if (path === ".")
      path = "/";
    const res = await this.adapter.list(path);
    const all = [...res.files, ...res.folders];
    let formattedAll;
    if (path !== "/") {
      formattedAll = all.map(
        (e) => (, import_obsidian.normalizePath)(e.substring(path.length))
      );
    } else {
      formattedAll = all;
    }
    return formattedAll;
  }
  async mkdir(path) {
    return this.adapter.mkdir(path);
  }
  async rmdir(path, opts) {
    var _a, _b;
    return this.adapter.rmdir(path, (_b = (_a = opts == null ? void  : opts.options) == null ? void  : _a.recursive) != null ? _b : false);
  }
  async stat(path) {
    if (path.endsWith(this.gitDir + "/index")) {
      if (this.index !== void  && this.indexctime != void  && this.indexmtime != void ) {
        return {
          isFile: () => true,
          isDirectory: () => false,
          isSymbolicLink: () => false,
          size: this.index.length,
          type: "file",
          ctimeMs: this.indexctime,
          mtimeMs: this.indexmtime
        };
      } else {
        const stat = await this.adapter.stat(path);
        if (stat == void ) {
          throw { code: "ENOENT" };
        }
        this.indexctime = stat.ctime;
        this.indexmtime = stat.mtime;
        return {
          ctimeMs: stat.ctime,
          mtimeMs: stat.mtime,
          size: stat.size,
          type: "file",
          isFile: () => true,
          isDirectory: () => false,
          isSymbolicLink: () => false
        };
      }
    }
    if (path === ".")
      path = "/";
    const file = this.vault.getAbstractFileByPath(path);
    this.maybeLog("Stat: " + path);
    if (file instanceof import_obsidian.TFile) {
      this.maybeLog("Reuse stat");
      return {
        ctimeMs: file.stat.ctime,
        mtimeMs: file.stat.mtime,
        size: file.stat.size,
        type: "file",
        isFile: () => true,
        isDirectory: () => false,
        isSymbolicLink: () => false
      };
    } else {
      const stat = await this.adapter.stat(path);
      if (stat) {
        return {
          ctimeMs: stat.ctime,
          mtimeMs: stat.mtime,
          size: stat.size,
          type: stat.type === "folder" ? "directory" : stat.type,
          isFile: () => stat.type === "file",
          isDirectory: () => stat.type === "folder",
          isSymbolicLink: () => false
        };
      } else {
        throw { code: "ENOENT" };
      }
    }
  }
  async unlink(path) {
    return this.adapter.remove(path);
  }
  async lstat(path) {
    return this.stat(path);
  }
  async readlink(path) {
    throw new Error(`readlink of (${path}) is not implemented.`);
  }
  async symlink(path) {
    throw new Error(`symlink of (${path}) is not implemented.`);
  }
  async saveAndClear() {
    if (this.index !== void ) {
      await this.adapter.writeBinary(
        this.plugin.gitManager.getVaultPath(this.gitDir + "/index"),
        this.index,
        {
          ctime: this.indexctime,
          mtime: this.indexmtime
        }
      );
    }
    this.clearIndex();
  }
  clearIndex() {
    this.index = void ;
    this.indexctime = void ;
    this.indexmtime = void ;
  }
  get gitDir() {
    return this.plugin.settings.gitDir || ".git";
  }
  maybeLog(text) {
  }
};

// src/types.ts
init_polyfill_buffer();

// src/ui/modals/generalModal.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
var generalModalConfigDefaults = {
  options: [],
  placeholder: "",
  allowEmpty: false,
  onlySelection: false,
  initialValue: void 
};
var GeneralModal = class extends import_obsidian.SuggestModal {
  constructor(config) {
    super(app);
    this.config = { ...generalModalConfigDefaults, ...config };
    this.setPlaceholder(this.config.placeholder);
  }
  open() {
    super.open();
    if (this.config.initialValue != void ) {
      this.inputEl.value = this.config.initialValue;
      this.inputEl.dispatchEvent(new Event("input"));
    }
    return new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  selectSuggestion(value, evt) {
    if (this.resolve) {
      let res;
      if (this.config.allowEmpty && value === " ")
        res = "";
      else if (value === "...")
        res = void ;
      else
        res = value;
      this.resolve(res);
    }
    super.selectSuggestion(value, evt);
  }
  onClose() {
    if (this.resolve)
      this.resolve(void );
  }
  getSuggestions(query) {
    if (this.config.onlySelection) {
      return this.config.options;
    } else if (this.config.allowEmpty) {
      return [query.length >  ? query : " ", ...this.config.options];
    } else {
      return [query.length >  ? query : "...", ...this.config.options];
    }
  }
  renderSuggestion(value, el) {
    el.setText(value);
  }
  onChooseSuggestion(item, evt) {
  }
};

// src/utils.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
var worthWalking = (filepath, root) => {
  if (filepath === "." || root == null || root.length ===  || root === ".") {
    return true;
  }
  if (root.length >= filepath.length) {
    return root.startsWith(filepath);
  } else {
    return filepath.startsWith(root);
  }
};
function getNewLeaf(event) {
  let leaf;
  if (event) {
    if (event.button ===  || event.button === ) {
      const type = import_obsidian.Keymap.isModEvent(event);
      leaf = app.workspace.getLeaf(type);
    }
  } else {
    leaf = app.workspace.getLeaf(false);
  }
  return leaf;
}
function splitRemoteBranch(remoteBranch) {
  const [remote, ...branch] = remoteBranch.split("/");
  return [remote, branch.length ===  ? void  : branch.join("/")];
}
function getDisplayPath(path) {
  if (path.endsWith("/"))
    return path;
  return path.split("/").last().replace(".md", "");
}

// src/isomorphicGit.ts
var IsomorphicGit = class extends GitManager {
  constructor(plugin) {
    super(plugin);
    this.FILE = ;
    this.HEAD = ;
    this.WORKDIR = ;
    this.STAGE = ;
    // Mapping from statusMatrix to git status codes based off git status --short
    // See: https://isomorphic-git.org/docs/en/statusMatrix
    this.status_mapping = {
      "": "  ",
      "": "AD",
      "": "??",
      "": "A ",
      "": "AM",
      "": "D ",
      "": " D",
      "": "MD",
      "": "DA",
      // Technically, two files: first one is deleted "D " and second one is untracked "??"
      "": "  ",
      "": "DA",
      // Same as ""
      "": " M",
      "": "M ",
      "": "MM"
    };
    this.noticeLength = ;
    this.fs = new MyAdapter(this.app.vault, this.plugin);
  }
  getRepo() {
    return {
      fs: this.fs,
      dir: this.plugin.settings.basePath,
      gitdir: this.plugin.settings.gitDir || void ,
      onAuth: () => {
        var _a, _b;
        return {
          username: (_a = this.plugin.localStorage.getUsername()) != null ? _a : void ,
          password: (_b = this.plugin.localStorage.getPassword()) != null ? _b : void 
        };
      },
      onAuthFailure: async () => {
        new import_obsidian.Notice(
          "Authentication failed. Please try with different credentials"
        );
        const username = await new GeneralModal({
          placeholder: "Specify your username"
        }).open();
        if (username) {
          const password = await new GeneralModal({
            placeholder: "Specify your password/personal access token"
          }).open();
          if (password) {
            this.plugin.localStorage.setUsername(username);
            this.plugin.localStorage.setPassword(password);
            return {
              username,
              password
            };
          }
        }
        return { cancel: true };
      },
      http: {
        async request({
          url,
          method,
          headers,
          body
        }) {
          if (body) {
            body = await collect(body);
            body = body.buffer;
          }
          const res = await (, import_obsidian.requestUrl)({
            url,
            method,
            headers,
            body,
            throw: false
          });
          return {
            url,
            method,
            headers: res.headers,
            body: [new UintArray(res.arrayBuffer)],
            statusCode: res.status,
            statusMessage: res.status.toString()
          };
        }
      }
    };
  }
  async wrapFS(call) {
    try {
      const res = await call;
      await this.fs.saveAndClear();
      return res;
    } catch (error) {
      await this.fs.saveAndClear();
      throw error;
    }
  }
  async status() {
    let notice;
    const timeout = window.setTimeout(function() {
      notice = new import_obsidian.Notice(
        "This takes longer: Getting status",
        this.noticeLength
      );
    }, e);
    try {
      this.plugin.setState( / status /);
      const status = (await this.wrapFS(isomorphic_git_default.statusMatrix({ ...this.getRepo() }))).map((row) => this.getFileStatusResult(row));
      const changed = status.filter(
        (fileStatus) => fileStatus.working_dir !== " "
      );
      const staged = status.filter(
        (fileStatus) => fileStatus.index !== " " && fileStatus.index !== "U"
      );
      const conflicted = [];
      window.clearTimeout(timeout);
      notice == null ? void  : notice.hide();
      return { changed, staged, conflicted };
    } catch (error) {
      window.clearTimeout(timeout);
      notice == null ? void  : notice.hide();
      this.plugin.displayError(error);
      throw error;
    }
  }
  async commitAll({
    message,
    status: status,
    unstagedFiles
  }) {
    try {
      await this.checkAuthorInfo();
      await this.stageAll({ status: status, unstagedFiles });
      return this.commit(message);
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async commit(message) {
    try {
      await this.checkAuthorInfo();
      this.plugin.setState( / commit /);
      const formatMessage = await this.formatCommitMessage(message);
      const hadConflict = this.plugin.localStorage.getConflict() === "true";
      let parent = void ;
      if (hadConflict) {
        const branchInfo = await this.branchInfo();
        parent = [branchInfo.current, branchInfo.tracking];
      }
      await this.wrapFS(
        isomorphic_git_default.commit({
          ...this.getRepo(),
          message: formatMessage,
          parent
        })
      );
      this.plugin.localStorage.setConflict("false");
      return;
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async stage(filepath, relativeToVault) {
    const gitPath = this.getPath(filepath, relativeToVault);
    let vaultPath;
    if (relativeToVault) {
      vaultPath = filepath;
    } else {
      vaultPath = this.getVaultPath(filepath);
    }
    try {
      this.plugin.setState( / add /);
      if (await this.app.vault.adapter.exists(vaultPath)) {
        await this.wrapFS(
          isomorphic_git_default.add({ ...this.getRepo(), filepath: gitPath })
        );
      } else {
        await this.wrapFS(
          isomorphic_git_default.remove({ ...this.getRepo(), filepath: gitPath })
        );
      }
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async stageAll({
    dir,
    status: status,
    unstagedFiles
  }) {
    try {
      if (status) {
        await Promise.all(
          status.changed.map(
            (file) => file.working_dir !== "D" ? this.wrapFS(
              isomorphic_git_default.add({
                ...this.getRepo(),
                filepath: file.path
              })
            ) : isomorphic_git_default.remove({
              ...this.getRepo(),
              filepath: file.path
            })
          )
        );
      } else {
        const filesToStage = unstagedFiles != null ? unstagedFiles : await this.getUnstagedFiles(dir != null ? dir : ".");
        await Promise.all(
          filesToStage.map(
            ({ filepath, deleted }) => deleted ? isomorphic_git_default.remove({ ...this.getRepo(), filepath }) : this.wrapFS(
              isomorphic_git_default.add({ ...this.getRepo(), filepath })
            )
          )
        );
      }
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async unstage(filepath, relativeToVault) {
    try {
      this.plugin.setState( / add /);
      filepath = this.getPath(filepath, relativeToVault);
      await this.wrapFS(
        isomorphic_git_default.resetIndex({ ...this.getRepo(), filepath })
      );
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async unstageAll({
    dir,
    status: status
  }) {
    try {
      let staged;
      if (status) {
        staged = status.staged.map((file) => file.path);
      } else {
        const res = await this.getStagedFiles(dir != null ? dir : ".");
        staged = res.map(({ filepath }) => filepath);
      }
      await this.wrapFS(
        Promise.all(
          staged.map(
            (file) => isomorphic_git_default.resetIndex({ ...this.getRepo(), filepath: file })
          )
        )
      );
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async discard(filepath) {
    try {
      this.plugin.setState( / add /);
      await this.wrapFS(
        isomorphic_git_default.checkout({
          ...this.getRepo(),
          filepaths: [filepath],
          force: true
        })
      );
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async discardAll({
    dir,
    status: status
  }) {
    let files = [];
    if (status) {
      if (dir != void ) {
        files = status.changed.filter((file) => file.path.startsWith(dir)).map((file) => file.path);
      } else {
        files = status.changed.map((file) => file.path);
      }
    } else {
      files = (await this.getUnstagedFiles(dir)).map(
        ({ filepath }) => filepath
      );
    }
    try {
      await this.wrapFS(
        isomorphic_git_default.checkout({
          ...this.getRepo(),
          filepaths: files,
          force: true
        })
      );
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  getProgressText(action, event) {
    let out = `${action} progress:`;
    if (event.phase) {
      out = `${out} ${event.phase}:`;
    }
    if (event.loaded) {
      out = `${out} ${event.loaded}`;
      if (event.total) {
        out = `${out} of ${event.total}`;
      }
    }
    return out;
  }
  resolveRef(ref) {
    return this.wrapFS(isomorphic_git_default.resolveRef({ ...this.getRepo(), ref }));
  }
  async pull() {
    const progressNotice = this.showNotice("Initializing pull");
    try {
      this.plugin.setState( / pull /);
      const localCommit = await this.resolveRef("HEAD");
      await this.fetch();
      const branchInfo = await this.branchInfo();
      await this.checkAuthorInfo();
      const mergeRes = await this.wrapFS(
        isomorphic_git_default.merge({
          ...this.getRepo(),
          ours: branchInfo.current,
          theirs: branchInfo.tracking,
          abortOnConflict: false
        })
      );
      if (!mergeRes.alreadyMerged) {
        await this.wrapFS(
          isomorphic_git_default.checkout({
            ...this.getRepo(),
            ref: branchInfo.current,
            onProgress: (progress) => {
              if (progressNotice !== void ) {
                progressNotice.noticeEl.innerText = this.getProgressText("Checkout", progress);
              }
            },
            remote: branchInfo.remote
          })
        );
      }
      progressNotice == null ? void  : progressNotice.hide();
      const upstreamCommit = await this.resolveRef("HEAD");
      const changedFiles = await this.getFileChangesCount(
        localCommit,
        upstreamCommit
      );
      this.showNotice("Finished pull", false);
      return changedFiles.map((file) => ({
        path: file.path,
        working_dir: "P",
        index: "P",
        vault_path: this.getVaultPath(file.path)
      }));
    } catch (error) {
      progressNotice == null ? void  : progressNotice.hide();
      if (error instanceof Errors.MergeConflictError) {
        this.plugin.handleConflict(
          error.data.filepaths.map((file) => this.getVaultPath(file))
        );
      }
      this.plugin.displayError(error);
      throw error;
    }
  }
  async push() {
    if (!await this.canPush()) {
      return ;
    }
    const progressNotice = this.showNotice("Initializing push");
    try {
      this.plugin.setState( / status /);
      const status = await this.branchInfo();
      const trackingBranch = status.tracking;
      const currentBranch = status.current;
      const numChangedFiles = (await this.getFileChangesCount(currentBranch, trackingBranch)).length;
      this.plugin.setState( / push /);
      await this.wrapFS(
        isomorphic_git_default.push({
          ...this.getRepo(),
          onProgress: (progress) => {
            if (progressNotice !== void ) {
              progressNotice.noticeEl.innerText = this.getProgressText("Pushing", progress);
            }
          }
        })
      );
      progressNotice == null ? void  : progressNotice.hide();
      return numChangedFiles;
    } catch (error) {
      progressNotice == null ? void  : progressNotice.hide();
      this.plugin.displayError(error);
      throw error;
    }
  }
  async getUnpushedCommits() {
    const status = await this.branchInfo();
    const trackingBranch = status.tracking;
    const currentBranch = status.current;
    if (trackingBranch == null || currentBranch == null) {
      return ;
    }
    const localCommit = await this.resolveRef(currentBranch);
    const upstreamCommit = await this.resolveRef(trackingBranch);
    const changedFiles = await this.getFileChangesCount(
      localCommit,
      upstreamCommit
    );
    return changedFiles.length;
  }
  async canPush() {
    const status = await this.branchInfo();
    const trackingBranch = status.tracking;
    const currentBranch = status.current;
    const current = await this.resolveRef(currentBranch);
    const tracking = await this.resolveRef(trackingBranch);
    return current != tracking;
  }
  async checkRequirements() {
    const headExists = await this.plugin.app.vault.adapter.exists(
      `${this.getRepo().dir}/.git/HEAD`
    );
    return headExists ? "valid" : "missing-repo";
  }
  async branchInfo() {
    var _a, _b;
    try {
      const current = await isomorphic_git_default.currentBranch(this.getRepo()) || "";
      const branches = await isomorphic_git_default.listBranches(this.getRepo());
      const remote = (_a = await this.getConfig(`branch.${current}.remote`)) != null ? _a : "origin";
      const trackingBranch = (_b = await this.getConfig(`branch.${current}.merge`)) == null ? void  : _b.split("refs/heads")[];
      const tracking = trackingBranch ? remote + trackingBranch : void ;
      return {
        current,
        tracking,
        branches,
        remote
      };
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async getCurrentRemote() {
    var _a;
    const current = await isomorphic_git_default.currentBranch(this.getRepo()) || "";
    const remote = (_a = await this.getConfig(`branch.${current}.remote`)) != null ? _a : "origin";
    return remote;
  }
  async checkout(branch, remote) {
    try {
      return this.wrapFS(
        isomorphic_git_default.checkout({
          ...this.getRepo(),
          ref: branch,
          force: !!remote,
          remote
        })
      );
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async createBranch(branch) {
    try {
      await this.wrapFS(
        isomorphic_git_default.branch({ ...this.getRepo(), ref: branch, checkout: true })
      );
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async deleteBranch(branch) {
    try {
      await this.wrapFS(
        isomorphic_git_default.deleteBranch({ ...this.getRepo(), ref: branch })
      );
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async branchIsMerged(branch) {
    return true;
  }
  async init() {
    try {
      await this.wrapFS(isomorphic_git_default.init(this.getRepo()));
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async clone(url, dir, depth) {
    const progressNotice = this.showNotice("Initializing clone");
    try {
      await this.wrapFS(
        isomorphic_git_default.clone({
          ...this.getRepo(),
          dir,
          url,
          depth,
          onProgress: (progress) => {
            if (progressNotice !== void ) {
              progressNotice.noticeEl.innerText = this.getProgressText("Cloning", progress);
            }
          }
        })
      );
      progressNotice == null ? void  : progressNotice.hide();
    } catch (error) {
      progressNotice == null ? void  : progressNotice.hide();
      this.plugin.displayError(error);
      throw error;
    }
  }
  async setConfig(path, value) {
    try {
      return this.wrapFS(
        isomorphic_git_default.setConfig({
          ...this.getRepo(),
          path: path,
          value
        })
      );
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async getConfig(path) {
    try {
      return this.wrapFS(
        isomorphic_git_default.getConfig({
          ...this.getRepo(),
          path: path
        })
      );
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async fetch(remote) {
    const progressNotice = this.showNotice("Initializing fetch");
    try {
      const args = {
        ...this.getRepo(),
        onProgress: (progress) => {
          if (progressNotice !== void ) {
            progressNotice.noticeEl.innerText = this.getProgressText("Fetching", progress);
          }
        },
        remote: remote != null ? remote : await this.getCurrentRemote()
      };
      await this.wrapFS(isomorphic_git_default.fetch(args));
      progressNotice == null ? void  : progressNotice.hide();
    } catch (error) {
      this.plugin.displayError(error);
      progressNotice == null ? void  : progressNotice.hide();
      throw error;
    }
  }
  async setRemote(name, url) {
    try {
      await this.wrapFS(
        isomorphic_git_default.addRemote({
          ...this.getRepo(),
          remote: name,
          url,
          force: true
        })
      );
    } catch (error) {
      this.plugin.displayError(error);
      throw error;
    }
  }
  async getRemoteBranches(remote) {
    let remoteBranches = [];
    remoteBranches.push(
      ...await this.wrapFS(
        isomorphic_git_default.listBranches({ ...this.getRepo(), remote })
      )
    );
    remoteBranches.remove("HEAD");
    remoteBranches = remoteBranches.map((e) => `${remote}/${e}`);
    return remoteBranches;
  }
  async getRemotes() {
    return (await this.wrapFS(isomorphic_git_default.listRemotes({ ...this.getRepo() }))).map(
      (remoteUrl) => remoteUrl.remote
    );
  }
  async removeRemote(remoteName) {
    await this.wrapFS(
      isomorphic_git_default.deleteRemote({ ...this.getRepo(), remote: remoteName })
    );
  }
  async getRemoteUrl(remote) {
    var _a;
    return (_a = (await this.wrapFS(isomorphic_git_default.listRemotes({ ...this.getRepo() }))).filter((item) => item.remote == remote)[]) == null ? void  : _a.url;
  }
  async log(_, __ = true, limit) {
    const logs = await this.wrapFS(
      isomorphic_git_default.log({ ...this.getRepo(), depth: limit })
    );
    return Promise.all(
      logs.map(async (log) => {
        const completeMessage = log.commit.message.split("\n\n");
        return {
          message: completeMessage[],
          body: completeMessage.slice().join("\n\n"),
          date: new Date(
            log.commit.committer.timestamp
          ).toDateString(),
          diff: {
            changed: ,
            files: (await this.getFileChangesCount(
              log.commit.parent.first(),
              log.oid
            )).map((item) => {
              return {
                path: item.path,
                status: item.type,
                vault_path: this.getVaultPath(item.path),
                hash: log.oid,
                binary: void 
              };
            })
          },
          hash: log.oid,
          refs: []
        };
      })
    );
  }
  updateBasePath(basePath) {
    this.getRepo().dir = basePath;
  }
  async updateUpstreamBranch(remoteBranch) {
    const [remote, branch] = splitRemoteBranch(remoteBranch);
    const branchInfo = await this.branchInfo();
    await this.setConfig(
      `branch.${branchInfo.current}.merge`,
      `refs/heads/${branch}`
    );
    await this.setConfig(`branch.${branch}.remote`, remote);
  }
  updateGitPath(gitPath) {
    return;
  }
  async getFileChangesCount(commitHash, commitHash) {
    return this.walkDifference({
      walkers: [
        isomorphic_git_default.TREE({ ref: commitHash }),
        isomorphic_git_default.TREE({ ref: commitHash })
      ]
    });
  }
  async walkDifference({
    walkers,
    dir: base
  }) {
    const res = await this.wrapFS(
      isomorphic_git_default.walk({
        ...this.getRepo(),
        trees: walkers,
        map: async function(filepath, [A, B]) {
          if (!worthWalking(filepath, base)) {
            return null;
          }
          if (await (A == null ? void  : A.type()) === "tree" || await (B == null ? void  : B.type()) === "tree") {
            return;
          }
          const Aoid = await (A == null ? void  : A.oid());
          const Boid = await (B == null ? void  : B.oid());
          let type = "equal";
          if (Aoid !== Boid) {
            type = "M";
          }
          if (Aoid === void ) {
            type = "A";
          }
          if (Boid === void ) {
            type = "D";
          }
          if (Aoid === void  && Boid === void ) {
            console.log("Something weird happened:");
            console.log(A);
            console.log(B);
          }
          if (type === "equal") {
            return;
          }
          return {
            path: filepath,
            type
          };
        }
      })
    );
    return res;
  }
  async getStagedFiles(dir = ".") {
    const res = await this.walkDifference({
      walkers: [isomorphic_git_default.TREE({ ref: "HEAD" }), isomorphic_git_default.STAGE()],
      dir
    });
    return res.map((file) => {
      return {
        vault_path: this.getVaultPath(file.path),
        filepath: file.path
      };
    });
  }
  async getUnstagedFiles(base = ".") {
    let notice;
    const timeout = window.setTimeout(function() {
      notice = new import_obsidian.Notice(
        "This takes longer: Getting status",
        this.noticeLength
      );
    }, e);
    try {
      const repo = this.getRepo();
      const res = await this.wrapFS(
        //Modified from `git.statusMatrix`
        isomorphic_git_default.walk({
          ...repo,
          trees: [isomorphic_git_default.WORKDIR(), isomorphic_git_default.STAGE()],
          map: async function(filepath, [workdir, stage]) {
            if (!stage && workdir) {
              const isIgnored = await isomorphic_git_default.isIgnored({
                ...repo,
                filepath
              });
              if (isIgnored) {
                return null;
              }
            }
            if (!worthWalking(filepath, base)) {
              return null;
            }
            const [workdirType, stageType] = await Promise.all([
              workdir && workdir.type(),
              stage && stage.type()
            ]);
            const isBlob = [workdirType, stageType].includes(
              "blob"
            );
            if ((workdirType === "tree" || workdirType === "special") && !isBlob)
              return;
            if (stageType === "commit")
              return null;
            if ((stageType === "tree" || stageType === "special") && !isBlob)
              return;
            const stageOid = stageType === "blob" ? await stage.oid() : void ;
            let workdirOid;
            if (workdirType === "blob" && stageType !== "blob") {
              workdirOid = "";
            } else if (workdirType === "blob") {
              workdirOid = await workdir.oid();
            }
            if (!workdirOid) {
              return {
                filepath,
                deleted: true
              };
            }
            if (workdirOid !== stageOid) {
              return {
                filepath,
                deleted: false
              };
            }
            return null;
          }
        })
      );
      window.clearTimeout(timeout);
      notice == null ? void  : notice.hide();
      return res;
    } catch (error) {
      window.clearTimeout(timeout);
      notice == null ? void  : notice.hide();
      this.plugin.displayError(error);
      throw error;
    }
  }
  async getDiffString(filePath, stagedChanges = false, hash) {
    const vaultPath = this.getVaultPath(filePath);
    const map = async (file, [A]) => {
      if (filePath == file) {
        const oid = await A.oid();
        const contents = await isomorphic_git_default.readBlob({
          ...this.getRepo(),
          oid
        });
        return contents.blob;
      }
    };
    if (hash) {
      const commitContent = await readBlob({
        ...this.getRepo(),
        filepath: filePath,
        oid: hash
      }).then((headBlob) => new TextDecoder().decode(headBlob.blob)).catch((err) => {
        if (err instanceof isomorphic_git_default.Errors.NotFoundError)
          return void ;
        throw err;
      });
      const commit = await isomorphic_git_default.readCommit({
        ...this.getRepo(),
        oid: hash
      });
      const previousContent = await readBlob({
        ...this.getRepo(),
        filepath: filePath,
        oid: commit.commit.parent.first()
      }).then((headBlob) => new TextDecoder().decode(headBlob.blob)).catch((err) => {
        if (err instanceof isomorphic_git_default.Errors.NotFoundError)
          return void ;
        throw err;
      });
      const diff = createPatch(
        vaultPath,
        previousContent != null ? previousContent : "",
        commitContent != null ? commitContent : ""
      );
      return diff;
    }
    const stagedBlob = (await isomorphic_git_default.walk({
      ...this.getRepo(),
      trees: [isomorphic_git_default.STAGE()],
      map
    })).first();
    const stagedContent = new TextDecoder().decode(stagedBlob);
    if (stagedChanges) {
      const headContent = await this.resolveRef("HEAD").then(
        (oid) => readBlob({
          ...this.getRepo(),
          filepath: filePath,
          oid
        })
      ).then((headBlob) => new TextDecoder().decode(headBlob.blob)).catch((err) => {
        if (err instanceof isomorphic_git_default.Errors.NotFoundError)
          return void ;
        throw err;
      });
      const diff = createPatch(
        vaultPath,
        headContent != null ? headContent : "",
        stagedContent
      );
      return diff;
    } else {
      let workdirContent;
      if (await app.vault.adapter.exists(vaultPath)) {
        workdirContent = await app.vault.adapter.read(vaultPath);
      } else {
        workdirContent = "";
      }
      const diff = createPatch(vaultPath, stagedContent, workdirContent);
      return diff;
    }
  }
  async getLastCommitTime() {
    const repo = this.getRepo();
    const oid = await this.resolveRef("HEAD");
    const commit = await isomorphic_git_default.readCommit({ ...repo, oid });
    const date = commit.commit.committer.timestamp;
    return new Date(date  e);
  }
  getFileStatusResult(row) {
    const status = this.status_mapping[`${row[this.HEAD]}${row[this.WORKDIR]}${row[this.STAGE]}`];
    return {
      index: status[] == "?" ? "U" : status[],
      working_dir: status[] == "?" ? "U" : status[],
      path: row[this.FILE],
      vault_path: this.getVaultPath(row[this.FILE])
    };
  }
  async checkAuthorInfo() {
    const name = await this.getConfig("user.name");
    const email = await this.getConfig("user.email");
    if (!name || !email) {
      throw "Git author information is not set. Please set it in the settings.";
    }
  }
  showNotice(message, infinity = true) {
    if (!this.plugin.settings.disablePopups) {
      return new import_obsidian.Notice(
        message,
        infinity ? this.noticeLength : void 
      );
    }
  }
};
function fromValue(value) {
  let queue = [value];
  return {
    next() {
      return Promise.resolve({
        done: queue.length === ,
        value: queue.pop()
      });
    },
    return() {
      queue = [];
      return {};
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function getIterator(iterable) {
  if (iterable[Symbol.asyncIterator]) {
    return iterable[Symbol.asyncIterator]();
  }
  if (iterable[Symbol.iterator]) {
    return iterable[Symbol.iterator]();
  }
  if (iterable.next) {
    return iterable;
  }
  return fromValue(iterable);
}
async function forAwait(iterable, cb) {
  const iter = getIterator(iterable);
  while (true) {
    const { value, done } = await iter.next();
    if (value)
      await cb(value);
    if (done)
      break;
  }
  if (iter.return)
    iter.return();
}
async function collect(iterable) {
  let size = ;
  const buffers = [];
  await forAwait(iterable, (value) => {
    buffers.push(value);
    size += value.byteLength;
  });
  const result = new UintArray(size);
  let nextIndex = ;
  for (const buffer of buffers) {
    result.set(buffer, nextIndex);
    nextIndex += buffer.byteLength;
  }
  return result;
}

// src/simpleGit.ts
init_polyfill_buffer();
var import_child_process = require("child_process");
var import_debug = __toESM(require_browser());
var import_obsidian = require("obsidian");
var path = __toESM(require("path"));
var import_path = require("path");

// node_modules/.pnpm/github.com+Vinzent+git-js@badbceadfbababfa_supports-color@../node_modules/simple-git/dist/esm/index.js
init_polyfill_buffer();
var import_file_exists = __toESM(require_dist(), );
var import_debug = __toESM(require_browser(), );
var import_child_process = require("child_process");
var import_promise_deferred = __toESM(require_dist(), );
var import_promise_deferred = __toESM(require_dist(), );
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (, fn[__getOwnPropNames(fn)[]])(fn = )), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (, cb[__getOwnPropNames(cb)[]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, copyDefault, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = / @__PURE__ / ((cache) => {
  return (module, temp) => {
    return cache && cache.get(module) || (temp = __reExport(__markAsModule({}), module, ), cache && cache.set(module, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? / @__PURE__ / new WeakMap() : );
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var GitError;
var init_git_error = __esm({
  "src/lib/errors/git-error.ts"() {
    GitError = class extends Error {
      constructor(task, message) {
        super(message);
        this.task = task;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
  }
});
var GitResponseError;
var init_git_response_error = __esm({
  "src/lib/errors/git-response-error.ts"() {
    init_git_error();
    GitResponseError = class extends GitError {
      constructor(git, message) {
        super(void , message || String(git));
        this.git = git;
      }
    };
  }
});
var TaskConfigurationError;
var init_task_configuration_error = __esm({
  "src/lib/errors/task-configuration-error.ts"() {
    init_git_error();
    TaskConfigurationError = class extends GitError {
      constructor(message) {
        super(void , message);
      }
    };
  }
});
function asFunction(source) {
  return typeof source === "function" ? source : NOOP;
}
function isUserFunction(source) {
  return typeof source === "function" && source !== NOOP;
}
function splitOn(input, char) {
  const index = input.indexOf(char);
  if (index <= ) {
    return [input, ""];
  }
  return [input.substr(, index), input.substr(index + )];
}
function first(input, offset = ) {
  return isArrayLike(input) && input.length > offset ? input[offset] : void ;
}
function last(input, offset = ) {
  if (isArrayLike(input) && input.length > offset) {
    return input[input.length -  - offset];
  }
}
function isArrayLike(input) {
  return !!(input && typeof input.length === "number");
}
function toLinesWithContent(input = "", trimmed = true, separator = "\n") {
  return input.split(separator).reduce((output, line) => {
    const lineContent = trimmed ? line.trim() : line;
    if (lineContent) {
      output.push(lineContent);
    }
    return output;
  }, []);
}
function forEachLineWithContent(input, callback) {
  return toLinesWithContent(input, true).map((line) => callback(line));
}
function folderExists(path) {
  return (, import_file_exists.exists)(path, import_file_exists.FOLDER);
}
function append(target, item) {
  if (Array.isArray(target)) {
    if (!target.includes(item)) {
      target.push(item);
    }
  } else {
    target.add(item);
  }
  return item;
}
function including(target, item) {
  if (Array.isArray(target) && !target.includes(item)) {
    target.push(item);
  }
  return target;
}
function remove(target, item) {
  if (Array.isArray(target)) {
    const index = target.indexOf(item);
    if (index >= ) {
      target.splice(index, );
    }
  } else {
    target.delete(item);
  }
  return item;
}
function asArray(source) {
  return Array.isArray(source) ? source : [source];
}
function asStringArray(source) {
  return asArray(source).map(String);
}
function asNumber(source, onNaN = ) {
  if (source == null) {
    return onNaN;
  }
  const num = parseInt(source, );
  return isNaN(num) ? onNaN : num;
}
function prefixedArray(input, prefix) {
  const output = [];
  for (let i = , max = input.length; i < max; i++) {
    output.push(prefix, input[i]);
  }
  return output;
}
function bufferToString(input) {
  return (Array.isArray(input) ? Buffer.concat(input) : input).toString("utf-");
}
function pick(source, properties) {
  return Object.assign({}, ...properties.map((property) => property in source ? { [property]: source[property] } : {}));
}
function delay(duration = ) {
  return new Promise((done) => setTimeout(done, duration));
}
var NULL;
var NOOP;
var objectToString;
var init_util = __esm({
  "src/lib/utils/util.ts"() {
    NULL = "\";
    NOOP = () => {
    };
    objectToString = Object.prototype.toString.call.bind(Object.prototype.toString);
  }
});
function filterType(input, filter, def) {
  if (filter(input)) {
    return input;
  }
  return arguments.length >  ? def : void ;
}
function filterPrimitives(input, omit) {
  return /number|string|boolean/.test(typeof input) && (!omit || !omit.includes(typeof input));
}
function filterPlainObject(input) {
  return !!input && objectToString(input) === "[object Object]";
}
function filterFunction(input) {
  return typeof input === "function";
}
var filterArray;
var filterString;
var filterStringArray;
var filterStringOrStringArray;
var filterHasLength;
var init_argument_filters = __esm({
  "src/lib/utils/argument-filters.ts"() {
    init_util();
    filterArray = (input) => {
      return Array.isArray(input);
    };
    filterString = (input) => {
      return typeof input === "string";
    };
    filterStringArray = (input) => {
      return Array.isArray(input) && input.every(filterString);
    };
    filterStringOrStringArray = (input) => {
      return filterString(input) || Array.isArray(input) && input.every(filterString);
    };
    filterHasLength = (input) => {
      if (input == null || "number|boolean|function".includes(typeof input)) {
        return false;
      }
      return Array.isArray(input) || typeof input === "string" || typeof input.length === "number";
    };
  }
});
var ExitCodes;
var init_exit_codes = __esm({
  "src/lib/utils/exit-codes.ts"() {
    ExitCodes = / @__PURE__ / ((ExitCodes) => {
      ExitCodes[ExitCodes["SUCCESS"] = ] = "SUCCESS";
      ExitCodes[ExitCodes["ERROR"] = ] = "ERROR";
      ExitCodes[ExitCodes["NOT_FOUND"] = -] = "NOT_FOUND";
      ExitCodes[ExitCodes["UNCLEAN"] = ] = "UNCLEAN";
      return ExitCodes;
    })(ExitCodes || {});
  }
});
var GitOutputStreams;
var init_git_output_streams = __esm({
  "src/lib/utils/git-output-streams.ts"() {
    GitOutputStreams = class {
      constructor(stdOut, stdErr) {
        this.stdOut = stdOut;
        this.stdErr = stdErr;
      }
      asStrings() {
        return new GitOutputStreams(this.stdOut.toString("utf"), this.stdErr.toString("utf"));
      }
    };
  }
});
var LineParser;
var RemoteLineParser;
var init_line_parser = __esm({
  "src/lib/utils/line-parser.ts"() {
    LineParser = class {
      constructor(regExp, useMatches) {
        this.matches = [];
        this.parse = (line, target) => {
          this.resetMatches();
          if (!this._regExp.every((reg, index) => this.addMatch(reg, index, line(index)))) {
            return false;
          }
          return this.useMatches(target, this.prepareMatches()) !== false;
        };
        this._regExp = Array.isArray(regExp) ? regExp : [regExp];
        if (useMatches) {
          this.useMatches = useMatches;
        }
      }
      useMatches(target, match) {
        throw new Error(`LineParser:useMatches not implemented`);
      }
      resetMatches() {
        this.matches.length = ;
      }
      prepareMatches() {
        return this.matches;
      }
      addMatch(reg, index, line) {
        const matched = line && reg.exec(line);
        if (matched) {
          this.pushMatch(index, matched);
        }
        return !!matched;
      }
      pushMatch(_index, matched) {
        this.matches.push(...matched.slice());
      }
    };
    RemoteLineParser = class extends LineParser {
      addMatch(reg, index, line) {
        return /^remote:\s/.test(String(line)) && super.addMatch(reg, index, line);
      }
      pushMatch(index, matched) {
        if (index >  || matched.length > ) {
          super.pushMatch(index, matched);
        }
      }
    };
  }
});
function createInstanceConfig(...options) {
  const baseDir = process.cwd();
  const config = Object.assign(__spreadValues({ baseDir }, defaultOptions), ...options.filter((o) => typeof o === "object" && o));
  config.baseDir = config.baseDir || baseDir;
  config.trimmed = config.trimmed === true;
  return config;
}
var defaultOptions;
var init_simple_git_options = __esm({
  "src/lib/utils/simple-git-options.ts"() {
    defaultOptions = {
      binary: "git",
      maxConcurrentProcesses: ,
      config: [],
      trimmed: false
    };
  }
});
function appendTaskOptions(options, commands = []) {
  if (!filterPlainObject(options)) {
    return commands;
  }
  return Object.keys(options).reduce((commands, key) => {
    const value = options[key];
    if (filterPrimitives(value, ["boolean"])) {
      commands.push(key + "=" + value);
    } else {
      commands.push(key);
    }
    return commands;
  }, commands);
}
function getTrailingOptions(args, initialPrimitive = , objectOnly = false) {
  const command = [];
  for (let i = , max = initialPrimitive <  ? args.length : initialPrimitive; i < max; i++) {
    if ("string|number".includes(typeof args[i])) {
      command.push(String(args[i]));
    }
  }
  appendTaskOptions(trailingOptionsArgument(args), command);
  if (!objectOnly) {
    command.push(...trailingArrayArgument(args));
  }
  return command;
}
function trailingArrayArgument(args) {
  const hasTrailingCallback = typeof last(args) === "function";
  return filterType(last(args, hasTrailingCallback ?  : ), filterArray, []);
}
function trailingOptionsArgument(args) {
  const hasTrailingCallback = filterFunction(last(args));
  return filterType(last(args, hasTrailingCallback ?  : ), filterPlainObject);
}
function trailingFunctionArgument(args, includeNoop = true) {
  const callback = asFunction(last(args));
  return includeNoop || isUserFunction(callback) ? callback : void ;
}
var init_task_options = __esm({
  "src/lib/utils/task-options.ts"() {
    init_argument_filters();
    init_util();
  }
});
function callTaskParser(parser, streams) {
  return parser(streams.stdOut, streams.stdErr);
}
function parseStringResponse(result, parsers, texts, trim = true) {
  asArray(texts).forEach((text) => {
    for (let lines = toLinesWithContent(text, trim), i = , max = lines.length; i < max; i++) {
      const line = (offset = ) => {
        if (i + offset >= max) {
          return;
        }
        return lines[i + offset];
      };
      parsers.some(({ parse: parse }) => parse(line, result));
    }
  });
  return result;
}
var init_task_parser = __esm({
  "src/lib/utils/task-parser.ts"() {
    init_util();
  }
});
var utils_exports = {};
__export(utils_exports, {
  ExitCodes: () => ExitCodes,
  GitOutputStreams: () => GitOutputStreams,
  LineParser: () => LineParser,
  NOOP: () => NOOP,
  NULL: () => NULL,
  RemoteLineParser: () => RemoteLineParser,
  append: () => append,
  appendTaskOptions: () => appendTaskOptions,
  asArray: () => asArray,
  asFunction: () => asFunction,
  asNumber: () => asNumber,
  asStringArray: () => asStringArray,
  bufferToString: () => bufferToString,
  callTaskParser: () => callTaskParser,
  createInstanceConfig: () => createInstanceConfig,
  delay: () => delay,
  filterArray: () => filterArray,
  filterFunction: () => filterFunction,
  filterHasLength: () => filterHasLength,
  filterPlainObject: () => filterPlainObject,
  filterPrimitives: () => filterPrimitives,
  filterString: () => filterString,
  filterStringArray: () => filterStringArray,
  filterStringOrStringArray: () => filterStringOrStringArray,
  filterType: () => filterType,
  first: () => first,
  folderExists: () => folderExists,
  forEachLineWithContent: () => forEachLineWithContent,
  getTrailingOptions: () => getTrailingOptions,
  including: () => including,
  isUserFunction: () => isUserFunction,
  last: () => last,
  objectToString: () => objectToString,
  parseStringResponse: () => parseStringResponse,
  pick: () => pick,
  prefixedArray: () => prefixedArray,
  remove: () => remove,
  splitOn: () => splitOn,
  toLinesWithContent: () => toLinesWithContent,
  trailingFunctionArgument: () => trailingFunctionArgument,
  trailingOptionsArgument: () => trailingOptionsArgument
});
var init_utils = __esm({
  "src/lib/utils/index.ts"() {
    init_argument_filters();
    init_exit_codes();
    init_git_output_streams();
    init_line_parser();
    init_simple_git_options();
    init_task_options();
    init_task_parser();
    init_util();
  }
});
var check_is_repo_exports = {};
__export(check_is_repo_exports, {
  CheckRepoActions: () => CheckRepoActions,
  checkIsBareRepoTask: () => checkIsBareRepoTask,
  checkIsRepoRootTask: () => checkIsRepoRootTask,
  checkIsRepoTask: () => checkIsRepoTask
});
function checkIsRepoTask(action) {
  switch (action) {
    case "bare":
      return checkIsBareRepoTask();
    case "root":
      return checkIsRepoRootTask();
  }
  const commands = ["rev-parse", "--is-inside-work-tree"];
  return {
    commands,
    format: "utf-",
    onError,
    parser
  };
}
function checkIsRepoRootTask() {
  const commands = ["rev-parse", "--git-dir"];
  return {
    commands,
    format: "utf-",
    onError,
    parser(path) {
      return /^\.(git)?$/.test(path.trim());
    }
  };
}
function checkIsBareRepoTask() {
  const commands = ["rev-parse", "--is-bare-repository"];
  return {
    commands,
    format: "utf-",
    onError,
    parser
  };
}
function isNotRepoMessage(error) {
  return /(Not a git repository|Kein Git-Repository)/i.test(String(error));
}
var CheckRepoActions;
var onError;
var parser;
var init_check_is_repo = __esm({
  "src/lib/tasks/check-is-repo.ts"() {
    init_utils();
    CheckRepoActions = / @__PURE__ / ((CheckRepoActions) => {
      CheckRepoActions["BARE"] = "bare";
      CheckRepoActions["IN_TREE"] = "tree";
      CheckRepoActions["IS_REPO_ROOT"] = "root";
      return CheckRepoActions;
    })(CheckRepoActions || {});
    onError = ({ exitCode }, error, done, fail) => {
      if (exitCode ===  && isNotRepoMessage(error)) {
        return done(Buffer.from("false"));
      }
      fail(error);
    };
    parser = (text) => {
      return text.trim() === "true";
    };
  }
});
function cleanSummaryParser(dryRun, text) {
  const summary = new CleanResponse(dryRun);
  const regexp = dryRun ? dryRunRemovalRegexp : removalRegexp;
  toLinesWithContent(text).forEach((line) => {
    const removed = line.replace(regexp, "");
    summary.paths.push(removed);
    (isFolderRegexp.test(removed) ? summary.folders : summary.files).push(removed);
  });
  return summary;
}
var CleanResponse;
var removalRegexp;
var dryRunRemovalRegexp;
var isFolderRegexp;
var init_CleanSummary = __esm({
  "src/lib/responses/CleanSummary.ts"() {
    init_utils();
    CleanResponse = class {
      constructor(dryRun) {
        this.dryRun = dryRun;
        this.paths = [];
        this.files = [];
        this.folders = [];
      }
    };
    removalRegexp = /^[a-z]+\s/i;
    dryRunRemovalRegexp = /^[a-z]+\s+[a-z]+\s/i;
    isFolderRegexp = /\/$/;
  }
});
var task_exports = {};
__export(task_exports, {
  EMPTY_COMMANDS: () => EMPTY_COMMANDS,
  adhocExecTask: () => adhocExecTask,
  configurationErrorTask: () => configurationErrorTask,
  isBufferTask: () => isBufferTask,
  isEmptyTask: () => isEmptyTask,
  straightThroughBufferTask: () => straightThroughBufferTask,
  straightThroughStringTask: () => straightThroughStringTask
});
function adhocExecTask(parser) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser: parser
  };
}
function configurationErrorTask(error) {
  return {
    commands: EMPTY_COMMANDS,
    format: "empty",
    parser() {
      throw typeof error === "string" ? new TaskConfigurationError(error) : error;
    }
  };
}
function straightThroughStringTask(commands, trimmed = false) {
  return {
    commands,
    format: "utf-",
    parser(text) {
      return trimmed ? String(text).trim() : text;
    }
  };
}
function straightThroughBufferTask(commands) {
  return {
    commands,
    format: "buffer",
    parser(buffer) {
      return buffer;
    }
  };
}
function isBufferTask(task) {
  return task.format === "buffer";
}
function isEmptyTask(task) {
  return task.format === "empty" || !task.commands.length;
}
var EMPTY_COMMANDS;
var init_task = __esm({
  "src/lib/tasks/task.ts"() {
    init_task_configuration_error();
    EMPTY_COMMANDS = [];
  }
});
var clean_exports = {};
__export(clean_exports, {
  CONFIG_ERROR_INTERACTIVE_MODE: () => CONFIG_ERROR_INTERACTIVE_MODE,
  CONFIG_ERROR_MODE_REQUIRED: () => CONFIG_ERROR_MODE_REQUIRED,
  CONFIG_ERROR_UNKNOWN_OPTION: () => CONFIG_ERROR_UNKNOWN_OPTION,
  CleanOptions: () => CleanOptions,
  cleanTask: () => cleanTask,
  cleanWithOptionsTask: () => cleanWithOptionsTask,
  isCleanOptionsArray: () => isCleanOptionsArray
});
function cleanWithOptionsTask(mode, customArgs) {
  const { cleanMode, options, valid } = getCleanOptions(mode);
  if (!cleanMode) {
    return configurationErrorTask(CONFIG_ERROR_MODE_REQUIRED);
  }
  if (!valid.options) {
    return configurationErrorTask(CONFIG_ERROR_UNKNOWN_OPTION + JSON.stringify(mode));
  }
  options.push(...customArgs);
  if (options.some(isInteractiveMode)) {
    return configurationErrorTask(CONFIG_ERROR_INTERACTIVE_MODE);
  }
  return cleanTask(cleanMode, options);
}
function cleanTask(mode, customArgs) {
  const commands = ["clean", `-${mode}`, ...customArgs];
  return {
    commands,
    format: "utf-",
    parser(text) {
      return cleanSummaryParser(mode === "n", text);
    }
  };
}
function isCleanOptionsArray(input) {
  return Array.isArray(input) && input.every((test) => CleanOptionValues.has(test));
}
function getCleanOptions(input) {
  let cleanMode;
  let options = [];
  let valid = { cleanMode: false, options: true };
  input.replace(/[^a-z]i/g, "").split("").forEach((char) => {
    if (isCleanMode(char)) {
      cleanMode = char;
      valid.cleanMode = true;
    } else {
      valid.options = valid.options && isKnownOption(options[options.length] = `-${char}`);
    }
  });
  return {
    cleanMode,
    options,
    valid
  };
}
function isCleanMode(cleanMode) {
  return cleanMode === "f" || cleanMode === "n";
}
function isKnownOption(option) {
  return /^-[a-z]$/i.test(option) && CleanOptionValues.has(option.charAt());
}
function isInteractiveMode(option) {
  if (/^-[^\-]/.test(option)) {
    return option.indexOf("i") > ;
  }
  return option === "--interactive";
}
var CONFIG_ERROR_INTERACTIVE_MODE;
var CONFIG_ERROR_MODE_REQUIRED;
var CONFIG_ERROR_UNKNOWN_OPTION;
var CleanOptions;
var CleanOptionValues;
var init_clean = __esm({
  "src/lib/tasks/clean.ts"() {
    init_CleanSummary();
    init_utils();
    init_task();
    CONFIG_ERROR_INTERACTIVE_MODE = "Git clean interactive mode is not supported";
    CONFIG_ERROR_MODE_REQUIRED = 'Git clean mode parameter ("n" or "f") is required';
    CONFIG_ERROR_UNKNOWN_OPTION = "Git clean unknown option found in: ";
    CleanOptions = / @__PURE__ / ((CleanOptions) => {
      CleanOptions["DRY_RUN"] = "n";
      CleanOptions["FORCE"] = "f";
      CleanOptions["IGNORED_INCLUDED"] = "x";
      CleanOptions["IGNORED_ONLY"] = "X";
      CleanOptions["EXCLUDING"] = "e";
      CleanOptions["QUIET"] = "q";
      CleanOptions["RECURSIVE"] = "d";
      return CleanOptions;
    })(CleanOptions || {});
    CleanOptionValues = / @__PURE__ / new Set([
      "i",
      ...asStringArray(Object.values(CleanOptions))
    ]);
  }
});
function configListParser(text) {
  const config = new ConfigList();
  for (const item of configParser(text)) {
    config.addValue(item.file, String(item.key), item.value);
  }
  return config;
}
function configGetParser(text, key) {
  let value = null;
  const values = [];
  const scopes = / @__PURE__ / new Map();
  for (const item of configParser(text, key)) {
    if (item.key !== key) {
      continue;
    }
    values.push(value = item.value);
    if (!scopes.has(item.file)) {
      scopes.set(item.file, []);
    }
    scopes.get(item.file).push(value);
  }
  return {
    key: key,
    paths: Array.from(scopes.keys()),
    scopes,
    value,
    values
  };
}
function configFilePath(filePath) {
  return filePath.replace(/^(file):/, "");
}
function configParser(text, requestedKey = null) {
  const lines = text.split("\");
  for (let i = , max = lines.length - ; i < max; ) {
    const file = configFilePath(lines[i++]);
    let value = lines[i++];
    let key = requestedKey;
    if (value.includes("\n")) {
      const line = splitOn(value, "\n");
      key = line[];
      value = line[];
    }
    yield { file, key: key, value };
  }
}
var ConfigList;
var init_ConfigList = __esm({
  "src/lib/responses/ConfigList.ts"() {
    init_utils();
    ConfigList = class {
      constructor() {
        this.files = [];
        this.values = / @__PURE__ / Object.create(null);
      }
      get all() {
        if (!this._all) {
          this._all = this.files.reduce((all, file) => {
            return Object.assign(all, this.values[file]);
          }, {});
        }
        return this._all;
      }
      addFile(file) {
        if (!(file in this.values)) {
          const latest = last(this.files);
          this.values[file] = latest ? Object.create(this.values[latest]) : {};
          this.files.push(file);
        }
        return this.values[file];
      }
      addValue(file, key, value) {
        const values = this.addFile(file);
        if (!values.hasOwnProperty(key)) {
          values[key] = value;
        } else if (Array.isArray(values[key])) {
          values[key].push(value);
        } else {
          values[key] = [values[key], value];
        }
        this._all = void ;
      }
    };
  }
});
function asConfigScope(scope, fallback) {
  if (typeof scope === "string" && GitConfigScope.hasOwnProperty(scope)) {
    return scope;
  }
  return fallback;
}
function addConfigTask(key, value, append, scope) {
  const commands = ["config", `--${scope}`];
  if (append) {
    commands.push("--add");
  }
  commands.push(key, value);
  return {
    commands,
    format: "utf-",
    parser(text) {
      return text;
    }
  };
}
function getConfigTask(key, scope) {
  const commands = ["config", "--null", "--show-origin", "--get-all", key];
  if (scope) {
    commands.splice(, , `--${scope}`);
  }
  return {
    commands,
    format: "utf-",
    parser(text) {
      return configGetParser(text, key);
    }
  };
}
function listConfigTask(scope) {
  const commands = ["config", "--list", "--show-origin", "--null"];
  if (scope) {
    commands.push(`--${scope}`);
  }
  return {
    commands,
    format: "utf-",
    parser(text) {
      return configListParser(text);
    }
  };
}
function config_default() {
  return {
    addConfig(key, value, ...rest) {
      return this._runTask(addConfigTask(key, value, rest[] === true, asConfigScope(
        rest[],
        "local"
        / local /
      )), trailingFunctionArgument(arguments));
    },
    getConfig(key, scope) {
      return this._runTask(getConfigTask(key, asConfigScope(scope, void )), trailingFunctionArgument(arguments));
    },
    listConfig(...rest) {
      return this._runTask(listConfigTask(asConfigScope(rest[], void )), trailingFunctionArgument(arguments));
    }
  };
}
var GitConfigScope;
var init_config = __esm({
  "src/lib/tasks/config.ts"() {
    init_ConfigList();
    init_utils();
    GitConfigScope = / @__PURE__ / ((GitConfigScope) => {
      GitConfigScope["system"] = "system";
      GitConfigScope["global"] = "global";
      GitConfigScope["local"] = "local";
      GitConfigScope["worktree"] = "worktree";
      return GitConfigScope;
    })(GitConfigScope || {});
  }
});
function grepQueryBuilder(...params) {
  return new GrepQuery().param(...params);
}
function parseGrep(grep) {
  const paths = / @__PURE__ / new Set();
  const results = {};
  forEachLineWithContent(grep, (input) => {
    const [path, line, preview] = input.split(NULL);
    paths.add(path);
    (results[path] = results[path] || []).push({
      line: asNumber(line),
      path: path,
      preview
    });
  });
  return {
    paths,
    results
  };
}
function grep_default() {
  return {
    grep(searchTerm) {
      const then = trailingFunctionArgument(arguments);
      const options = getTrailingOptions(arguments);
      for (const option of disallowedOptions) {
        if (options.includes(option)) {
          return this._runTask(configurationErrorTask(`git.grep: use of "${option}" is not supported.`), then);
        }
      }
      if (typeof searchTerm === "string") {
        searchTerm = grepQueryBuilder().param(searchTerm);
      }
      const commands = ["grep", "--null", "-n", "--full-name", ...options, ...searchTerm];
      return this._runTask({
        commands,
        format: "utf-",
        parser(stdOut) {
          return parseGrep(stdOut);
        }
      }, then);
    }
  };
}
var disallowedOptions;
var Query;
var _a;
var GrepQuery;
var init_grep = __esm({
  "src/lib/tasks/grep.ts"() {
    init_utils();
    init_task();
    disallowedOptions = ["-h"];
    Query = Symbol("grepQuery");
    GrepQuery = class {
      constructor() {
        this[_a] = [];
      }
      [(_a = Query, Symbol.iterator)]() {
        for (const query of this[Query]) {
          yield query;
        }
      }
      and(...and) {
        and.length && this[Query].push("--and", "(", ...prefixedArray(and, "-e"), ")");
        return this;
      }
      param(...param) {
        this[Query].push(...prefixedArray(param, "-e"));
        return this;
      }
    };
  }
});
var reset_exports = {};
__export(reset_exports, {
  ResetMode: () => ResetMode,
  getResetMode: () => getResetMode,
  resetTask: () => resetTask
});
function resetTask(mode, customArgs) {
  const commands = ["reset"];
  if (isValidResetMode(mode)) {
    commands.push(`--${mode}`);
  }
  commands.push(...customArgs);
  return straightThroughStringTask(commands);
}
function getResetMode(mode) {
  if (isValidResetMode(mode)) {
    return mode;
  }
  switch (typeof mode) {
    case "string":
    case "undefined":
      return "soft";
  }
  return;
}
function isValidResetMode(mode) {
  return ResetModes.includes(mode);
}
var ResetMode;
var ResetModes;
var init_reset = __esm({
  "src/lib/tasks/reset.ts"() {
    init_task();
    ResetMode = / @__PURE__ / ((ResetMode) => {
      ResetMode["MIXED"] = "mixed";
      ResetMode["SOFT"] = "soft";
      ResetMode["HARD"] = "hard";
      ResetMode["MERGE"] = "merge";
      ResetMode["KEEP"] = "keep";
      return ResetMode;
    })(ResetMode || {});
    ResetModes = Array.from(Object.values(ResetMode));
  }
});
function createLog() {
  return (, import_debug.default)("simple-git");
}
function prefixedLogger(to, prefix, forward) {
  if (!prefix || !String(prefix).replace(/\s/, "")) {
    return !forward ? to : (message, ...args) => {
      to(message, ...args);
      forward(message, ...args);
    };
  }
  return (message, ...args) => {
    to(`%s ${message}`, prefix, ...args);
    if (forward) {
      forward(message, ...args);
    }
  };
}
function childLoggerName(name, childDebugger, { namespace: parentNamespace }) {
  if (typeof name === "string") {
    return name;
  }
  const childNamespace = childDebugger && childDebugger.namespace || "";
  if (childNamespace.startsWith(parentNamespace)) {
    return childNamespace.substr(parentNamespace.length + );
  }
  return childNamespace || parentNamespace;
}
function createLogger(label, verbose, initialStep, infoDebugger = createLog()) {
  const labelPrefix = label && `[${label}]` || "";
  const spawned = [];
  const debugDebugger = typeof verbose === "string" ? infoDebugger.extend(verbose) : verbose;
  const key = childLoggerName(filterType(verbose, filterString), debugDebugger, infoDebugger);
  return step(initialStep);
  function sibling(name, initial) {
    return append(spawned, createLogger(label, key.replace(/^[^:]+/, name), initial, infoDebugger));
  }
  function step(phase) {
    const stepPrefix = phase && `[${phase}]` || "";
    const debug = debugDebugger && prefixedLogger(debugDebugger, stepPrefix) || NOOP;
    const info = prefixedLogger(infoDebugger, `${labelPrefix} ${stepPrefix}`, debug);
    return Object.assign(debugDebugger ? debug : info, {
      label,
      sibling,
      info,
      step
    });
  }
}
var init_git_logger = __esm({
  "src/lib/git-logger.ts"() {
    init_utils();
    import_debug.default.formatters.L = (value) => String(filterHasLength(value) ? value.length : "-");
    import_debug.default.formatters.B = (value) => {
      if (Buffer.isBuffer(value)) {
        return value.toString("utf");
      }
      return objectToString(value);
    };
  }
});
var _TasksPendingQueue;
var TasksPendingQueue;
var init_tasks_pending_queue = __esm({
  "src/lib/runners/tasks-pending-queue.ts"() {
    init_git_error();
    init_git_logger();
    _TasksPendingQueue = class {
      constructor(logLabel = "GitExecutor") {
        this.logLabel = logLabel;
        this._queue = / @__PURE__ / new Map();
      }
      withProgress(task) {
        return this._queue.get(task);
      }
      createProgress(task) {
        const name = _TasksPendingQueue.getName(task.commands[]);
        const logger = createLogger(this.logLabel, name);
        return {
          task,
          logger,
          name
        };
      }
      push(task) {
        const progress = this.createProgress(task);
        progress.logger("Adding task to the queue, commands = %o", task.commands);
        this._queue.set(task, progress);
        return progress;
      }
      fatal(err) {
        for (const [task, { logger }] of Array.from(this._queue.entries())) {
          if (task === err.task) {
            logger.info(`Failed %o`, err);
            logger(`Fatal exception, any as-yet un-started tasks run through this executor will not be attempted`);
          } else {
            logger.info(`A fatal exception occurred in a previous task, the queue has been purged: %o`, err.message);
          }
          this.complete(task);
        }
        if (this._queue.size !== ) {
          throw new Error(`Queue size should be zero after fatal: ${this._queue.size}`);
        }
      }
      complete(task) {
        const progress = this.withProgress(task);
        if (progress) {
          this._queue.delete(task);
        }
      }
      attempt(task) {
        const progress = this.withProgress(task);
        if (!progress) {
          throw new GitError(void , "TasksPendingQueue: attempt called for an unknown task");
        }
        progress.logger("Starting task");
        return progress;
      }
      static getName(name = "empty") {
        return `task:${name}:${++_TasksPendingQueue.counter}`;
      }
    };
    TasksPendingQueue = _TasksPendingQueue;
    TasksPendingQueue.counter = ;
  }
});
function pluginContext(task, commands) {
  return {
    method: first(task.commands) || "",
    commands
  };
}
function onErrorReceived(target, logger) {
  return (err) => {
    logger(`[ERROR] child process exception %o`, err);
    target.push(Buffer.from(String(err.stack), "ascii"));
  };
}
function onDataReceived(target, name, logger, output) {
  return (buffer) => {
    logger(`%s received %L bytes`, name, buffer);
    output(`%B`, buffer);
    target.push(buffer);
  };
}
var GitExecutorChain;
var init_git_executor_chain = __esm({
  "src/lib/runners/git-executor-chain.ts"() {
    init_git_error();
    init_task();
    init_utils();
    init_tasks_pending_queue();
    GitExecutorChain = class {
      constructor(_executor, _scheduler, _plugins) {
        this._executor = _executor;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = Promise.resolve();
        this._queue = new TasksPendingQueue();
      }
      get binary() {
        return this._executor.binary;
      }
      get cwd() {
        return this._cwd || this._executor.cwd;
      }
      set cwd(cwd) {
        this._cwd = cwd;
      }
      get env() {
        return this._executor.env;
      }
      get outputHandler() {
        return this._executor.outputHandler;
      }
      chain() {
        return this;
      }
      push(task) {
        this._queue.push(task);
        return this._chain = this._chain.then(() => this.attemptTask(task));
      }
      attemptTask(task) {
        return __async(this, null, function () {
          const onScheduleComplete = yield this._scheduler.next();
          const onQueueComplete = () => this._queue.complete(task);
          try {
            const { logger } = this._queue.attempt(task);
            return yield isEmptyTask(task) ? this.attemptEmptyTask(task, logger) : this.attemptRemoteTask(task, logger);
          } catch (e) {
            throw this.onFatalException(task, e);
          } finally {
            onQueueComplete();
            onScheduleComplete();
          }
        });
      }
      onFatalException(task, e) {
        const gitError = e instanceof GitError ? Object.assign(e, { task }) : new GitError(task, e && String(e));
        this._chain = Promise.resolve();
        this._queue.fatal(gitError);
        return gitError;
      }
      attemptRemoteTask(task, logger) {
        return __async(this, null, function () {
          const args = this._plugins.exec("spawn.args", [...task.commands], pluginContext(task, task.commands));
          const raw = yield this.gitResponse(task, this.binary, args, this.outputHandler, logger.step("SPAWN"));
          const outputStreams = yield this.handleTaskData(task, args, raw, logger.step("HANDLE"));
          logger(`passing response to task's parser as a %s`, task.format);
          if (isBufferTask(task)) {
            return callTaskParser(task.parser, outputStreams);
          }
          return callTaskParser(task.parser, outputStreams.asStrings());
        });
      }
      attemptEmptyTask(task, logger) {
        return __async(this, null, function () {
          logger(`empty task bypassing child process to call to task's parser`);
          return task.parser(this);
        });
      }
      handleTaskData(task, args, result, logger) {
        const { exitCode, rejection, stdOut, stdErr } = result;
        return new Promise((done, fail) => {
          logger(`Preparing to handle process response exitCode=%d stdOut=`, exitCode);
          const { error } = this._plugins.exec("task.error", { error: rejection }, __spreadValues(__spreadValues({}, pluginContext(task, args)), result));
          if (error && task.onError) {
            logger.info(`exitCode=%s handling with custom error handler`);
            return task.onError(result, error, (newStdOut) => {
              logger.info(`custom error handler treated as success`);
              logger(`custom error returned a %s`, objectToString(newStdOut));
              done(new GitOutputStreams(Array.isArray(newStdOut) ? Buffer.concat(newStdOut) : newStdOut, Buffer.concat(stdErr)));
            }, fail);
          }
          if (error) {
            logger.info(`handling as error: exitCode=%s stdErr=%s rejection=%o`, exitCode, stdErr.length, rejection);
            return fail(error);
          }
          logger.info(`retrieving task output complete`);
          done(new GitOutputStreams(Buffer.concat(stdOut), Buffer.concat(stdErr)));
        });
      }
      gitResponse(task, command, args, outputHandler, logger) {
        return __async(this, null, function () {
          const outputLogger = logger.sibling("output");
          const spawnOptions = this._plugins.exec("spawn.options", {
            cwd: this.cwd,
            env: this.env,
            windowsHide: true
          }, pluginContext(task, task.commands));
          return new Promise((done) => {
            const stdOut = [];
            const stdErr = [];
            logger.info(`%s %o`, command, args);
            logger("%O", spawnOptions);
            let rejection = this._beforeSpawn(task, args);
            if (rejection) {
              return done({
                stdOut,
                stdErr,
                exitCode: ,
                rejection
              });
            }
            this._plugins.exec("spawn.before", void , __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              kill(reason) {
                rejection = reason || rejection;
              }
            }));
            const spawned = (, import_child_process.spawn)(command, args, spawnOptions);
            spawned.stdout.on("data", onDataReceived(stdOut, "stdOut", logger, outputLogger.step("stdOut")));
            spawned.stderr.on("data", onDataReceived(stdErr, "stdErr", logger, outputLogger.step("stdErr")));
            spawned.on("error", onErrorReceived(stdErr, logger));
            if (outputHandler) {
              logger(`Passing child process stdOut/stdErr to custom outputHandler`);
              outputHandler(command, spawned.stdout, spawned.stderr, [...args]);
            }
            this._plugins.exec("spawn.after", void , __spreadProps(__spreadValues({}, pluginContext(task, args)), {
              spawned,
              close(exitCode, reason) {
                done({
                  stdOut,
                  stdErr,
                  exitCode,
                  rejection: rejection || reason
                });
              },
              kill(reason) {
                if (spawned.killed) {
                  return;
                }
                rejection = reason;
                spawned.kill("SIGINT");
              }
            }));
          });
        });
      }
      _beforeSpawn(task, args) {
        let rejection;
        this._plugins.exec("spawn.before", void , __spreadProps(__spreadValues({}, pluginContext(task, args)), {
          kill(reason) {
            rejection = reason || rejection;
          }
        }));
        return rejection;
      }
    };
  }
});
var git_executor_exports = {};
__export(git_executor_exports, {
  GitExecutor: () => GitExecutor
});
var GitExecutor;
var init_git_executor = __esm({
  "src/lib/runners/git-executor.ts"() {
    init_git_executor_chain();
    GitExecutor = class {
      constructor(binary = "git", cwd, _scheduler, _plugins) {
        this.binary = binary;
        this.cwd = cwd;
        this._scheduler = _scheduler;
        this._plugins = _plugins;
        this._chain = new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      chain() {
        return new GitExecutorChain(this, this._scheduler, this._plugins);
      }
      push(task) {
        return this._chain.push(task);
      }
    };
  }
});
function taskCallback(task, response, callback = NOOP) {
  const onSuccess = (data) => {
    callback(null, data);
  };
  const onError = (err) => {
    if ((err == null ? void  : err.task) === task) {
      callback(err instanceof GitResponseError ? addDeprecationNoticeToError(err) : err, void );
    }
  };
  response.then(onSuccess, onError);
}
function addDeprecationNoticeToError(err) {
  let log = (name) => {
    console.warn(`simple-git deprecation notice: accessing GitResponseError.${name} should be GitResponseError.git.${name}, this will no longer be available in version `);
    log = NOOP;
  };
  return Object.create(err, Object.getOwnPropertyNames(err.git).reduce(descriptorReducer, {}));
  function descriptorReducer(all, name) {
    if (name in err) {
      return all;
    }
    all[name] = {
      enumerable: false,
      configurable: false,
      get() {
        log(name);
        return err.git[name];
      }
    };
    return all;
  }
}
var init_task_callback = __esm({
  "src/lib/task-callback.ts"() {
    init_git_response_error();
    init_utils();
  }
});
function changeWorkingDirectoryTask(directory, root) {
  return adhocExecTask((instance) => {
    if (!folderExists(directory)) {
      throw new Error(`Git.cwd: cannot change to non-directory "${directory}"`);
    }
    return (root || instance).cwd = directory;
  });
}
var init_change_working_directory = __esm({
  "src/lib/tasks/change-working-directory.ts"() {
    init_utils();
    init_task();
  }
});
function checkoutTask(args) {
  const commands = ["checkout", ...args];
  if (commands[] === "-b" && commands.includes("-B")) {
    commands[] = remove(commands, "-B");
  }
  return straightThroughStringTask(commands);
}
function checkout_default() {
  return {
    checkout() {
      return this._runTask(checkoutTask(getTrailingOptions(arguments, )), trailingFunctionArgument(arguments));
    },
    checkoutBranch(branchName, startPoint) {
      return this._runTask(checkoutTask(["-b", branchName, startPoint, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    },
    checkoutLocalBranch(branchName) {
      return this._runTask(checkoutTask(["-b", branchName, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    }
  };
}
var init_checkout = __esm({
  "src/lib/tasks/checkout.ts"() {
    init_utils();
    init_task();
  }
});
function parseCommitResult(stdOut) {
  const result = {
    author: null,
    branch: "",
    commit: "",
    root: false,
    summary: {
      changes: ,
      insertions: ,
      deletions: 
    }
  };
  return parseStringResponse(result, parsers, stdOut);
}
var parsers;
var init_parse_commit = __esm({
  "src/lib/parsers/parse-commit.ts"() {
    init_utils();
    parsers = [
      new LineParser(/^\[([^\s]+)( \([^)]+\))? ([^\]]+)/, (result, [branch, root, commit]) => {
        result.branch = branch;
        result.commit = commit;
        result.root = !!root;
      }),
      new LineParser(/\sAuthor:\s(.+)/i, (result, [author]) => {
        const parts = author.split("<");
        const email = parts.pop();
        if (!email || !email.includes("@")) {
          return;
        }
        result.author = {
          email: email.substr(, email.length - ),
          name: parts.join("<").trim()
        };
      }),
      new LineParser(/(\d+)[^,](?:,\s(\d+)[^,])(?:,\s(\d+))/g, (result, [changes, insertions, deletions]) => {
        result.summary.changes = parseInt(changes, ) || ;
        result.summary.insertions = parseInt(insertions, ) || ;
        result.summary.deletions = parseInt(deletions, ) || ;
      }),
      new LineParser(/^(\d+)[^,](?:,\s(\d+)[^(]+\(([+-]))?/, (result, [changes, lines, direction]) => {
        result.summary.changes = parseInt(changes, ) || ;
        const count = parseInt(lines, ) || ;
        if (direction === "-") {
          result.summary.deletions = count;
        } else if (direction === "+") {
          result.summary.insertions = count;
        }
      })
    ];
  }
});
function commitTask(message, files, customArgs) {
  const commands = [
    "-c",
    "core.abbrev=",
    "commit",
    ...prefixedArray(message, "-m"),
    ...files,
    ...customArgs
  ];
  return {
    commands,
    format: "utf-",
    parser: parseCommitResult
  };
}
function commit_default() {
  return {
    commit(message, ...rest) {
      const next = trailingFunctionArgument(arguments);
      const task = rejectDeprecatedSignatures(message) || commitTask(asArray(message), asArray(filterType(rest[], filterStringOrStringArray, [])), [...filterType(rest[], filterArray, []), ...getTrailingOptions(arguments, , true)]);
      return this._runTask(task, next);
    }
  };
  function rejectDeprecatedSignatures(message) {
    return !filterStringOrStringArray(message) && configurationErrorTask(`git.commit: requires the commit message to be supplied as a string/string[]`);
  }
}
var init_commit = __esm({
  "src/lib/tasks/commit.ts"() {
    init_parse_commit();
    init_utils();
    init_task();
  }
});
function hashObjectTask(filePath, write) {
  const commands = ["hash-object", filePath];
  if (write) {
    commands.push("-w");
  }
  return straightThroughStringTask(commands, true);
}
var init_hash_object = __esm({
  "src/lib/tasks/hash-object.ts"() {
    init_task();
  }
});
function parseInit(bare, path, text) {
  const response = String(text).trim();
  let result;
  if (result = initResponseRegex.exec(response)) {
    return new InitSummary(bare, path, false, result[]);
  }
  if (result = reInitResponseRegex.exec(response)) {
    return new InitSummary(bare, path, true, result[]);
  }
  let gitDir = "";
  const tokens = response.split(" ");
  while (tokens.length) {
    const token = tokens.shift();
    if (token === "in") {
      gitDir = tokens.join(" ");
      break;
    }
  }
  return new InitSummary(bare, path, /^re/i.test(response), gitDir);
}
var InitSummary;
var initResponseRegex;
var reInitResponseRegex;
var init_InitSummary = __esm({
  "src/lib/responses/InitSummary.ts"() {
    InitSummary = class {
      constructor(bare, path, existing, gitDir) {
        this.bare = bare;
        this.path = path;
        this.existing = existing;
        this.gitDir = gitDir;
      }
    };
    initResponseRegex = /^Init.+ repository in (.+)$/;
    reInitResponseRegex = /^Rein.+ in (.+)$/;
  }
});
function hasBareCommand(command) {
  return command.includes(bareCommand);
}
function initTask(bare = false, path, customArgs) {
  const commands = ["init", ...customArgs];
  if (bare && !hasBareCommand(commands)) {
    commands.splice(, , bareCommand);
  }
  return {
    commands,
    format: "utf-",
    parser(text) {
      return parseInit(commands.includes("--bare"), path, text);
    }
  };
}
var bareCommand;
var init_init = __esm({
  "src/lib/tasks/init.ts"() {
    init_InitSummary();
    bareCommand = "--bare";
  }
});
function logFormatFromCommand(customArgs) {
  for (let i = ; i < customArgs.length; i++) {
    const format = logFormatRegex.exec(customArgs[i]);
    if (format) {
      return `--${format[]}`;
    }
  }
  return "";
}
function isLogFormat(customArg) {
  return logFormatRegex.test(customArg);
}
var logFormatRegex;
var init_log_format = __esm({
  "src/lib/args/log-format.ts"() {
    logFormatRegex = /^--(stat|numstat|name-only|name-status)(=|$)/;
  }
});
var DiffSummary;
var init_DiffSummary = __esm({
  "src/lib/responses/DiffSummary.ts"() {
    DiffSummary = class {
      constructor() {
        this.changed = ;
        this.deletions = ;
        this.insertions = ;
        this.files = [];
      }
    };
  }
});
function getDiffParser(format = "") {
  const parser = diffSummaryParsers[format];
  return (stdOut) => parseStringResponse(new DiffSummary(), parser, stdOut, false);
}
var statParser;
var numStatParser;
var nameOnlyParser;
var nameStatusParser;
var diffSummaryParsers;
var init_parse_diff_summary = __esm({
  "src/lib/parsers/parse-diff-summary.ts"() {
    init_log_format();
    init_DiffSummary();
    init_utils();
    statParser = [
      new LineParser(/(.+)\s+\|\s+(\d+)(\s+[+\-]+)?$/, (result, [file, changes, alterations = ""]) => {
        result.files.push({
          file: file.trim(),
          changes: asNumber(changes),
          insertions: alterations.replace(/[^+]/g, "").length,
          deletions: alterations.replace(/[^-]/g, "").length,
          binary: false
        });
      }),
      new LineParser(/(.+) \|\s+Bin ([-.]+) -> ([-.]+) ([a-z]+)/, (result, [file, before, after]) => {
        result.files.push({
          file: file.trim(),
          before: asNumber(before),
          after: asNumber(after),
          binary: true
        });
      }),
      new LineParser(/(\d+) files? changed\s((?:, \d+ [^,]+){,})/, (result, [changed, summary]) => {
        const inserted = /(\d+) i/.exec(summary);
        const deleted = /(\d+) d/.exec(summary);
        result.changed = asNumber(changed);
        result.insertions = asNumber(inserted == null ? void  : inserted[]);
        result.deletions = asNumber(deleted == null ? void  : deleted[]);
      })
    ];
    numStatParser = [
      new LineParser(/(\d+)\t(\d+)\t(.+)$/, (result, [changesInsert, changesDelete, file]) => {
        const insertions = asNumber(changesInsert);
        const deletions = asNumber(changesDelete);
        result.changed++;
        result.insertions += insertions;
        result.deletions += deletions;
        result.files.push({
          file,
          changes: insertions + deletions,
          insertions,
          deletions,
          binary: false
        });
      }),
      new LineParser(/-\t-\t(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          after: ,
          before: ,
          binary: true
        });
      })
    ];
    nameOnlyParser = [
      new LineParser(/(.+)$/, (result, [file]) => {
        result.changed++;
        result.files.push({
          file,
          changes: ,
          insertions: ,
          deletions: ,
          binary: false
        });
      })
    ];
    nameStatusParser = [
      new LineParser(/([ACDMRTUXB])([-][-][-])?\t(.[^\t]+)\t?(.)?$/, (result, [status, _similarity, from, to]) => {
        result.changed++;
        result.files.push({
          file: to != null ? to : from,
          changes: ,
          status: status,
          insertions: ,
          deletions: ,
          binary: false
        });
      })
    ];
    diffSummaryParsers = {
      [
        ""
        / NONE /
      ]: statParser,
      [
        "--stat"
        / STAT /
      ]: statParser,
      [
        "--numstat"
        / NUM_STAT /
      ]: numStatParser,
      [
        "--name-status"
        / NAME_STATUS /
      ]: nameStatusParser,
      [
        "--name-only"
        / NAME_ONLY /
      ]: nameOnlyParser
    };
  }
});
function lineBuilder(tokens, fields) {
  return fields.reduce((line, field, index) => {
    line[field] = tokens[index] || "";
    return line;
  }, / @__PURE__ / Object.create({ diff: null }));
}
function createListLogSummaryParser(splitter = SPLITTER, fields = defaultFieldNames, logFormat = "") {
  const parseDiffResult = getDiffParser(logFormat);
  return function(stdOut) {
    const all = toLinesWithContent(stdOut, true, START_BOUNDARY).map(function(item) {
      const lineDetail = item.trim().split(COMMIT_BOUNDARY);
      const listLogLine = lineBuilder(lineDetail[].trim().split(splitter), fields);
      if (lineDetail.length >  && !!lineDetail[].trim()) {
        listLogLine.diff = parseDiffResult(lineDetail[]);
      }
      return listLogLine;
    });
    return {
      all,
      latest: all.length && all[] || null,
      total: all.length
    };
  };
}
var START_BOUNDARY;
var COMMIT_BOUNDARY;
var SPLITTER;
var defaultFieldNames;
var init_parse_list_log_summary = __esm({
  "src/lib/parsers/parse-list-log-summary.ts"() {
    init_utils();
    init_parse_diff_summary();
    init_log_format();
    START_BOUNDARY = "\xF\xF\xF\xF\xF\xF ";
    COMMIT_BOUNDARY = " \xF\xF";
    SPLITTER = " \xF ";
    defaultFieldNames = ["hash", "date", "message", "refs", "author_name", "author_email"];
  }
});
var diff_exports = {};
__export(diff_exports, {
  diffSummaryTask: () => diffSummaryTask,
  validateLogFormatConfig: () => validateLogFormatConfig
});
function diffSummaryTask(customArgs) {
  let logFormat = logFormatFromCommand(customArgs);
  const commands = ["diff"];
  if (logFormat === "") {
    logFormat = "--stat";
    commands.push("--stat=");
  }
  commands.push(...customArgs);
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-",
    parser: getDiffParser(logFormat)
  };
}
function validateLogFormatConfig(customArgs) {
  const flags = customArgs.filter(isLogFormat);
  if (flags.length > ) {
    return configurationErrorTask(`Summary flags are mutually exclusive - pick one of ${flags.join(",")}`);
  }
  if (flags.length && customArgs.includes("-z")) {
    return configurationErrorTask(`Summary flag ${flags} parsing is not compatible with null termination option '-z'`);
  }
}
var init_diff = __esm({
  "src/lib/tasks/diff.ts"() {
    init_log_format();
    init_parse_diff_summary();
    init_task();
  }
});
function prettyFormat(format, splitter) {
  const fields = [];
  const formatStr = [];
  Object.keys(format).forEach((field) => {
    fields.push(field);
    formatStr.push(String(format[field]));
  });
  return [fields, formatStr.join(splitter)];
}
function userOptions(input) {
  return Object.keys(input).reduce((out, key) => {
    if (!(key in excludeOptions)) {
      out[key] = input[key];
    }
    return out;
  }, {});
}
function parseLogOptions(opt = {}, customArgs = []) {
  const splitter = filterType(opt.splitter, filterString, SPLITTER);
  const format = !filterPrimitives(opt.format) && opt.format ? opt.format : {
    hash: "%H",
    date: opt.strictDate === false ? "%ai" : "%aI",
    message: "%s",
    refs: "%D",
    body: opt.multiLine ? "%B" : "%b",
    author_name: opt.mailMap !== false ? "%aN" : "%an",
    author_email: opt.mailMap !== false ? "%aE" : "%ae"
  };
  const [fields, formatStr] = prettyFormat(format, splitter);
  const suffix = [];
  const command = [
    `--pretty=format:${START_BOUNDARY}${formatStr}${COMMIT_BOUNDARY}`,
    ...customArgs
  ];
  const maxCount = opt.n || opt["max-count"] || opt.maxCount;
  if (maxCount) {
    command.push(`--max-count=${maxCount}`);
  }
  if (opt.from || opt.to) {
    const rangeOperator = opt.symmetric !== false ? "..." : "..";
    suffix.push(`${opt.from || ""}${rangeOperator}${opt.to || ""}`);
  }
  if (filterString(opt.file)) {
    suffix.push("--follow", opt.file);
  }
  appendTaskOptions(userOptions(opt), command);
  return {
    fields,
    splitter,
    commands: [...command, ...suffix]
  };
}
function logTask(splitter, fields, customArgs) {
  const parser = createListLogSummaryParser(splitter, fields, logFormatFromCommand(customArgs));
  return {
    commands: ["log", ...customArgs],
    format: "utf-",
    parser: parser
  };
}
function log_default() {
  return {
    log(...rest) {
      const next = trailingFunctionArgument(arguments);
      const options = parseLogOptions(trailingOptionsArgument(arguments), filterType(arguments[], filterArray));
      const task = rejectDeprecatedSignatures(...rest) || validateLogFormatConfig(options.commands) || createLogTask(options);
      return this._runTask(task, next);
    }
  };
  function createLogTask(options) {
    return logTask(options.splitter, options.fields, options.commands);
  }
  function rejectDeprecatedSignatures(from, to) {
    return filterString(from) && filterString(to) && configurationErrorTask(`git.log(string, string) should be replaced with git.log({ from: string, to: string })`);
  }
}
var excludeOptions;
var init_log = __esm({
  "src/lib/tasks/log.ts"() {
    init_log_format();
    init_parse_list_log_summary();
    init_utils();
    init_task();
    init_diff();
    excludeOptions = / @__PURE__ / ((excludeOptions) => {
      excludeOptions[excludeOptions["--pretty"] = ] = "--pretty";
      excludeOptions[excludeOptions["max-count"] = ] = "max-count";
      excludeOptions[excludeOptions["maxCount"] = ] = "maxCount";
      excludeOptions[excludeOptions["n"] = ] = "n";
      excludeOptions[excludeOptions["file"] = ] = "file";
      excludeOptions[excludeOptions["format"] = ] = "format";
      excludeOptions[excludeOptions["from"] = ] = "from";
      excludeOptions[excludeOptions["to"] = ] = "to";
      excludeOptions[excludeOptions["splitter"] = ] = "splitter";
      excludeOptions[excludeOptions["symmetric"] = ] = "symmetric";
      excludeOptions[excludeOptions["mailMap"] = ] = "mailMap";
      excludeOptions[excludeOptions["multiLine"] = ] = "multiLine";
      excludeOptions[excludeOptions["strictDate"] = ] = "strictDate";
      return excludeOptions;
    })(excludeOptions || {});
  }
});
var MergeSummaryConflict;
var MergeSummaryDetail;
var init_MergeSummary = __esm({
  "src/lib/responses/MergeSummary.ts"() {
    MergeSummaryConflict = class {
      constructor(reason, file = null, meta) {
        this.reason = reason;
        this.file = file;
        this.meta = meta;
      }
      toString() {
        return `${this.file}:${this.reason}`;
      }
    };
    MergeSummaryDetail = class {
      constructor() {
        this.conflicts = [];
        this.merges = [];
        this.result = "success";
      }
      get failed() {
        return this.conflicts.length > ;
      }
      get reason() {
        return this.result;
      }
      toString() {
        if (this.conflicts.length) {
          return `CONFLICTS: ${this.conflicts.join(", ")}`;
        }
        return "OK";
      }
    };
  }
});
var PullSummary;
var PullFailedSummary;
var init_PullSummary = __esm({
  "src/lib/responses/PullSummary.ts"() {
    PullSummary = class {
      constructor() {
        this.remoteMessages = {
          all: []
        };
        this.created = [];
        this.deleted = [];
        this.files = [];
        this.deletions = {};
        this.insertions = {};
        this.summary = {
          changes: ,
          deletions: ,
          insertions: 
        };
      }
    };
    PullFailedSummary = class {
      constructor() {
        this.remote = "";
        this.hash = {
          local: "",
          remote: ""
        };
        this.branch = {
          local: "",
          remote: ""
        };
        this.message = "";
      }
      toString() {
        return this.message;
      }
    };
  }
});
function objectEnumerationResult(remoteMessages) {
  return remoteMessages.objects = remoteMessages.objects || {
    compressing: ,
    counting: ,
    enumerating: ,
    packReused: ,
    reused: { count: , delta:  },
    total: { count: , delta:  }
  };
}
function asObjectCount(source) {
  const count = /^\s(\d+)/.exec(source);
  const delta = /delta (\d+)/i.exec(source);
  return {
    count: asNumber(count && count[] || ""),
    delta: asNumber(delta && delta[] || "")
  };
}
var remoteMessagesObjectParsers;
var init_parse_remote_objects = __esm({
  "src/lib/parsers/parse-remote-objects.ts"() {
    init_utils();
    remoteMessagesObjectParsers = [
      new RemoteLineParser(/^remote:\s(enumerating|counting|compressing) objects: (\d+),/i, (result, [action, count]) => {
        const key = action.toLowerCase();
        const enumeration = objectEnumerationResult(result.remoteMessages);
        Object.assign(enumeration, { [key]: asNumber(count) });
      }),
      new RemoteLineParser(/^remote:\s(enumerating|counting|compressing) objects: \d+% \(\d+\/(\d+)\),/i, (result, [action, count]) => {
        const key = action.toLowerCase();
        const enumeration = objectEnumerationResult(result.remoteMessages);
        Object.assign(enumeration, { [key]: asNumber(count) });
      }),
      new RemoteLineParser(/total ([^,]+), reused ([^,]+), pack-reused (\d+)/i, (result, [total, reused, packReused]) => {
        const objects = objectEnumerationResult(result.remoteMessages);
        objects.total = asObjectCount(total);
        objects.reused = asObjectCount(reused);
        objects.packReused = asNumber(packReused);
      })
    ];
  }
});
function parseRemoteMessages(_stdOut, stdErr) {
  return parseStringResponse({ remoteMessages: new RemoteMessageSummary() }, parsers, stdErr);
}
var parsers;
var RemoteMessageSummary;
var init_parse_remote_messages = __esm({
  "src/lib/parsers/parse-remote-messages.ts"() {
    init_utils();
    init_parse_remote_objects();
    parsers = [
      new RemoteLineParser(/^remote:\s(.+)$/, (result, [text]) => {
        result.remoteMessages.all.push(text.trim());
        return false;
      }),
      ...remoteMessagesObjectParsers,
      new RemoteLineParser([/create a (?:pull|merge) request/i, /\s(https?:\/\/\S+)$/], (result, [pullRequestUrl]) => {
        result.remoteMessages.pullRequestUrl = pullRequestUrl;
      }),
      new RemoteLineParser([/found (\d+) vulnerabilities.+\(([^)]+)\)/i, /\s(https?:\/\/\S+)$/], (result, [count, summary, url]) => {
        result.remoteMessages.vulnerabilities = {
          count: asNumber(count),
          summary,
          url
        };
      })
    ];
    RemoteMessageSummary = class {
      constructor() {
        this.all = [];
      }
    };
  }
});
function parsePullErrorResult(stdOut, stdErr) {
  const pullError = parseStringResponse(new PullFailedSummary(), errorParsers, [stdOut, stdErr]);
  return pullError.message && pullError;
}
var FILE_UPDATE_REGEX;
var SUMMARY_REGEX;
var ACTION_REGEX;
var parsers;
var errorParsers;
var parsePullDetail;
var parsePullResult;
var init_parse_pull = __esm({
  "src/lib/parsers/parse-pull.ts"() {
    init_PullSummary();
    init_utils();
    init_parse_remote_messages();
    FILE_UPDATE_REGEX = /^\s(.+?)\s+\|\s+\d+\s(\+)(-)/;
    SUMMARY_REGEX = /(\d+)\D+((\d+)\D+\(\+\))?(\D+(\d+)\D+\(-\))?/;
    ACTION_REGEX = /^(create|delete) mode \d+ (.+)/;
    parsers = [
      new LineParser(FILE_UPDATE_REGEX, (result, [file, insertions, deletions]) => {
        result.files.push(file);
        if (insertions) {
          result.insertions[file] = insertions.length;
        }
        if (deletions) {
          result.deletions[file] = deletions.length;
        }
      }),
      new LineParser(SUMMARY_REGEX, (result, [changes, , insertions, , deletions]) => {
        if (insertions !== void  || deletions !== void ) {
          result.summary.changes = +changes || ;
          result.summary.insertions = +insertions || ;
          result.summary.deletions = +deletions || ;
          return true;
        }
        return false;
      }),
      new LineParser(ACTION_REGEX, (result, [action, file]) => {
        append(result.files, file);
        append(action === "create" ? result.created : result.deleted, file);
      })
    ];
    errorParsers = [
      new LineParser(/^from\s(.+)$/i, (result, [remote]) => void (result.remote = remote)),
      new LineParser(/^fatal:\s(.+)$/, (result, [message]) => void (result.message = message)),
      new LineParser(/([a-z-]+)\.\.([a-z-]+)\s+(\S+)\s+->\s+(\S+)$/, (result, [hashLocal, hashRemote, branchLocal, branchRemote]) => {
        result.branch.local = branchLocal;
        result.hash.local = hashLocal;
        result.branch.remote = branchRemote;
        result.hash.remote = hashRemote;
      })
    ];
    parsePullDetail = (stdOut, stdErr) => {
      return parseStringResponse(new PullSummary(), parsers, [stdOut, stdErr]);
    };
    parsePullResult = (stdOut, stdErr) => {
      return Object.assign(new PullSummary(), parsePullDetail(stdOut, stdErr), parseRemoteMessages(stdOut, stdErr));
    };
  }
});
var parsers;
var parseMergeResult;
var parseMergeDetail;
var init_parse_merge = __esm({
  "src/lib/parsers/parse-merge.ts"() {
    init_MergeSummary();
    init_utils();
    init_parse_pull();
    parsers = [
      new LineParser(/^Auto-merging\s+(.+)$/, (summary, [autoMerge]) => {
        summary.merges.push(autoMerge);
      }),
      new LineParser(/^CONFLICT\s+\((.+)\): Merge conflict in (.+)$/, (summary, [reason, file]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file));
      }),
      new LineParser(/^CONFLICT\s+\((.+\/delete)\): (.+) deleted in (.+) and/, (summary, [reason, file, deleteRef]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, file, { deleteRef: deleteRef }));
      }),
      new LineParser(/^CONFLICT\s+\((.+)\):/, (summary, [reason]) => {
        summary.conflicts.push(new MergeSummaryConflict(reason, null));
      }),
      new LineParser(/^Automatic merge failed;\s+(.+)$/, (summary, [result]) => {
        summary.result = result;
      })
    ];
    parseMergeResult = (stdOut, stdErr) => {
      return Object.assign(parseMergeDetail(stdOut, stdErr), parsePullResult(stdOut, stdErr));
    };
    parseMergeDetail = (stdOut) => {
      return parseStringResponse(new MergeSummaryDetail(), parsers, stdOut);
    };
  }
});
function mergeTask(customArgs) {
  if (!customArgs.length) {
    return configurationErrorTask("Git.merge requires at least one option");
  }
  return {
    commands: ["merge", ...customArgs],
    format: "utf-",
    parser(stdOut, stdErr) {
      const merge = parseMergeResult(stdOut, stdErr);
      if (merge.failed) {
        throw new GitResponseError(merge);
      }
      return merge;
    }
  };
}
var init_merge = __esm({
  "src/lib/tasks/merge.ts"() {
    init_git_response_error();
    init_parse_merge();
    init_task();
  }
});
function pushResultPushedItem(local, remote, status) {
  const deleted = status.includes("deleted");
  const tag = status.includes("tag") || /^refs\/tags/.test(local);
  const alreadyUpdated = !status.includes("new");
  return {
    deleted,
    tag: tag,
    branch: !tag,
    new: !alreadyUpdated,
    alreadyUpdated,
    local,
    remote
  };
}
var parsers;
var parsePushResult;
var parsePushDetail;
var init_parse_push = __esm({
  "src/lib/parsers/parse-push.ts"() {
    init_utils();
    init_parse_remote_messages();
    parsers = [
      new LineParser(/^Pushing to (.+)$/, (result, [repo]) => {
        result.repo = repo;
      }),
      new LineParser(/^updating local tracking ref '(.+)'/, (result, [local]) => {
        result.ref = __spreadProps(__spreadValues({}, result.ref || {}), {
          local
        });
      }),
      new LineParser(/^[=-]\s+([^:]+):(\S+)\s+\[(.+)]$/, (result, [local, remote, type]) => {
        result.pushed.push(pushResultPushedItem(local, remote, type));
      }),
      new LineParser(/^Branch '([^']+)' set up to track remote branch '([^']+)' from '([^']+)'/, (result, [local, remote, remoteName]) => {
        result.branch = __spreadProps(__spreadValues({}, result.branch || {}), {
          local,
          remote,
          remoteName
        });
      }),
      new LineParser(/^([^:]+):(\S+)\s+([a-z-]+)\.\.([a-z-]+)$/, (result, [local, remote, from, to]) => {
        result.update = {
          head: {
            local,
            remote
          },
          hash: {
            from,
            to
          }
        };
      })
    ];
    parsePushResult = (stdOut, stdErr) => {
      const pushDetail = parsePushDetail(stdOut, stdErr);
      const responseDetail = parseRemoteMessages(stdOut, stdErr);
      return __spreadValues(__spreadValues({}, pushDetail), responseDetail);
    };
    parsePushDetail = (stdOut, stdErr) => {
      return parseStringResponse({ pushed: [] }, parsers, [stdOut, stdErr]);
    };
  }
});
var push_exports = {};
__export(push_exports, {
  pushTagsTask: () => pushTagsTask,
  pushTask: () => pushTask
});
function pushTagsTask(ref = {}, customArgs) {
  append(customArgs, "--tags");
  return pushTask(ref, customArgs);
}
function pushTask(ref = {}, customArgs) {
  const commands = ["push", ...customArgs];
  if (ref.branch) {
    commands.splice(, , ref.branch);
  }
  if (ref.remote) {
    commands.splice(, , ref.remote);
  }
  remove(commands, "-v");
  append(commands, "--verbose");
  append(commands, "--porcelain");
  return {
    commands,
    format: "utf-",
    parser: parsePushResult
  };
}
var init_push = __esm({
  "src/lib/tasks/push.ts"() {
    init_parse_push();
    init_utils();
  }
});
var fromPathRegex;
var FileStatusSummary;
var init_FileStatusSummary = __esm({
  "src/lib/responses/FileStatusSummary.ts"() {
    fromPathRegex = /^(.+) -> (.+)$/;
    FileStatusSummary = class {
      constructor(path, index, working_dir) {
        this.path = path;
        this.index = index;
        this.working_dir = working_dir;
        if (index + working_dir === "R") {
          const detail = fromPathRegex.exec(path) || [null, path, path];
          this.from = detail[] || "";
          this.path = detail[] || "";
        }
      }
    };
  }
});
function renamedFile(line) {
  const [to, from] = line.split(NULL);
  return {
    from: from || to,
    to
  };
}
function parser(indexX, indexY, handler) {
  return [`${indexX}${indexY}`, handler];
}
function conflicts(indexX, ...indexY) {
  return indexY.map((y) => parser(indexX, y, (result, file) => append(result.conflicted, file)));
}
function splitLine(result, lineStr) {
  const trimmed = lineStr.trim();
  switch (" ") {
    case trimmed.charAt():
      return data(trimmed.charAt(), trimmed.charAt(), trimmed.substr());
    case trimmed.charAt():
      return data(" ", trimmed.charAt(), trimmed.substr());
    default:
      return;
  }
  function data(index, workingDir, path) {
    const raw = `${index}${workingDir}`;
    const handler = parsers.get(raw);
    if (handler) {
      handler(result, path);
    }
    if (raw !== "" && raw !== "!!") {
      result.files.push(new FileStatusSummary(path.replace(/\.+$/, ""), index, workingDir));
    }
  }
}
var StatusSummary;
var parsers;
var parseStatusSummary;
var init_StatusSummary = __esm({
  "src/lib/responses/StatusSummary.ts"() {
    init_utils();
    init_FileStatusSummary();
    StatusSummary = class {
      constructor() {
        this.not_added = [];
        this.conflicted = [];
        this.created = [];
        this.deleted = [];
        this.ignored = void ;
        this.modified = [];
        this.renamed = [];
        this.files = [];
        this.staged = [];
        this.ahead = ;
        this.behind = ;
        this.current = null;
        this.tracking = null;
        this.detached = false;
        this.isClean = () => {
          return !this.files.length;
        };
      }
    };
    parsers = new Map([
      parser(" ", "A", (result, file) => append(result.created, file)),
      parser(" ", "D", (result, file) => append(result.deleted, file)),
      parser(" ", "M", (result, file) => append(result.modified, file)),
      parser("A", " ", (result, file) => append(result.created, file) && append(result.staged, file)),
      parser("A", "M", (result, file) => append(result.created, file) && append(result.staged, file) && append(result.modified, file)),
      parser("D", " ", (result, file) => append(result.deleted, file) && append(result.staged, file)),
      parser("M", " ", (result, file) => append(result.modified, file) && append(result.staged, file)),
      parser("M", "M", (result, file) => append(result.modified, file) && append(result.staged, file)),
      parser("R", " ", (result, file) => {
        append(result.renamed, renamedFile(file));
      }),
      parser("R", "M", (result, file) => {
        const renamed = renamedFile(file);
        append(result.renamed, renamed);
        append(result.modified, renamed.to);
      }),
      parser("!", "!", (_result, _file) => {
        append(_result.ignored = _result.ignored || [], _file);
      }),
      parser("?", "?", (result, file) => append(result.not_added, file)),
      ...conflicts(
        "A",
        "A",
        "U"
        / UNMERGED /
      ),
      ...conflicts(
        "D",
        "D",
        "U"
        / UNMERGED /
      ),
      ...conflicts(
        "U",
        "A",
        "D",
        "U"
        / UNMERGED /
      ),
      [
        "",
        (result, line) => {
          const aheadReg = /ahead (\d+)/;
          const behindReg = /behind (\d+)/;
          const currentReg = /^(.+?(?=(?:\.{}|\s|$)))/;
          const trackingReg = /\.{}(\S)/;
          const onEmptyBranchReg = /\son\s([\S]+)$/;
          let regexResult;
          regexResult = aheadReg.exec(line);
          result.ahead = regexResult && +regexResult[] || ;
          regexResult = behindReg.exec(line);
          result.behind = regexResult && +regexResult[] || ;
          regexResult = currentReg.exec(line);
          result.current = regexResult && regexResult[];
          regexResult = trackingReg.exec(line);
          result.tracking = regexResult && regexResult[];
          regexResult = onEmptyBranchReg.exec(line);
          result.current = regexResult && regexResult[] || result.current;
          result.detached = /\(no branch\)/.test(line);
        }
      ]
    ]);
    parseStatusSummary = function(text) {
      const lines = text.split(NULL);
      const status = new StatusSummary();
      for (let i = , l = lines.length; i < l; ) {
        let line = lines[i++].trim();
        if (!line) {
          continue;
        }
        if (line.charAt() === "R") {
          line += NULL + (lines[i++] || "");
        }
        splitLine(status, line);
      }
      return status;
    };
  }
});
function statusTask(customArgs) {
  const commands = [
    "status",
    "--porcelain",
    "-b",
    "-u",
    "--null",
    ...customArgs.filter((arg) => !ignoredOptions.includes(arg))
  ];
  return {
    format: "utf-",
    commands,
    parser(text) {
      return parseStatusSummary(text);
    }
  };
}
var ignoredOptions;
var init_status = __esm({
  "src/lib/tasks/status.ts"() {
    init_StatusSummary();
    ignoredOptions = ["--null", "-z"];
  }
});
function versionResponse(major = , minor = , patch = , agent = "", installed = true) {
  return Object.defineProperty({
    major,
    minor,
    patch,
    agent,
    installed
  }, "toString", {
    value() {
      return `${this.major}.${this.minor}.${this.patch}`;
    },
    configurable: false,
    enumerable: false
  });
}
function notInstalledResponse() {
  return versionResponse(, , , "", false);
}
function version_default() {
  return {
    version() {
      return this._runTask({
        commands: ["--version"],
        format: "utf-",
        parser: versionParser,
        onError(result, error, done, fail) {
          if (result.exitCode === -) {
            return done(Buffer.from(NOT_INSTALLED));
          }
          fail(error);
        }
      });
    }
  };
}
function versionParser(stdOut) {
  if (stdOut === NOT_INSTALLED) {
    return notInstalledResponse();
  }
  return parseStringResponse(versionResponse(, , , stdOut), parsers, stdOut);
}
var NOT_INSTALLED;
var parsers;
var init_version = __esm({
  "src/lib/tasks/version.ts"() {
    init_utils();
    NOT_INSTALLED = "installed=false";
    parsers = [
      new LineParser(/version (\d+)\.(\d+)\.(\d+)(?:\s\((.+)\))?/, (result, [major, minor, patch, agent = ""]) => {
        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), asNumber(patch), agent));
      }),
      new LineParser(/version (\d+)\.(\d+)\.(\D+)(.+)?$/, (result, [major, minor, patch, agent = ""]) => {
        Object.assign(result, versionResponse(asNumber(major), asNumber(minor), patch, agent));
      })
    ];
  }
});
var simple_git_api_exports = {};
__export(simple_git_api_exports, {
  SimpleGitApi: () => SimpleGitApi
});
var SimpleGitApi;
var init_simple_git_api = __esm({
  "src/lib/simple-git-api.ts"() {
    init_task_callback();
    init_change_working_directory();
    init_checkout();
    init_commit();
    init_config();
    init_grep();
    init_hash_object();
    init_init();
    init_log();
    init_merge();
    init_push();
    init_status();
    init_task();
    init_version();
    init_utils();
    SimpleGitApi = class {
      constructor(_executor) {
        this._executor = _executor;
      }
      _runTask(task, then) {
        const chain = this._executor.chain();
        const promise = chain.push(task);
        if (then) {
          taskCallback(task, promise, then);
        }
        return Object.create(this, {
          then: { value: promise.then.bind(promise) },
          catch: { value: promise.catch.bind(promise) },
          _executor: { value: chain }
        });
      }
      add(files) {
        return this._runTask(straightThroughStringTask(["add", ...asArray(files)]), trailingFunctionArgument(arguments));
      }
      cwd(directory) {
        const next = trailingFunctionArgument(arguments);
        if (typeof directory === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory, this._executor), next);
        }
        if (typeof (directory == null ? void  : directory.path) === "string") {
          return this._runTask(changeWorkingDirectoryTask(directory.path, directory.root && this._executor || void ), next);
        }
        return this._runTask(configurationErrorTask("Git.cwd: workingDirectory must be supplied as a string"), next);
      }
      hashObject(path, write) {
        return this._runTask(hashObjectTask(path, write === true), trailingFunctionArgument(arguments));
      }
      init(bare) {
        return this._runTask(initTask(bare === true, this._executor.cwd, getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
      merge() {
        return this._runTask(mergeTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
      mergeFromTo(remote, branch) {
        if (!(filterString(remote) && filterString(branch))) {
          return this._runTask(configurationErrorTask(`Git.mergeFromTo requires that the 'remote' and 'branch' arguments are supplied as strings`));
        }
        return this._runTask(mergeTask([remote, branch, ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments, false));
      }
      outputHandler(handler) {
        this._executor.outputHandler = handler;
        return this;
      }
      push() {
        const task = pushTask({
          remote: filterType(arguments[], filterString),
          branch: filterType(arguments[], filterString)
        }, getTrailingOptions(arguments));
        return this._runTask(task, trailingFunctionArgument(arguments));
      }
      stash() {
        return this._runTask(straightThroughStringTask(["stash", ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
      }
      status() {
        return this._runTask(statusTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
      }
    };
    Object.assign(SimpleGitApi.prototype, checkout_default(), commit_default(), config_default(), grep_default(), log_default(), version_default());
  }
});
var scheduler_exports = {};
__export(scheduler_exports, {
  Scheduler: () => Scheduler
});
var createScheduledTask;
var Scheduler;
var init_scheduler = __esm({
  "src/lib/runners/scheduler.ts"() {
    init_utils();
    init_git_logger();
    createScheduledTask = (() => {
      let id = ;
      return () => {
        id++;
        const { promise: promise, done } = (, import_promise_deferred.createDeferred)();
        return {
          promise: promise,
          done,
          id
        };
      };
    })();
    Scheduler = class {
      constructor(concurrency = ) {
        this.concurrency = concurrency;
        this.logger = createLogger("", "scheduler");
        this.pending = [];
        this.running = [];
        this.logger(`Constructed, concurrency=%s`, concurrency);
      }
      schedule() {
        if (!this.pending.length || this.running.length >= this.concurrency) {
          this.logger(`Schedule attempt ignored, pending=%s running=%s concurrency=%s`, this.pending.length, this.running.length, this.concurrency);
          return;
        }
        const task = append(this.running, this.pending.shift());
        this.logger(`Attempting id=%s`, task.id);
        task.done(() => {
          this.logger(`Completing id=`, task.id);
          remove(this.running, task);
          this.schedule();
        });
      }
      next() {
        const { promise: promise, id } = append(this.pending, createScheduledTask());
        this.logger(`Scheduling id=%s`, id);
        this.schedule();
        return promise;
      }
    };
  }
});
var apply_patch_exports = {};
__export(apply_patch_exports, {
  applyPatchTask: () => applyPatchTask
});
function applyPatchTask(patches, customArgs) {
  return straightThroughStringTask(["apply", ...customArgs, ...patches]);
}
var init_apply_patch = __esm({
  "src/lib/tasks/apply-patch.ts"() {
    init_task();
  }
});
function branchDeletionSuccess(branch, hash) {
  return {
    branch: branch,
    hash: hash,
    success: true
  };
}
function branchDeletionFailure(branch) {
  return {
    branch: branch,
    hash: null,
    success: false
  };
}
var BranchDeletionBatch;
var init_BranchDeleteSummary = __esm({
  "src/lib/responses/BranchDeleteSummary.ts"() {
    BranchDeletionBatch = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.errors = [];
      }
      get success() {
        return !this.errors.length;
      }
    };
  }
});
function hasBranchDeletionError(data, processExitCode) {
  return processExitCode ===  && deleteErrorRegex.test(data);
}
var deleteSuccessRegex;
var deleteErrorRegex;
var parsers;
var parseBranchDeletions;
var init_parse_branch_delete = __esm({
  "src/lib/parsers/parse-branch-delete.ts"() {
    init_BranchDeleteSummary();
    init_utils();
    deleteSuccessRegex = /(\S+)\s+\(\S+\s([^)]+)\)/;
    deleteErrorRegex = /^error[^']+'([^']+)'/m;
    parsers = [
      new LineParser(deleteSuccessRegex, (result, [branch, hash]) => {
        const deletion = branchDeletionSuccess(branch, hash);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      }),
      new LineParser(deleteErrorRegex, (result, [branch]) => {
        const deletion = branchDeletionFailure(branch);
        result.errors.push(deletion);
        result.all.push(deletion);
        result.branches[branch] = deletion;
      })
    ];
    parseBranchDeletions = (stdOut, stdErr) => {
      return parseStringResponse(new BranchDeletionBatch(), parsers, [stdOut, stdErr]);
    };
  }
});
var BranchSummaryResult;
var init_BranchSummary = __esm({
  "src/lib/responses/BranchSummary.ts"() {
    BranchSummaryResult = class {
      constructor() {
        this.all = [];
        this.branches = {};
        this.current = "";
        this.detached = false;
      }
      push(status, detached, name, commit, label) {
        if (status === "") {
          this.detached = detached;
          this.current = name;
        }
        this.all.push(name);
        this.branches[name] = {
          current: status === "",
          linkedWorkTree: status === "+",
          name,
          commit: commit,
          label
        };
      }
    };
  }
});
function branchStatus(input) {
  return input ? input.charAt() : "";
}
function parseBranchSummary(stdOut) {
  return parseStringResponse(new BranchSummaryResult(), parsers, stdOut);
}
var parsers;
var init_parse_branch = __esm({
  "src/lib/parsers/parse-branch.ts"() {
    init_BranchSummary();
    init_utils();
    parsers = [
      new LineParser(/^([+]\s)?\((?:HEAD )?detached (?:from|at) (\S+)\)\s+([a-z-]+)\s(.)$/, (result, [current, name, commit, label]) => {
        result.push(branchStatus(current), true, name, commit, label);
      }),
      new LineParser(/^([+]\s)?(\S+)\s+([a-z-]+)\s?(.)$/s, (result, [current, name, commit, label]) => {
        result.push(branchStatus(current), false, name, commit, label);
      })
    ];
  }
});
var branch_exports = {};
__export(branch_exports, {
  branchLocalTask: () => branchLocalTask,
  branchTask: () => branchTask,
  containsDeleteBranchCommand: () => containsDeleteBranchCommand,
  deleteBranchTask: () => deleteBranchTask,
  deleteBranchesTask: () => deleteBranchesTask
});
function containsDeleteBranchCommand(commands) {
  const deleteCommands = ["-d", "-D", "--delete"];
  return commands.some((command) => deleteCommands.includes(command));
}
function branchTask(customArgs) {
  const isDelete = containsDeleteBranchCommand(customArgs);
  const commands = ["branch", ...customArgs];
  if (commands.length === ) {
    commands.push("-a");
  }
  if (!commands.includes("-v")) {
    commands.splice(, , "-v");
  }
  return {
    format: "utf-",
    commands,
    parser(stdOut, stdErr) {
      if (isDelete) {
        return parseBranchDeletions(stdOut, stdErr).all[];
      }
      return parseBranchSummary(stdOut);
    }
  };
}
function branchLocalTask() {
  const parser = parseBranchSummary;
  return {
    format: "utf-",
    commands: ["branch", "-v"],
    parser: parser
  };
}
function deleteBranchesTask(branches, forceDelete = false) {
  return {
    format: "utf-",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", ...branches],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr);
    },
    onError({ exitCode, stdOut }, error, done, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      done(stdOut);
    }
  };
}
function deleteBranchTask(branch, forceDelete = false) {
  const task = {
    format: "utf-",
    commands: ["branch", "-v", forceDelete ? "-D" : "-d", branch],
    parser(stdOut, stdErr) {
      return parseBranchDeletions(stdOut, stdErr).branches[branch];
    },
    onError({ exitCode, stdErr, stdOut }, error, _, fail) {
      if (!hasBranchDeletionError(String(error), exitCode)) {
        return fail(error);
      }
      throw new GitResponseError(task.parser(bufferToString(stdOut), bufferToString(stdErr)), String(error));
    }
  };
  return task;
}
var init_branch = __esm({
  "src/lib/tasks/branch.ts"() {
    init_git_response_error();
    init_parse_branch_delete();
    init_parse_branch();
    init_utils();
  }
});
var parseCheckIgnore;
var init_CheckIgnore = __esm({
  "src/lib/responses/CheckIgnore.ts"() {
    parseCheckIgnore = (text) => {
      return text.split(/\n/g).map((line) => line.trim()).filter((file) => !!file);
    };
  }
});
var check_ignore_exports = {};
__export(check_ignore_exports, {
  checkIgnoreTask: () => checkIgnoreTask
});
function checkIgnoreTask(paths) {
  return {
    commands: ["check-ignore", ...paths],
    format: "utf-",
    parser: parseCheckIgnore
  };
}
var init_check_ignore = __esm({
  "src/lib/tasks/check-ignore.ts"() {
    init_CheckIgnore();
  }
});
var clone_exports = {};
__export(clone_exports, {
  cloneMirrorTask: () => cloneMirrorTask,
  cloneTask: () => cloneTask
});
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function cloneTask(repo, directory, customArgs) {
  const commands = ["clone", ...customArgs];
  filterString(repo) && commands.push(repo);
  filterString(directory) && commands.push(directory);
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return straightThroughStringTask(commands);
}
function cloneMirrorTask(repo, directory, customArgs) {
  append(customArgs, "--mirror");
  return cloneTask(repo, directory, customArgs);
}
var init_clone = __esm({
  "src/lib/tasks/clone.ts"() {
    init_task();
    init_utils();
  }
});
function parseFetchResult(stdOut, stdErr) {
  const result = {
    raw: stdOut,
    remote: null,
    branches: [],
    tags: [],
    updated: [],
    deleted: []
  };
  return parseStringResponse(result, parsers, [stdOut, stdErr]);
}
var parsers;
var init_parse_fetch = __esm({
  "src/lib/parsers/parse-fetch.ts"() {
    init_utils();
    parsers = [
      new LineParser(/From (.+)$/, (result, [remote]) => {
        result.remote = remote;
      }),
      new LineParser(/\ \[new branch]\s+(\S+)\s-> (.+)$/, (result, [name, tracking]) => {
        result.branches.push({
          name,
          tracking
        });
      }),
      new LineParser(/\ \[new tag]\s+(\S+)\s-> (.+)$/, (result, [name, tracking]) => {
        result.tags.push({
          name,
          tracking
        });
      }),
      new LineParser(/- \[deleted]\s+\S+\s-> (.+)$/, (result, [tracking]) => {
        result.deleted.push({
          tracking
        });
      }),
      new LineParser(/\s([^.]+)\.\.(\S+)\s+(\S+)\s-> (.+)$/, (result, [from, to, name, tracking]) => {
        result.updated.push({
          name,
          tracking,
          to,
          from
        });
      })
    ];
  }
});
var fetch_exports = {};
__export(fetch_exports, {
  fetchTask: () => fetchTask
});
function disallowedCommand(command) {
  return /^--upload-pack(=|$)/.test(command);
}
function fetchTask(remote, branch, customArgs) {
  const commands = ["fetch", ...customArgs];
  if (remote && branch) {
    commands.push(remote, branch);
  }
  const banned = commands.find(disallowedCommand);
  if (banned) {
    return configurationErrorTask(`git.fetch: potential exploit argument blocked.`);
  }
  return {
    commands,
    format: "utf-",
    parser: parseFetchResult
  };
}
var init_fetch = __esm({
  "src/lib/tasks/fetch.ts"() {
    init_parse_fetch();
    init_task();
  }
});
function parseMoveResult(stdOut) {
  return parseStringResponse({ moves: [] }, parsers, stdOut);
}
var parsers;
var init_parse_move = __esm({
  "src/lib/parsers/parse-move.ts"() {
    init_utils();
    parsers = [
      new LineParser(/^Renaming (.+) to (.+)$/, (result, [from, to]) => {
        result.moves.push({ from, to });
      })
    ];
  }
});
var move_exports = {};
__export(move_exports, {
  moveTask: () => moveTask
});
function moveTask(from, to) {
  return {
    commands: ["mv", "-v", ...asArray(from), to],
    format: "utf-",
    parser: parseMoveResult
  };
}
var init_move = __esm({
  "src/lib/tasks/move.ts"() {
    init_parse_move();
    init_utils();
  }
});
var pull_exports = {};
__export(pull_exports, {
  pullTask: () => pullTask
});
function pullTask(remote, branch, customArgs) {
  const commands = ["pull", ...customArgs];
  if (remote && branch) {
    commands.splice(, , remote, branch);
  }
  return {
    commands,
    format: "utf-",
    parser(stdOut, stdErr) {
      return parsePullResult(stdOut, stdErr);
    },
    onError(result, _error, _done, fail) {
      const pullError = parsePullErrorResult(bufferToString(result.stdOut), bufferToString(result.stdErr));
      if (pullError) {
        return fail(new GitResponseError(pullError));
      }
      fail(_error);
    }
  };
}
var init_pull = __esm({
  "src/lib/tasks/pull.ts"() {
    init_git_response_error();
    init_parse_pull();
    init_utils();
  }
});
function parseGetRemotes(text) {
  const remotes = {};
  forEach(text, ([name]) => remotes[name] = { name });
  return Object.values(remotes);
}
function parseGetRemotesVerbose(text) {
  const remotes = {};
  forEach(text, ([name, url, purpose]) => {
    if (!remotes.hasOwnProperty(name)) {
      remotes[name] = {
        name,
        refs: { fetch: "", push: "" }
      };
    }
    if (purpose && url) {
      remotes[name].refs[purpose.replace(/[^a-z]/g, "")] = url;
    }
  });
  return Object.values(remotes);
}
function forEach(text, handler) {
  forEachLineWithContent(text, (line) => handler(line.split(/\s+/)));
}
var init_GetRemoteSummary = __esm({
  "src/lib/responses/GetRemoteSummary.ts"() {
    init_utils();
  }
});
var remote_exports = {};
__export(remote_exports, {
  addRemoteTask: () => addRemoteTask,
  getRemotesTask: () => getRemotesTask,
  listRemotesTask: () => listRemotesTask,
  remoteTask: () => remoteTask,
  removeRemoteTask: () => removeRemoteTask
});
function addRemoteTask(remoteName, remoteRepo, customArgs = []) {
  return straightThroughStringTask(["remote", "add", ...customArgs, remoteName, remoteRepo]);
}
function getRemotesTask(verbose) {
  const commands = ["remote"];
  if (verbose) {
    commands.push("-v");
  }
  return {
    commands,
    format: "utf-",
    parser: verbose ? parseGetRemotesVerbose : parseGetRemotes
  };
}
function listRemotesTask(customArgs = []) {
  const commands = [...customArgs];
  if (commands[] !== "ls-remote") {
    commands.unshift("ls-remote");
  }
  return straightThroughStringTask(commands);
}
function remoteTask(customArgs = []) {
  const commands = [...customArgs];
  if (commands[] !== "remote") {
    commands.unshift("remote");
  }
  return straightThroughStringTask(commands);
}
function removeRemoteTask(remoteName) {
  return straightThroughStringTask(["remote", "remove", remoteName]);
}
var init_remote = __esm({
  "src/lib/tasks/remote.ts"() {
    init_GetRemoteSummary();
    init_task();
  }
});
var stash_list_exports = {};
__export(stash_list_exports, {
  stashListTask: () => stashListTask
});
function stashListTask(opt = {}, customArgs) {
  const options = parseLogOptions(opt);
  const commands = ["stash", "list", ...options.commands, ...customArgs];
  const parser = createListLogSummaryParser(options.splitter, options.fields, logFormatFromCommand(commands));
  return validateLogFormatConfig(commands) || {
    commands,
    format: "utf-",
    parser: parser
  };
}
var init_stash_list = __esm({
  "src/lib/tasks/stash-list.ts"() {
    init_log_format();
    init_parse_list_log_summary();
    init_diff();
    init_log();
  }
});
var sub_module_exports = {};
__export(sub_module_exports, {
  addSubModuleTask: () => addSubModuleTask,
  initSubModuleTask: () => initSubModuleTask,
  subModuleTask: () => subModuleTask,
  updateSubModuleTask: () => updateSubModuleTask
});
function addSubModuleTask(repo, path) {
  return subModuleTask(["add", repo, path]);
}
function initSubModuleTask(customArgs) {
  return subModuleTask(["init", ...customArgs]);
}
function subModuleTask(customArgs) {
  const commands = [...customArgs];
  if (commands[] !== "submodule") {
    commands.unshift("submodule");
  }
  return straightThroughStringTask(commands);
}
function updateSubModuleTask(customArgs) {
  return subModuleTask(["update", ...customArgs]);
}
var init_sub_module = __esm({
  "src/lib/tasks/sub-module.ts"() {
    init_task();
  }
});
function singleSorted(a, b) {
  const aIsNum = isNaN(a);
  const bIsNum = isNaN(b);
  if (aIsNum !== bIsNum) {
    return aIsNum ?  : -;
  }
  return aIsNum ? sorted(a, b) : ;
}
function sorted(a, b) {
  return a === b ?  : a > b ?  : -;
}
function trimmed(input) {
  return input.trim();
}
function toNumber(input) {
  if (typeof input === "string") {
    return parseInt(input.replace(/^\D+/g, ""), ) || ;
  }
  return ;
}
var TagList;
var parseTagList;
var init_TagList = __esm({
  "src/lib/responses/TagList.ts"() {
    TagList = class {
      constructor(all, latest) {
        this.all = all;
        this.latest = latest;
      }
    };
    parseTagList = function(data, customSort = false) {
      const tags = data.split("\n").map(trimmed).filter(Boolean);
      if (!customSort) {
        tags.sort(function(tagA, tagB) {
          const partsA = tagA.split(".");
          const partsB = tagB.split(".");
          if (partsA.length ===  || partsB.length === ) {
            return singleSorted(toNumber(partsA[]), toNumber(partsB[]));
          }
          for (let i = , l = Math.max(partsA.length, partsB.length); i < l; i++) {
            const diff = sorted(toNumber(partsA[i]), toNumber(partsB[i]));
            if (diff) {
              return diff;
            }
          }
          return ;
        });
      }
      const latest = customSort ? tags[] : [...tags].reverse().find((tag) => tag.indexOf(".") >= );
      return new TagList(tags, latest);
    };
  }
});
var tag_exports = {};
__export(tag_exports, {
  addAnnotatedTagTask: () => addAnnotatedTagTask,
  addTagTask: () => addTagTask,
  tagListTask: () => tagListTask
});
function tagListTask(customArgs = []) {
  const hasCustomSort = customArgs.some((option) => /^--sort=/.test(option));
  return {
    format: "utf-",
    commands: ["tag", "-l", ...customArgs],
    parser(text) {
      return parseTagList(text, hasCustomSort);
    }
  };
}
function addTagTask(name) {
  return {
    format: "utf-",
    commands: ["tag", name],
    parser() {
      return { name };
    }
  };
}
function addAnnotatedTagTask(name, tagMessage) {
  return {
    format: "utf-",
    commands: ["tag", "-a", "-m", tagMessage, name],
    parser() {
      return { name };
    }
  };
}
var init_tag = __esm({
  "src/lib/tasks/tag.ts"() {
    init_TagList();
  }
});
var require_git = __commonJS({
  "src/git.js"(exports, module) {
    var { GitExecutor: GitExecutor } = (init_git_executor(), __toCommonJS(git_executor_exports));
    var { SimpleGitApi: SimpleGitApi } = (init_simple_git_api(), __toCommonJS(simple_git_api_exports));
    var { Scheduler: Scheduler } = (init_scheduler(), __toCommonJS(scheduler_exports));
    var { configurationErrorTask: configurationErrorTask } = (init_task(), __toCommonJS(task_exports));
    var {
      asArray: asArray,
      filterArray: filterArray,
      filterPrimitives: filterPrimitives,
      filterString: filterString,
      filterStringOrStringArray: filterStringOrStringArray,
      filterType: filterType,
      getTrailingOptions: getTrailingOptions,
      trailingFunctionArgument: trailingFunctionArgument,
      trailingOptionsArgument: trailingOptionsArgument
    } = (init_utils(), __toCommonJS(utils_exports));
    var { applyPatchTask: applyPatchTask } = (init_apply_patch(), __toCommonJS(apply_patch_exports));
    var {
      branchTask: branchTask,
      branchLocalTask: branchLocalTask,
      deleteBranchesTask: deleteBranchesTask,
      deleteBranchTask: deleteBranchTask
    } = (init_branch(), __toCommonJS(branch_exports));
    var { checkIgnoreTask: checkIgnoreTask } = (init_check_ignore(), __toCommonJS(check_ignore_exports));
    var { checkIsRepoTask: checkIsRepoTask } = (init_check_is_repo(), __toCommonJS(check_is_repo_exports));
    var { cloneTask: cloneTask, cloneMirrorTask: cloneMirrorTask } = (init_clone(), __toCommonJS(clone_exports));
    var { cleanWithOptionsTask: cleanWithOptionsTask, isCleanOptionsArray: isCleanOptionsArray } = (init_clean(), __toCommonJS(clean_exports));
    var { diffSummaryTask: diffSummaryTask } = (init_diff(), __toCommonJS(diff_exports));
    var { fetchTask: fetchTask } = (init_fetch(), __toCommonJS(fetch_exports));
    var { moveTask: moveTask } = (init_move(), __toCommonJS(move_exports));
    var { pullTask: pullTask } = (init_pull(), __toCommonJS(pull_exports));
    var { pushTagsTask: pushTagsTask } = (init_push(), __toCommonJS(push_exports));
    var {
      addRemoteTask: addRemoteTask,
      getRemotesTask: getRemotesTask,
      listRemotesTask: listRemotesTask,
      remoteTask: remoteTask,
      removeRemoteTask: removeRemoteTask
    } = (init_remote(), __toCommonJS(remote_exports));
    var { getResetMode: getResetMode, resetTask: resetTask } = (init_reset(), __toCommonJS(reset_exports));
    var { stashListTask: stashListTask } = (init_stash_list(), __toCommonJS(stash_list_exports));
    var {
      addSubModuleTask: addSubModuleTask,
      initSubModuleTask: initSubModuleTask,
      subModuleTask: subModuleTask,
      updateSubModuleTask: updateSubModuleTask
    } = (init_sub_module(), __toCommonJS(sub_module_exports));
    var { addAnnotatedTagTask: addAnnotatedTagTask, addTagTask: addTagTask, tagListTask: tagListTask } = (init_tag(), __toCommonJS(tag_exports));
    var { straightThroughBufferTask: straightThroughBufferTask, straightThroughStringTask: straightThroughStringTask } = (init_task(), __toCommonJS(task_exports));
    function Git(options, plugins) {
      this._executor = new GitExecutor(options.binary, options.baseDir, new Scheduler(options.maxConcurrentProcesses), plugins);
      this._trimmed = options.trimmed;
    }
    (Git.prototype = Object.create(SimpleGitApi.prototype)).constructor = Git;
    Git.prototype.customBinary = function(command) {
      this._executor.binary = command;
      return this;
    };
    Git.prototype.env = function(name, value) {
      if (arguments.length ===  && typeof name === "object") {
        this._executor.env = name;
      } else {
        (this._executor.env = this._executor.env || {})[name] = value;
      }
      return this;
    };
    Git.prototype.stashList = function(options) {
      return this._runTask(stashListTask(trailingOptionsArgument(arguments) || {}, filterArray(options) && options || []), trailingFunctionArgument(arguments));
    };
    function createCloneTask(api, task, repoPath, localPath) {
      if (typeof repoPath !== "string") {
        return configurationErrorTask(`git.${api}() requires a string 'repoPath'`);
      }
      return task(repoPath, filterType(localPath, filterString), getTrailingOptions(arguments));
    }
    Git.prototype.clone = function() {
      return this._runTask(createCloneTask("clone", cloneTask, ...arguments), trailingFunctionArgument(arguments));
    };
    Git.prototype.mirror = function() {
      return this._runTask(createCloneTask("mirror", cloneMirrorTask, ...arguments), trailingFunctionArgument(arguments));
    };
    Git.prototype.mv = function(from, to) {
      return this._runTask(moveTask(from, to), trailingFunctionArgument(arguments));
    };
    Git.prototype.checkoutLatestTag = function(then) {
      var git = this;
      return this.pull(function() {
        git.tags(function(err, tags) {
          git.checkout(tags.latest, then);
        });
      });
    };
    Git.prototype.pull = function(remote, branch, options, then) {
      return this._runTask(pullTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
    };
    Git.prototype.fetch = function(remote, branch) {
      return this._runTask(fetchTask(filterType(remote, filterString), filterType(branch, filterString), getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
    };
    Git.prototype.silent = function(silence) {
      console.warn("simple-git deprecation notice: git.silent: logging should be configured using the `debug` library / `DEBUG` environment variable, this will be an error in version ");
      return this;
    };
    Git.prototype.tags = function(options, then) {
      return this._runTask(tagListTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
    };
    Git.prototype.rebase = function() {
      return this._runTask(straightThroughStringTask(["rebase", ...getTrailingOptions(arguments)]), trailingFunctionArgument(arguments));
    };
    Git.prototype.reset = function(mode) {
      return this._runTask(resetTask(getResetMode(mode), getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
    };
    Git.prototype.revert = function(commit) {
      const next = trailingFunctionArgument(arguments);
      if (typeof commit !== "string") {
        return this._runTask(configurationErrorTask("Commit must be a string"), next);
      }
      return this._runTask(straightThroughStringTask(["revert", ...getTrailingOptions(arguments, , true), commit]), next);
    };
    Git.prototype.addTag = function(name) {
      const task = typeof name === "string" ? addTagTask(name) : configurationErrorTask("Git.addTag requires a tag name");
      return this._runTask(task, trailingFunctionArgument(arguments));
    };
    Git.prototype.addAnnotatedTag = function(tagName, tagMessage) {
      return this._runTask(addAnnotatedTagTask(tagName, tagMessage), trailingFunctionArgument(arguments));
    };
    Git.prototype.deleteLocalBranch = function(branchName, forceDelete, then) {
      return this._runTask(deleteBranchTask(branchName, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument(arguments));
    };
    Git.prototype.deleteLocalBranches = function(branchNames, forceDelete, then) {
      return this._runTask(deleteBranchesTask(branchNames, typeof forceDelete === "boolean" ? forceDelete : false), trailingFunctionArgument(arguments));
    };
    Git.prototype.branch = function(options, then) {
      return this._runTask(branchTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
    };
    Git.prototype.branchLocal = function(then) {
      return this._runTask(branchLocalTask(), trailingFunctionArgument(arguments));
    };
    Git.prototype.raw = function(commands) {
      const createRestCommands = !Array.isArray(commands);
      const command = [].slice.call(createRestCommands ? arguments : commands, );
      for (let i = ; i < command.length && createRestCommands; i++) {
        if (!filterPrimitives(command[i])) {
          command.splice(i, command.length - i);
          break;
        }
      }
      command.push(...getTrailingOptions(arguments, , true));
      var next = trailingFunctionArgument(arguments);
      if (!command.length) {
        return this._runTask(configurationErrorTask("Raw: must supply one or more command to execute"), next);
      }
      return this._runTask(straightThroughStringTask(command, this._trimmed), next);
    };
    Git.prototype.submoduleAdd = function(repo, path, then) {
      return this._runTask(addSubModuleTask(repo, path), trailingFunctionArgument(arguments));
    };
    Git.prototype.submoduleUpdate = function(args, then) {
      return this._runTask(updateSubModuleTask(getTrailingOptions(arguments, true)), trailingFunctionArgument(arguments));
    };
    Git.prototype.submoduleInit = function(args, then) {
      return this._runTask(initSubModuleTask(getTrailingOptions(arguments, true)), trailingFunctionArgument(arguments));
    };
    Git.prototype.subModule = function(options, then) {
      return this._runTask(subModuleTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
    };
    Git.prototype.listRemote = function() {
      return this._runTask(listRemotesTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
    };
    Git.prototype.addRemote = function(remoteName, remoteRepo, then) {
      return this._runTask(addRemoteTask(remoteName, remoteRepo, getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
    };
    Git.prototype.removeRemote = function(remoteName, then) {
      return this._runTask(removeRemoteTask(remoteName), trailingFunctionArgument(arguments));
    };
    Git.prototype.getRemotes = function(verbose, then) {
      return this._runTask(getRemotesTask(verbose === true), trailingFunctionArgument(arguments));
    };
    Git.prototype.remote = function(options, then) {
      return this._runTask(remoteTask(getTrailingOptions(arguments)), trailingFunctionArgument(arguments));
    };
    Git.prototype.tag = function(options, then) {
      const command = getTrailingOptions(arguments);
      if (command[] !== "tag") {
        command.unshift("tag");
      }
      return this._runTask(straightThroughStringTask(command), trailingFunctionArgument(arguments));
    };
    Git.prototype.updateServerInfo = function(then) {
      return this._runTask(straightThroughStringTask(["update-server-info"]), trailingFunctionArgument(arguments));
    };
    Git.prototype.pushTags = function(remote, then) {
      const task = pushTagsTask({ remote: filterType(remote, filterString) }, getTrailingOptions(arguments));
      return this._runTask(task, trailingFunctionArgument(arguments));
    };
    Git.prototype.rm = function(files) {
      return this._runTask(straightThroughStringTask(["rm", "-f", ...asArray(files)]), trailingFunctionArgument(arguments));
    };
    Git.prototype.rmKeepLocal = function(files) {
      return this._runTask(straightThroughStringTask(["rm", "--cached", ...asArray(files)]), trailingFunctionArgument(arguments));
    };
    Git.prototype.catFile = function(options, then) {
      return this._catFile("utf-", arguments);
    };
    Git.prototype.binaryCatFile = function() {
      return this._catFile("buffer", arguments);
    };
    Git.prototype._catFile = function(format, args) {
      var handler = trailingFunctionArgument(args);
      var command = ["cat-file"];
      var options = args[];
      if (typeof options === "string") {
        return this._runTask(configurationErrorTask("Git.catFile: options must be supplied as an array of strings"), handler);
      }
      if (Array.isArray(options)) {
        command.push.apply(command, options);
      }
      const task = format === "buffer" ? straightThroughBufferTask(command) : straightThroughStringTask(command);
      return this._runTask(task, handler);
    };
    Git.prototype.diff = function(options, then) {
      const task = filterString(options) ? configurationErrorTask("git.diff: supplying options as a single string is no longer supported, switch to an array of strings") : straightThroughStringTask(["diff", ...getTrailingOptions(arguments)]);
      return this._runTask(task, trailingFunctionArgument(arguments));
    };
    Git.prototype.diffSummary = function() {
      return this._runTask(diffSummaryTask(getTrailingOptions(arguments, )), trailingFunctionArgument(arguments));
    };
    Git.prototype.applyPatch = function(patches) {
      const task = !filterStringOrStringArray(patches) ? configurationErrorTask(`git.applyPatch requires one or more string patches as the first argument`) : applyPatchTask(asArray(patches), getTrailingOptions([].slice.call(arguments, )));
      return this._runTask(task, trailingFunctionArgument(arguments));
    };
    Git.prototype.revparse = function() {
      const commands = ["rev-parse", ...getTrailingOptions(arguments, true)];
      return this._runTask(straightThroughStringTask(commands, true), trailingFunctionArgument(arguments));
    };
    Git.prototype.show = function(options, then) {
      return this._runTask(straightThroughStringTask(["show", ...getTrailingOptions(arguments, )]), trailingFunctionArgument(arguments));
    };
    Git.prototype.clean = function(mode, options, then) {
      const usingCleanOptionsArray = isCleanOptionsArray(mode);
      const cleanMode = usingCleanOptionsArray && mode.join("") || filterType(mode, filterString) || "";
      const customArgs = getTrailingOptions([].slice.call(arguments, usingCleanOptionsArray ?  : ));
      return this._runTask(cleanWithOptionsTask(cleanMode, customArgs), trailingFunctionArgument(arguments));
    };
    Git.prototype.exec = function(then) {
      const task = {
        commands: [],
        format: "utf-",
        parser() {
          if (typeof then === "function") {
            then();
          }
        }
      };
      return this._runTask(task);
    };
    Git.prototype.clearQueue = function() {
      return this;
    };
    Git.prototype.checkIgnore = function(pathnames, then) {
      return this._runTask(checkIgnoreTask(asArray(filterType(pathnames, filterStringOrStringArray, []))), trailingFunctionArgument(arguments));
    };
    Git.prototype.checkIsRepo = function(checkType, then) {
      return this._runTask(checkIsRepoTask(filterType(checkType, filterString)), trailingFunctionArgument(arguments));
    };
    module.exports = Git;
  }
});
init_git_error();
var GitConstructError = class extends GitError {
  constructor(config, message) {
    super(void , message);
    this.config = config;
  }
};
init_git_error();
init_git_error();
var GitPluginError = class extends GitError {
  constructor(task, plugin, message) {
    super(task, message);
    this.task = task;
    this.plugin = plugin;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};
init_git_response_error();
init_task_configuration_error();
init_check_is_repo();
init_clean();
init_config();
init_grep();
init_reset();
function abortPlugin(signal) {
  if (!signal) {
    return;
  }
  const onSpawnAfter = {
    type: "spawn.after",
    action(_data, context) {
      function kill() {
        context.kill(new GitPluginError(void , "abort", "Abort signal received"));
      }
      signal.addEventListener("abort", kill);
      context.spawned.on("close", () => signal.removeEventListener("abort", kill));
    }
  };
  const onSpawnBefore = {
    type: "spawn.before",
    action(_data, context) {
      if (signal.aborted) {
        context.kill(new GitPluginError(void , "abort", "Abort already signaled"));
      }
    }
  };
  return [onSpawnBefore, onSpawnAfter];
}
function isConfigSwitch(arg) {
  return typeof arg === "string" && arg.trim().toLowerCase() === "-c";
}
function preventProtocolOverride(arg, next) {
  if (!isConfigSwitch(arg)) {
    return;
  }
  if (!/^\sprotocol(.[a-z]+)?.allow/.test(next)) {
    return;
  }
  throw new GitPluginError(void , "unsafe", "Configuring protocol.allow is not permitted without enabling allowUnsafeExtProtocol");
}
function preventUploadPack(arg, method) {
  if (/^\s--(upload|receive)-pack/.test(arg)) {
    throw new GitPluginError(void , "unsafe", `Use of --upload-pack or --receive-pack is not permitted without enabling allowUnsafePack`);
  }
  if (method === "clone" && /^\s-u\b/.test(arg)) {
    throw new GitPluginError(void , "unsafe", `Use of clone with option -u is not permitted without enabling allowUnsafePack`);
  }
  if (method === "push" && /^\s--exec\b/.test(arg)) {
    throw new GitPluginError(void , "unsafe", `Use of push with option --exec is not permitted without enabling allowUnsafePack`);
  }
}
function blockUnsafeOperationsPlugin({
  allowUnsafeProtocolOverride = false,
  allowUnsafePack = false
} = {}) {
  return {
    type: "spawn.args",
    action(args, context) {
      args.forEach((current, index) => {
        const next = index < args.length ? args[index + ] : "";
        allowUnsafeProtocolOverride || preventProtocolOverride(current, next);
        allowUnsafePack || preventUploadPack(current, context.method);
      });
      return args;
    }
  };
}
init_utils();
function commandConfigPrefixingPlugin(configuration) {
  const prefix = prefixedArray(configuration, "-c");
  return {
    type: "spawn.args",
    action(data) {
      return [...prefix, ...data];
    }
  };
}
init_utils();
var never = (, import_promise_deferred.deferred)().promise;
function completionDetectionPlugin({
  onClose = true,
  onExit = 
} = {}) {
  function createEvents() {
    let exitCode = -;
    const events = {
      close: (, import_promise_deferred.deferred)(),
      closeTimeout: (, import_promise_deferred.deferred)(),
      exit: (, import_promise_deferred.deferred)(),
      exitTimeout: (, import_promise_deferred.deferred)()
    };
    const result = Promise.race([
      onClose === false ? never : events.closeTimeout.promise,
      onExit === false ? never : events.exitTimeout.promise
    ]);
    configureTimeout(onClose, events.close, events.closeTimeout);
    configureTimeout(onExit, events.exit, events.exitTimeout);
    return {
      close(code) {
        exitCode = code;
        events.close.done();
      },
      exit(code) {
        exitCode = code;
        events.exit.done();
      },
      get exitCode() {
        return exitCode;
      },
      result
    };
  }
  function configureTimeout(flag, event, timeout) {
    if (flag === false) {
      return;
    }
    (flag === true ? event.promise : event.promise.then(() => delay(flag))).then(timeout.done);
  }
  return {
    type: "spawn.after",
    action(_, _) {
      return __async(this, arguments, function (_data, { spawned, close }) {
        var _a, _b;
        const events = createEvents();
        let deferClose = true;
        let quickClose = () => void (deferClose = false);
        (_a = spawned.stdout) == null ? void  : _a.on("data", quickClose);
        (_b = spawned.stderr) == null ? void  : _b.on("data", quickClose);
        spawned.on("error", quickClose);
        spawned.on("close", (code) => events.close(code));
        spawned.on("exit", (code) => events.exit(code));
        try {
          yield events.result;
          if (deferClose) {
            yield delay();
          }
          close(events.exitCode);
        } catch (err) {
          close(events.exitCode, err);
        }
      });
    }
  };
}
init_git_error();
function isTaskError(result) {
  return !!(result.exitCode && result.stdErr.length);
}
function getErrorMessage(result) {
  return Buffer.concat([...result.stdOut, ...result.stdErr]);
}
function errorDetectionHandler(overwrite = false, isError = isTaskError, errorMessage = getErrorMessage) {
  return (error, result) => {
    if (!overwrite && error || !isError(result)) {
      return error;
    }
    return errorMessage(result);
  };
}
function errorDetectionPlugin(config) {
  return {
    type: "task.error",
    action(data, context) {
      const error = config(data.error, {
        stdErr: context.stdErr,
        stdOut: context.stdOut,
        exitCode: context.exitCode
      });
      if (Buffer.isBuffer(error)) {
        return { error: new GitError(void , error.toString("utf-")) };
      }
      return {
        error
      };
    }
  };
}
init_utils();
var PluginStore = class {
  constructor() {
    this.plugins = / @__PURE__ / new Set();
  }
  add(plugin) {
    const plugins = [];
    asArray(plugin).forEach((plugin) => plugin && this.plugins.add(append(plugins, plugin)));
    return () => {
      plugins.forEach((plugin) => this.plugins.delete(plugin));
    };
  }
  exec(type, data, context) {
    let output = data;
    const contextual = Object.freeze(Object.create(context));
    for (const plugin of this.plugins) {
      if (plugin.type === type) {
        output = plugin.action(output, contextual);
      }
    }
    return output;
  }
};
init_utils();
function progressMonitorPlugin(progress) {
  const progressCommand = "--progress";
  const progressMethods = ["checkout", "clone", "fetch", "pull", "push"];
  const onProgress = {
    type: "spawn.after",
    action(_data, context) {
      var _a;
      if (!context.commands.includes(progressCommand)) {
        return;
      }
      (_a = context.spawned.stderr) == null ? void  : _a.on("data", (chunk) => {
        const message = /^([\s\S]+?):\s(\d+)% \((\d+)\/(\d+)\)/.exec(chunk.toString("utf"));
        if (!message) {
          return;
        }
        progress({
          method: context.method,
          stage: progressEventStage(message[]),
          progress: asNumber(message[]),
          processed: asNumber(message[]),
          total: asNumber(message[])
        });
      });
    }
  };
  const onArgs = {
    type: "spawn.args",
    action(args, context) {
      if (!progressMethods.includes(context.method)) {
        return args;
      }
      return including(args, progressCommand);
    }
  };
  return [onArgs, onProgress];
}
function progressEventStage(input) {
  return String(input.toLowerCase().split(" ", )) || "unknown";
}
init_utils();
function spawnOptionsPlugin(spawnOptions) {
  const options = pick(spawnOptions, ["uid", "gid"]);
  return {
    type: "spawn.options",
    action(data) {
      return __spreadValues(__spreadValues({}, options), data);
    }
  };
}
function timeoutPlugin({
  block,
  stdErr = true,
  stdOut = true
}) {
  if (block > ) {
    return {
      type: "spawn.after",
      action(_data, context) {
        var _a, _b;
        let timeout;
        function wait() {
          timeout && clearTimeout(timeout);
          timeout = setTimeout(kill, block);
        }
        function stop() {
          var _a, _b;
          (_a = context.spawned.stdout) == null ? void  : _a.off("data", wait);
          (_b = context.spawned.stderr) == null ? void  : _b.off("data", wait);
          context.spawned.off("exit", stop);
          context.spawned.off("close", stop);
          timeout && clearTimeout(timeout);
        }
        function kill() {
          stop();
          context.kill(new GitPluginError(void , "timeout", `block timeout reached`));
        }
        stdOut && ((_a = context.spawned.stdout) == null ? void  : _a.on("data", wait));
        stdErr && ((_b = context.spawned.stderr) == null ? void  : _b.on("data", wait));
        context.spawned.on("exit", stop);
        context.spawned.on("close", stop);
        wait();
      }
    };
  }
}
init_utils();
var Git = require_git();
function gitInstanceFactory(baseDir, options) {
  const plugins = new PluginStore();
  const config = createInstanceConfig(baseDir && (typeof baseDir === "string" ? { baseDir } : baseDir) || {}, options);
  if (!folderExists(config.baseDir)) {
    throw new GitConstructError(config, `Cannot use simple-git on a directory that does not exist`);
  }
  if (Array.isArray(config.config)) {
    plugins.add(commandConfigPrefixingPlugin(config.config));
  }
  plugins.add(blockUnsafeOperationsPlugin(config.unsafe));
  plugins.add(completionDetectionPlugin(config.completion));
  config.abort && plugins.add(abortPlugin(config.abort));
  config.progress && plugins.add(progressMonitorPlugin(config.progress));
  config.timeout && plugins.add(timeoutPlugin(config.timeout));
  config.spawnOptions && plugins.add(spawnOptionsPlugin(config.spawnOptions));
  plugins.add(errorDetectionPlugin(errorDetectionHandler(true)));
  config.errors && plugins.add(errorDetectionPlugin(config.errors));
  return new Git(config, plugins);
}
init_git_response_error();
var esm_default = gitInstanceFactory;

// src/simpleGit.ts
var SimpleGit = class extends GitManager {
  constructor(plugin) {
    super(plugin);
  }
  async setGitInstance(ignoreError = false) {
    if (this.isGitInstalled()) {
      const adapter = this.app.vault.adapter;
      const path = adapter.getBasePath();
      let basePath = path;
      if (this.plugin.settings.basePath) {
        const exists = await adapter.exists(
          (, import_obsidian.normalizePath)(this.plugin.settings.basePath)
        );
        if (exists) {
          basePath = path + import_path.sep + this.plugin.settings.basePath;
        } else if (!ignoreError) {
          new import_obsidian.Notice("ObsidianGit: Base path does not exist");
        }
      }
      this.git = esm_default({
        baseDir: basePath,
        binary: this.plugin.localStorage.getGitPath() || void ,
        config: ["core.quotepath=off"]
      });
      const pathPaths = this.plugin.localStorage.getPATHPaths();
      const envVars = this.plugin.localStorage.getEnvVars();
      const gitDir = this.plugin.settings.gitDir;
      if (pathPaths.length > ) {
        const path = process.env["PATH"] + ":" + pathPaths.join(":");
        process.env["PATH"] = path;
      }
      if (gitDir) {
        process.env["GIT_DIR"] = gitDir;
      }
      for (const envVar of envVars) {
        const [key, value] = envVar.split("=");
        process.env[key] = value;
      }
      import_debug.default.enable("simple-git");
      if (await this.git.checkIsRepo()) {
        await this.git.cwd(await this.git.revparse("--show-toplevel"));
      }
    }
  }
  async status() {
    this.plugin.setState( / status /);
    const status = await this.git.status((err) => this.onError(err));
    this.plugin.setState( / idle /);
    return {
      changed: status.files.filter((e) => e.working_dir !== " ").map((e) => {
        const res = this.formatPath(e);
        return {
          path: res.path,
          from: res.from,
          working_dir: e.working_dir === "?" ? "U" : e.working_dir,
          vault_path: this.getVaultPath(res.path)
        };
      }),
      staged: status.files.filter((e) => e.index !== " " && e.index != "?").map((e) => {
        const res = this.formatPath(e, e.index === "R");
        return {
          path: res.path,
          from: res.from,
          index: e.index,
          vault_path: this.getVaultPath(res.path)
        };
      }),
      conflicted: status.conflicted.map(
        (path) => this.formatPath({ path: path }).path
      )
    };
  }
  async getSubmodulePaths() {
    return new Promise(async (resolve) => {
      this.git.outputHandler(async (cmd, stdout, stderr, args) => {
        if (!(args.contains("submodule") && args.contains("foreach"))) {
          return;
        }
        let body = "";
        const root = this.app.vault.adapter.getBasePath() + (this.plugin.settings.basePath ? "/" + this.plugin.settings.basePath : "");
        stdout.on("data", (chunk) => {
          body += chunk.toString("utf");
        });
        stdout.on("end", async () => {
          const submods = body.split("\n");
          const strippedSubmods = submods.map((i) => {
            const submod = i.match(/'([^'])'/);
            if (submod != void ) {
              return root + "/" + submod[] + import_path.sep;
            }
          }).filter((i) => !!i);
          strippedSubmods.reverse();
          resolve(strippedSubmods);
        });
      });
      await this.git.subModule(["foreach", "--recursive", ""]);
      this.git.outputHandler(() => {
      });
    });
  }
  //Remove wrong `"` like "My file.md"
  formatPath(path, renamed = false) {
    function format(path) {
      if (path == void )
        return void ;
      if (path.startsWith('"') && path.endsWith('"')) {
        return path.substring(, path.length - );
      } else {
        return path;
      }
    }
    if (renamed) {
      return {
        from: format(path.from),
        path: format(path.path)
      };
    } else {
      return {
        path: format(path.path)
      };
    }
  }
  async commitAll({ message }) {
    if (this.plugin.settings.updateSubmodules) {
      this.plugin.setState( / commit /);
      const submodulePaths = await this.getSubmodulePaths();
      for (const item of submodulePaths) {
        await this.git.cwd({ path: item, root: false }).add("-A", (err) => this.onError(err));
        await this.git.cwd({ path: item, root: false }).commit(
          await this.formatCommitMessage(message),
          (err) => this.onError(err)
        );
      }
    }
    this.plugin.setState( / add /);
    await this.git.add("-A", (err) => this.onError(err));
    this.plugin.setState( / commit /);
    return (await this.git.commit(
      await this.formatCommitMessage(message),
      (err) => this.onError(err)
    )).summary.changes;
  }
  async commit(message) {
    this.plugin.setState( / commit /);
    const res = (await this.git.commit(
      await this.formatCommitMessage(message),
      (err) => this.onError(err)
    )).summary.changes;
    this.plugin.setState( / idle /);
    return res;
  }
  async stage(path, relativeToVault) {
    this.plugin.setState( / add /);
    path = this.getPath(path, relativeToVault);
    await this.git.add(["--", path], (err) => this.onError(err));
    this.plugin.setState( / idle /);
  }
  async stageAll({ dir }) {
    this.plugin.setState( / add /);
    await this.git.add(dir != null ? dir : "-A", (err) => this.onError(err));
    this.plugin.setState( / idle /);
  }
  async unstageAll({ dir }) {
    this.plugin.setState( / add /);
    await this.git.reset(
      dir != void  ? ["--", dir] : [],
      (err) => this.onError(err)
    );
    this.plugin.setState( / idle /);
  }
  async unstage(path, relativeToVault) {
    this.plugin.setState( / add /);
    path = this.getPath(path, relativeToVault);
    await this.git.reset(["--", path], (err) => this.onError(err));
    this.plugin.setState( / idle /);
  }
  async discard(filepath) {
    this.plugin.setState( / add /);
    await this.git.checkout(["--", filepath], (err) => this.onError(err));
    this.plugin.setState( / idle /);
  }
  async discardAll({ dir }) {
    return this.discard(dir != null ? dir : ".");
  }
  async pull() {
    this.plugin.setState( / pull /);
    if (this.plugin.settings.updateSubmodules)
      await this.git.subModule(
        ["update", "--remote", "--merge", "--recursive"],
        (err) => this.onError(err)
      );
    const branchInfo = await this.branchInfo();
    const localCommit = await this.git.revparse(
      [branchInfo.current],
      (err) => this.onError(err)
    );
    await this.git.fetch((err) => this.onError(err));
    const upstreamCommit = await this.git.revparse(
      [branchInfo.tracking],
      (err) => this.onError(err)
    );
    if (localCommit !== upstreamCommit) {
      if (this.plugin.settings.syncMethod === "merge" || this.plugin.settings.syncMethod === "rebase") {
        try {
          switch (this.plugin.settings.syncMethod) {
            case "merge":
              await this.git.merge([branchInfo.tracking]);
              break;
            case "rebase":
              await this.git.rebase([branchInfo.tracking]);
          }
        } catch (err) {
          this.plugin.displayError(
            `Pull failed (${this.plugin.settings.syncMethod}): ${err.message}`
          );
          return;
        }
      } else if (this.plugin.settings.syncMethod === "reset") {
        try {
          await this.git.raw(
            [
              "update-ref",
              `refs/heads/${branchInfo.current}`,
              upstreamCommit
            ],
            (err) => this.onError(err)
          );
          await this.unstageAll({});
        } catch (err) {
          this.plugin.displayError(
            `Sync failed (${this.plugin.settings.syncMethod}): ${err.message}`
          );
        }
      }
      const afterMergeCommit = await this.git.revparse(
        [branchInfo.current],
        (err) => this.onError(err)
      );
      const filesChanged = await this.git.diff([
        `${localCommit}..${afterMergeCommit}`,
        "--name-only"
      ]);
      return filesChanged.split(/\r\n|\r|\n/).filter((value) => value.length > ).map((e) => {
        return {
          path: e,
          working_dir: "P",
          vault_path: this.getVaultPath(e)
        };
      });
    } else {
      return [];
    }
  }
  async push() {
    this.plugin.setState( / status /);
    const status = await this.git.status();
    const trackingBranch = status.tracking;
    const currentBranch = status.current;
    const remoteChangedFiles = (await this.git.diffSummary(
      [currentBranch, trackingBranch, "--"],
      (err) => this.onError(err)
    )).changed;
    this.plugin.setState( / push /);
    if (this.plugin.settings.updateSubmodules) {
      await this.git.env({ ...process.env, OBSIDIAN_GIT:  }).subModule(
        [
          "foreach",
          "--recursive",
          `tracking=$(git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref -q HEAD)"); echo $tracking; if [ ! -z "$(git diff --shortstat $tracking)" ]; then git push; fi`
        ],
        (err) => this.onError(err)
      );
    }
    await this.git.env({ ...process.env, OBSIDIAN_GIT:  }).push((err) => this.onError(err));
    return remoteChangedFiles;
  }
  async getUnpushedCommits() {
    const status = await this.git.status();
    const trackingBranch = status.tracking;
    const currentBranch = status.current;
    if (trackingBranch == null || currentBranch == null) {
      return ;
    }
    const remoteChangedFiles = (await this.git.diffSummary(
      [currentBranch, trackingBranch, "--"],
      (err) => this.onError(err)
    )).changed;
    return remoteChangedFiles;
  }
  async canPush() {
    if (this.plugin.settings.updateSubmodules === true) {
      return true;
    }
    const status = await this.git.status((err) => this.onError(err));
    const trackingBranch = status.tracking;
    const currentBranch = status.current;
    const remoteChangedFiles = (await this.git.diffSummary([currentBranch, trackingBranch, "--"])).changed;
    return remoteChangedFiles !== ;
  }
  async checkRequirements() {
    if (!this.isGitInstalled()) {
      return "missing-git";
    }
    if (!await this.git.checkIsRepo()) {
      return "missing-repo";
    }
    return "valid";
  }
  async branchInfo() {
    const status = await this.git.status((err) => this.onError(err));
    const branches = await this.git.branch(
      ["--no-color"],
      (err) => this.onError(err)
    );
    return {
      current: status.current || void ,
      tracking: status.tracking || void ,
      branches: branches.all
    };
  }
  async getRemoteUrl(remote) {
    return await this.git.remote(
      ["get-url", remote],
      (err, url) => this.onError(err)
    ) || void ;
  }
  // https://github.com/kometenstaub/obsidian-version-history-diff/issues/
  async log(file, relativeToVault = true, limit) {
    let path;
    if (file) {
      path = this.getPath(file, relativeToVault);
    }
    const res = await this.git.log(
      {
        file: path,
        maxCount: limit,
        "-m": null,
        "--name-status": null
      },
      (err) => this.onError(err)
    );
    return res.all.map((e) => {
      var _a, _b;
      return {
        ...e,
        refs: e.refs.split(", "),
        diff: {
          ...e.diff,
          files: e.diff.files.map((f) => ({
            ...f,
            status: f.status,
            path: f.file,
            hash: e.hash,
            vault_path: this.getVaultPath(f.file)
          }))
        },
        fileName: (_b = (_a = e.diff) == null ? void  : _a.files.first()) == null ? void  : _b.file
      };
    });
  }
  async show(commitHash, file, relativeToVault = true) {
    const path = this.getPath(file, relativeToVault);
    return this.git.show(
      [commitHash + ":" + path],
      (err) => this.onError(err)
    );
  }
  async checkout(branch, remote) {
    if (remote) {
      branch = `${remote}/${branch}`;
    }
    await this.git.checkout(branch, (err) => this.onError(err));
    if (this.plugin.settings.submoduleRecurseCheckout) {
      const submodulePaths = await this.getSubmodulePaths();
      for (const submodulePath of submodulePaths) {
        const branchSummary = await this.git.cwd({ path: submodulePath, root: false }).branch();
        if (Object.keys(branchSummary.branches).includes(branch)) {
          await this.git.cwd({ path: submodulePath, root: false }).checkout(branch, (err) => this.onError(err));
        }
      }
    }
  }
  async createBranch(branch) {
    await this.git.checkout(["-b", branch], (err) => this.onError(err));
  }
  async deleteBranch(branch, force) {
    await this.git.branch(
      [force ? "-D" : "-d", branch],
      (err) => this.onError(err)
    );
  }
  async branchIsMerged(branch) {
    const notMergedBranches = await this.git.branch(
      ["--no-merged"],
      (err) => this.onError(err)
    );
    return !notMergedBranches.all.contains(branch);
  }
  async init() {
    await this.git.init(false, (err) => this.onError(err));
  }
  async clone(url, dir, depth) {
    await this.git.clone(
      url,
      path.join(
        this.app.vault.adapter.getBasePath(),
        dir
      ),
      depth ? ["--depth", `${depth}`] : [],
      (err) => this.onError(err)
    );
  }
  async setConfig(path, value) {
    if (value == void ) {
      await this.git.raw(["config", "--local", "--unset", path]);
    } else {
      await this.git.addConfig(path, value, (err) => this.onError(err));
    }
  }
  async getConfig(path) {
    const config = await this.git.listConfig(
      "local",
      (err) => this.onError(err)
    );
    return config.all[path];
  }
  async fetch(remote) {
    await this.git.fetch(
      remote != void  ? [remote] : [],
      (err) => this.onError(err)
    );
  }
  async setRemote(name, url) {
    if ((await this.getRemotes()).includes(name))
      await this.git.remote(
        ["set-url", name, url],
        (err) => this.onError(err)
      );
    else {
      await this.git.remote(
        ["add", name, url],
        (err) => this.onError(err)
      );
    }
  }
  async getRemoteBranches(remote) {
    const res = await this.git.branch(
      ["-r", "--list", `${remote}`],
      (err) => this.onError(err)
    );
    console.log(remote);
    console.log(res);
    const list = [];
    for (const item in res.branches) {
      list.push(res.branches[item].name);
    }
    return list;
  }
  async getRemotes() {
    const res = await this.git.remote([], (err) => this.onError(err));
    if (res) {
      return res.trim().split("\n");
    } else {
      return [];
    }
  }
  async removeRemote(remoteName) {
    await this.git.removeRemote(remoteName);
  }
  async updateUpstreamBranch(remoteBranch) {
    try {
      await this.git.branch(["--set-upstream-to", remoteBranch]);
    } catch (e) {
      console.error(e);
      try {
        await this.git.branch(["--set-upstream", remoteBranch]);
      } catch (e) {
        console.error(e);
        await this.git.push(
          // A type error occurs here because the third element could be undefined.
          // However, it is unlikely to be undefined due to the `remoteBranch`'s format, and error handling is in place.
          // Therefore, we temporarily ignore the error.
          // @ts-ignore
          ["--set-upstream", ...splitRemoteBranch(remoteBranch)],
          (err) => this.onError(err)
        );
      }
    }
  }
  updateGitPath(gitPath) {
    this.setGitInstance();
  }
  updateBasePath(basePath) {
    this.setGitInstance(true);
  }
  async getDiffString(filePath, stagedChanges = false, hash) {
    if (stagedChanges)
      return await this.git.diff(["--cached", "--", filePath]);
    if (hash)
      return await this.git.show([`${hash}`, "--", filePath]);
    else
      return await this.git.diff(["--", filePath]);
  }
  async diff(file, commit, commit) {
    return await this.git.diff([`${commit}..${commit}`, "--", file]);
  }
  async getLastCommitTime() {
    const res = await this.git.log({ n:  }, (err) => this.onError(err));
    if (res != null && res.latest != null) {
      return new Date(res.latest.date);
    }
  }
  isGitInstalled() {
    const command = (, import_child_process.spawnSync)(
      this.plugin.localStorage.getGitPath() || "git",
      ["--version"],
      {
        stdio: "ignore"
      }
    );
    if (command.error) {
      console.error(command.error);
      return false;
    }
    return true;
  }
  onError(error) {
    if (error) {
      const networkFailure = error.message.contains("Could not resolve host") || error.message.match(
        /ssh: connect to host .? port .?: Operation timed out/
      ) || error.message.match(
        /ssh: connect to host .? port .?: Network is unreachable/
      );
      if (!networkFailure) {
        this.plugin.displayError(error.message);
        this.plugin.setState( / idle /);
      } else if (!this.plugin.offlineMode) {
        this.plugin.displayError(
          "Git: Going into offline mode. Future network errors will no longer be displayed.",
          e
        );
      }
      if (networkFailure) {
        this.plugin.offlineMode = true;
        this.plugin.setState( / idle /);
      }
    }
  }
};

// src/settings.ts
var ObsidianGitSettingsTab = class extends import_obsidian.PluginSettingTab {
  display() {
    const { containerEl } = this;
    const plugin = this.plugin;
    const commitOrBackup = plugin.settings.differentIntervalCommitAndPush ? "commit" : "backup";
    const gitReady = plugin.gitReady;
    containerEl.empty();
    containerEl.createEl("h", { text: "Git Backup settings" });
    if (!gitReady) {
      containerEl.createEl("p", {
        text: "Git is not ready. When all settings are correct you can configure auto backup, etc."
      });
    }
    if (gitReady) {
      containerEl.createEl("br");
      containerEl.createEl("h", { text: "Automatic" });
      new import_obsidian.Setting(containerEl).setName("Split automatic commit and push").setDesc("Enable to use separate timer for commit and push").addToggle(
        (toggle) => toggle.setValue(
          plugin.settings.differentIntervalCommitAndPush
        ).onChange((value) => {
          plugin.settings.differentIntervalCommitAndPush = value;
          plugin.saveSettings();
          plugin.clearAutoBackup();
          plugin.clearAutoPush();
          if (plugin.settings.autoSaveInterval > ) {
            plugin.startAutoBackup(
              plugin.settings.autoSaveInterval
            );
          }
          if (value && plugin.settings.autoPushInterval > ) {
            plugin.startAutoPush(
              plugin.settings.autoPushInterval
            );
          }
          this.display();
        })
      );
      new import_obsidian.Setting(containerEl).setName(`Vault ${commitOrBackup} interval (minutes)`).setDesc(
        `${plugin.settings.differentIntervalCommitAndPush ? "Commit" : "Commit and push"} changes every X minutes. Set to  (default) to disable. (See below setting for further configuration!)`
      ).addText(
        (text) => text.setValue(String(plugin.settings.autoSaveInterval)).onChange((value) => {
          if (!isNaN(Number(value))) {
            plugin.settings.autoSaveInterval = Number(value);
            plugin.saveSettings();
            if (plugin.settings.autoSaveInterval > ) {
              plugin.clearAutoBackup();
              plugin.startAutoBackup(
                plugin.settings.autoSaveInterval
              );
              new import_obsidian.Notice(
                `Automatic ${commitOrBackup} enabled! Every ${plugin.settings.autoSaveInterval} minutes.`
              );
            } else if (plugin.settings.autoSaveInterval <= ) {
              plugin.clearAutoBackup() && new import_obsidian.Notice(
                `Automatic ${commitOrBackup} disabled!`
              );
            }
          } else {
            new import_obsidian.Notice("Please specify a valid number.");
          }
        })
      );
      if (!plugin.settings.setLastSaveToLastCommit)
        new import_obsidian.Setting(containerEl).setName(`Auto Backup after file change`).setDesc(
          `If turned on, do auto ${commitOrBackup} every ${plugin.settings.autoSaveInterval} minutes after last change. This also prevents auto ${commitOrBackup} while editing a file. If turned off, it's independent from the last change.`
        ).addToggle(
          (toggle) => toggle.setValue(plugin.settings.autoBackupAfterFileChange).onChange((value) => {
            plugin.settings.autoBackupAfterFileChange = value;
            this.display();
            plugin.saveSettings();
            plugin.clearAutoBackup();
            if (plugin.settings.autoSaveInterval > ) {
              plugin.startAutoBackup(
                plugin.settings.autoSaveInterval
              );
            }
          })
        );
      if (!plugin.settings.autoBackupAfterFileChange)
        new import_obsidian.Setting(containerEl).setName(`Auto ${commitOrBackup} after latest commit`).setDesc(
          `If turned on, set last auto ${commitOrBackup} time to latest commit`
        ).addToggle(
          (toggle) => toggle.setValue(plugin.settings.setLastSaveToLastCommit).onChange(async (value) => {
            plugin.settings.setLastSaveToLastCommit = value;
            plugin.saveSettings();
            this.display();
            plugin.clearAutoBackup();
            await plugin.setUpAutoBackup();
          })
        );
      if (plugin.settings.differentIntervalCommitAndPush) {
        new import_obsidian.Setting(containerEl).setName(`Vault push interval (minutes)`).setDesc(
          "Push changes every X minutes. Set to  (default) to disable."
        ).addText(
          (text) => text.setValue(String(plugin.settings.autoPushInterval)).onChange((value) => {
            if (!isNaN(Number(value))) {
              plugin.settings.autoPushInterval = Number(value);
              plugin.saveSettings();
              if (plugin.settings.autoPushInterval > ) {
                plugin.clearAutoPush();
                plugin.startAutoPush(
                  plugin.settings.autoPushInterval
                );
                new import_obsidian.Notice(
                  `Automatic push enabled! Every ${plugin.settings.autoPushInterval} minutes.`
                );
              } else if (plugin.settings.autoPushInterval <= ) {
                plugin.clearAutoPush() && new import_obsidian.Notice(
                  "Automatic push disabled!"
                );
              }
            } else {
              new import_obsidian.Notice(
                "Please specify a valid number."
              );
            }
          })
        );
      }
      new import_obsidian.Setting(containerEl).setName("Auto pull interval (minutes)").setDesc(
        "Pull changes every X minutes. Set to  (default) to disable."
      ).addText(
        (text) => text.setValue(String(plugin.settings.autoPullInterval)).onChange((value) => {
          if (!isNaN(Number(value))) {
            plugin.settings.autoPullInterval = Number(value);
            plugin.saveSettings();
            if (plugin.settings.autoPullInterval > ) {
              plugin.clearAutoPull();
              plugin.startAutoPull(
                plugin.settings.autoPullInterval
              );
              new import_obsidian.Notice(
                `Automatic pull enabled! Every ${plugin.settings.autoPullInterval} minutes.`
              );
            } else if (plugin.settings.autoPullInterval <= ) {
              plugin.clearAutoPull() && new import_obsidian.Notice("Automatic pull disabled!");
            }
          } else {
            new import_obsidian.Notice("Please specify a valid number.");
          }
        })
      );
      new import_obsidian.Setting(containerEl).setName("Specify custom commit message on auto backup").setDesc("You will get a pop up to specify your message").addToggle(
        (toggle) => toggle.setValue(plugin.settings.customMessageOnAutoBackup).onChange((value) => {
          plugin.settings.customMessageOnAutoBackup = value;
          plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Commit message on auto backup/commit").setDesc(
        "Available placeholders: {{date}} (see below), {{hostname}} (see below) and {{numFiles}} (number of changed files in the commit)"
      ).addText(
        (text) => text.setPlaceholder("vault backup: {{date}}").setValue(plugin.settings.autoCommitMessage).onChange((value) => {
          plugin.settings.autoCommitMessage = value;
          plugin.saveSettings();
        })
      );
      containerEl.createEl("br");
      containerEl.createEl("h", { text: "Commit message" });
      new import_obsidian.Setting(containerEl).setName("Commit message on manual backup/commit").setDesc(
        "Available placeholders: {{date}} (see below), {{hostname}} (see below) and {{numFiles}} (number of changed files in the commit)"
      ).addText(
        (text) => text.setPlaceholder("vault backup: {{date}}").setValue(
          plugin.settings.commitMessage ? plugin.settings.commitMessage : ""
        ).onChange((value) => {
          plugin.settings.commitMessage = value;
          plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("{{date}} placeholder format").setDesc(
        'Specify custom date format. E.g. "YYYY-MM-DD HH:mm:ss"'
      ).addText(
        (text) => text.setPlaceholder(plugin.settings.commitDateFormat).setValue(plugin.settings.commitDateFormat).onChange(async (value) => {
          plugin.settings.commitDateFormat = value;
          await plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("{{hostname}} placeholder replacement").setDesc("Specify custom hostname for every device.").addText(
        (text) => {
          var _a;
          return text.setValue((_a = plugin.localStorage.getHostname()) != null ? _a : "").onChange(async (value) => {
            plugin.localStorage.setHostname(value);
          });
        }
      );
      new import_obsidian.Setting(containerEl).setName("Preview commit message").addButton(
        (button) => button.setButtonText("Preview").onClick(async () => {
          const commitMessagePreview = await plugin.gitManager.formatCommitMessage(
            plugin.settings.commitMessage
          );
          new import_obsidian.Notice(`${commitMessagePreview}`);
        })
      );
      new import_obsidian.Setting(containerEl).setName("List filenames affected by commit in the commit body").addToggle(
        (toggle) => toggle.setValue(plugin.settings.listChangedFilesInMessageBody).onChange((value) => {
          plugin.settings.listChangedFilesInMessageBody = value;
          plugin.saveSettings();
        })
      );
      containerEl.createEl("br");
      containerEl.createEl("h", { text: "Backup" });
      if (plugin.gitManager instanceof SimpleGit)
        new import_obsidian.Setting(containerEl).setName("Sync Method").setDesc(
          "Selects the method used for handling new changes found in your remote git repository."
        ).addDropdown((dropdown) => {
          const options = {
            merge: "Merge",
            rebase: "Rebase",
            reset: "Other sync service (Only updates the HEAD without touching the working directory)"
          };
          dropdown.addOptions(options);
          dropdown.setValue(plugin.settings.syncMethod);
          dropdown.onChange(async (option) => {
            plugin.settings.syncMethod = option;
            plugin.saveSettings();
          });
        });
      new import_obsidian.Setting(containerEl).setName("Pull updates on startup").setDesc("Automatically pull updates when Obsidian starts").addToggle(
        (toggle) => toggle.setValue(plugin.settings.autoPullOnBoot).onChange((value) => {
          plugin.settings.autoPullOnBoot = value;
          plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Push on backup").setDesc("Disable to only commit changes").addToggle(
        (toggle) => toggle.setValue(!plugin.settings.disablePush).onChange((value) => {
          plugin.settings.disablePush = !value;
          plugin.saveSettings();
        })
      );
      new import_obsidian.Setting(containerEl).setName("Pull changes before push").setDesc("Commit -> pull -> push (Only if pushing is enabled)").addToggle(
        (toggle) => toggle.setValue(plugin.settings.pullBeforePush).onChange((value) => {
          plugin.settings.pullBeforePush = value;
          plugin.saveSettings();
        })
      );
    }
    containerEl.createEl("br");
    containerEl.createEl("h", { text: "Miscellaneous" });
    new import_obsidian.Setting(containerEl).setName(
      "Automatically refresh Source Control View on file changes"
    ).setDesc(
      "On slower machines this may cause lags. If so, just disable this option"
    ).addToggle(
      (toggle) => toggle.setValue(plugin.settings.refreshSourceControl).onChange((value) => {
        plugin.settings.refreshSourceControl = value;
        plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Source Control View refresh interval").setDesc(
      "Milliseconds to wait after file change before refreshing the Source Control View"
    ).addText(
      (toggle) => toggle.setValue(
        plugin.settings.refreshSourceControlTimer.toString()
      ).setPlaceholder("").onChange((value) => {
        plugin.settings.refreshSourceControlTimer = Math.max(
          parseInt(value),
          
        );
        plugin.saveSettings();
        plugin.setRefreshDebouncer();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Disable notifications").setDesc(
      "Disable notifications for git operations to minimize distraction (refer to status bar for updates). Errors are still shown as notifications even if you enable this setting"
    ).addToggle(
      (toggle) => toggle.setValue(plugin.settings.disablePopups).onChange((value) => {
        plugin.settings.disablePopups = value;
        plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show status bar").setDesc(
      "Obsidian must be restarted for the changes to take affect"
    ).addToggle(
      (toggle) => toggle.setValue(plugin.settings.showStatusBar).onChange((value) => {
        plugin.settings.showStatusBar = value;
        plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show stage/unstage button in file menu").addToggle(
      (toggle) => toggle.setValue(plugin.settings.showFileMenu).onChange((value) => {
        plugin.settings.showFileMenu = value;
        plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show branch status bar").setDesc(
      "Obsidian must be restarted for the changes to take affect"
    ).addToggle(
      (toggle) => toggle.setValue(plugin.settings.showBranchStatusBar).onChange((value) => {
        plugin.settings.showBranchStatusBar = value;
        plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show changes files count in status bar").addToggle(
      (toggle) => toggle.setValue(plugin.settings.changedFilesInStatusBar).onChange((value) => {
        plugin.settings.changedFilesInStatusBar = value;
        plugin.saveSettings();
      })
    );
    containerEl.createEl("br");
    if (plugin.gitManager instanceof IsomorphicGit) {
      containerEl.createEl("h", {
        text: "Authentication/Commit Author"
      });
    } else {
      containerEl.createEl("h", { text: "Commit Author" });
    }
    if (plugin.gitManager instanceof IsomorphicGit)
      new import_obsidian.Setting(containerEl).setName(
        "Username on your git server. E.g. your username on GitHub"
      ).addText((cb) => {
        var _a;
        cb.setValue((_a = plugin.localStorage.getUsername()) != null ? _a : "");
        cb.onChange((value) => {
          plugin.localStorage.setUsername(value);
        });
      });
    if (plugin.gitManager instanceof IsomorphicGit)
      new import_obsidian.Setting(containerEl).setName("Password/Personal access token").setDesc(
        "Type in your password. You won't be able to see it again."
      ).addText((cb) => {
        cb.inputEl.autocapitalize = "off";
        cb.inputEl.autocomplete = "off";
        cb.inputEl.spellcheck = false;
        cb.onChange((value) => {
          plugin.localStorage.setPassword(value);
        });
      });
    if (gitReady)
      new import_obsidian.Setting(containerEl).setName("Author name for commit").addText(async (cb) => {
        cb.setValue(await plugin.gitManager.getConfig("user.name"));
        cb.onChange((value) => {
          plugin.gitManager.setConfig(
            "user.name",
            value == "" ? void  : value
          );
        });
      });
    if (gitReady)
      new import_obsidian.Setting(containerEl).setName("Author email for commit").addText(async (cb) => {
        cb.setValue(
          await plugin.gitManager.getConfig("user.email")
        );
        cb.onChange((value) => {
          plugin.gitManager.setConfig(
            "user.email",
            value == "" ? void  : value
          );
        });
      });
    containerEl.createEl("br");
    containerEl.createEl("h", { text: "Advanced" });
    if (plugin.gitManager instanceof SimpleGit) {
      new import_obsidian.Setting(containerEl).setName("Update submodules").setDesc(
        '"Create backup" and "pull" takes care of submodules. Missing features: Conflicted files, count of pulled/pushed/committed files. Tracking branch needs to be set for each submodule'
      ).addToggle(
        (toggle) => toggle.setValue(plugin.settings.updateSubmodules).onChange((value) => {
          plugin.settings.updateSubmodules = value;
          plugin.saveSettings();
        })
      );
      if (plugin.settings.updateSubmodules) {
        new import_obsidian.Setting(containerEl).setName("Submodule recurse checkout/switch").setDesc(
          "Whenever a checkout happens on the root repository, recurse the checkout on the submodules (if the branches exist)."
        ).addToggle(
          (toggle) => toggle.setValue(plugin.settings.submoduleRecurseCheckout).onChange((value) => {
            plugin.settings.submoduleRecurseCheckout = value;
            plugin.saveSettings();
          })
        );
      }
    }
    if (plugin.gitManager instanceof SimpleGit)
      new import_obsidian.Setting(containerEl).setName("Custom Git binary path").addText((cb) => {
        var _a;
        cb.setValue((_a = plugin.localStorage.getGitPath()) != null ? _a : "");
        cb.setPlaceholder("git");
        cb.onChange((value) => {
          plugin.localStorage.setGitPath(value);
          plugin.gitManager.updateGitPath(value || "git");
        });
      });
    if (plugin.gitManager instanceof SimpleGit)
      new import_obsidian.Setting(containerEl).setName("Additional environment variables").setDesc(
        "Use each line for a new environment variable in the format KEY=VALUE"
      ).addTextArea((cb) => {
        cb.setPlaceholder("GIT_DIR=/path/to/git/dir");
        cb.setValue(plugin.localStorage.getEnvVars().join("\n"));
        cb.onChange((value) => {
          plugin.localStorage.setEnvVars(value.split("\n"));
        });
      });
    if (plugin.gitManager instanceof SimpleGit)
      new import_obsidian.Setting(containerEl).setName("Additional PATH environment variable paths").setDesc("Use each line for one path").addTextArea((cb) => {
        cb.setValue(plugin.localStorage.getPATHPaths().join("\n"));
        cb.onChange((value) => {
          plugin.localStorage.setPATHPaths(value.split("\n"));
        });
      });
    if (plugin.gitManager instanceof SimpleGit)
      new import_obsidian.Setting(containerEl).setName("Reload with new environment variables").setDesc(
        "Removing previously added environment variables will not take effect until Obsidian is restarted."
      ).addButton((cb) => {
        cb.setButtonText("Reload");
        cb.setCta();
        cb.onClick(() => {
          plugin.gitManager.setGitInstance();
        });
      });
    new import_obsidian.Setting(containerEl).setName("Custom base path (Git repository path)").setDesc(
      `
            Sets the relative path to the vault from which the Git binary should be executed.
             Mostly used to set the path to the Git repository, which is only required if the Git repository is below the vault root directory. Use "\\" instead of "/" on Windows.
            `
    ).addText((cb) => {
      cb.setValue(plugin.settings.basePath);
      cb.setPlaceholder("directory/directory-with-git-repo");
      cb.onChange((value) => {
        plugin.settings.basePath = value;
        plugin.saveSettings();
        plugin.gitManager.updateBasePath(value || "");
      });
    });
    new import_obsidian.Setting(containerEl).setName("Custom Git directory path (Instead of '.git')").setDesc(
      `Requires restart of Obsidian to take effect. Use "\\" instead of "/" on Windows.`
    ).addText((cb) => {
      cb.setValue(plugin.settings.gitDir);
      cb.setPlaceholder(".git");
      cb.onChange((value) => {
        plugin.settings.gitDir = value;
        plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Disable on this device").addToggle(
      (toggle) => toggle.setValue(plugin.localStorage.getPluginDisabled()).onChange((value) => {
        plugin.localStorage.setPluginDisabled(value);
        if (value) {
          plugin.unloadPlugin();
        } else {
          plugin.loadPlugin();
        }
        new import_obsidian.Notice(
          "Obsidian must be restarted for the changes to take affect"
        );
      })
    );
    new import_obsidian.Setting(containerEl).setName("Donate").setDesc(
      "If you like this Plugin, consider donating to support continued development."
    ).addButton((bt) => {
      bt.buttonEl.outerHTML = "<a href='https://ko-fi.com/FFIQ' target='_blank'><img height='' style='border:px;height:px;' src='https://cdn.ko-fi.com/cdn/kofi.png?v=' border='' alt='Buy Me a Coffee at ko-fi.com' /></a>";
    });
    const info = containerEl.createDiv();
    info.setAttr("align", "center");
    info.setText(
      "Debugging and logging:\nYou can always see the logs of this and every other plugin by opening the console with"
    );
    const keys = containerEl.createDiv();
    keys.setAttr("align", "center");
    keys.addClass("obsidian-git-shortcuts");
    if (import_obsidian.Platform.isMacOS === true) {
      keys.createEl("kbd", { text: "CMD (\u) + OPTION (\u) + I" });
    } else {
      keys.createEl("kbd", { text: "CTRL + SHIFT + I" });
    }
  }
};

// src/statusBar.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
var StatusBar = class {
  constructor(statusBarEl, plugin) {
    this.statusBarEl = statusBarEl;
    this.plugin = plugin;
    this.messages = [];
    this.base = "obsidian-git-statusbar-";
    this.statusBarEl.setAttribute("aria-label-position", "top");
    addEventListener("git-refresh", this.refreshCommitTimestamp.bind(this));
  }
  displayMessage(message, timeout) {
    this.messages.push({
      message: `Git: ${message.slice(, )}`,
      timeout
    });
    this.display();
  }
  display() {
    if (this.messages.length >  && !this.currentMessage) {
      this.currentMessage = this.messages.shift();
      this.statusBarEl.addClass(this.base + "message");
      this.statusBarEl.ariaLabel = "";
      this.statusBarEl.setText(this.currentMessage.message);
      this.lastMessageTimestamp = Date.now();
    } else if (this.currentMessage) {
      const messageAge = Date.now() - this.lastMessageTimestamp;
      if (messageAge >= this.currentMessage.timeout) {
        this.currentMessage = null;
        this.lastMessageTimestamp = null;
      }
    } else {
      this.displayState();
    }
  }
  displayState() {
    if (this.statusBarEl.getText().length >  || !this.statusBarEl.hasChildNodes()) {
      this.statusBarEl.empty();
      this.iconEl = this.statusBarEl.createDiv();
      this.textEl = this.statusBarEl.createDiv();
      this.textEl.style.float = "right";
      this.textEl.style.marginLeft = "px";
      this.iconEl.style.float = "left";
    }
    switch (this.plugin.state) {
      case  / idle /:
        this.displayFromNow();
        break;
      case  / status /:
        this.statusBarEl.ariaLabel = "Checking repository status...";
        (, import_obsidian.setIcon)(this.iconEl, "refresh-cw");
        this.statusBarEl.addClass(this.base + "status");
        break;
      case  / add /:
        this.statusBarEl.ariaLabel = "Adding files...";
        (, import_obsidian.setIcon)(this.iconEl, "refresh-w");
        this.statusBarEl.addClass(this.base + "add");
        break;
      case  / commit /:
        this.statusBarEl.ariaLabel = "Committing changes...";
        (, import_obsidian.setIcon)(this.iconEl, "git-commit");
        this.statusBarEl.addClass(this.base + "commit");
        break;
      case  / push /:
        this.statusBarEl.ariaLabel = "Pushing changes...";
        (, import_obsidian.setIcon)(this.iconEl, "upload");
        this.statusBarEl.addClass(this.base + "push");
        break;
      case  / pull /:
        this.statusBarEl.ariaLabel = "Pulling changes...";
        (, import_obsidian.setIcon)(this.iconEl, "download");
        this.statusBarEl.addClass(this.base + "pull");
        break;
      case  / conflicted /:
        this.statusBarEl.ariaLabel = "You have conflict files...";
        (, import_obsidian.setIcon)(this.iconEl, "alert-circle");
        this.statusBarEl.addClass(this.base + "conflict");
        break;
      default:
        this.statusBarEl.ariaLabel = "Failed on initialization!";
        (, import_obsidian.setIcon)(this.iconEl, "alert-triangle");
        this.statusBarEl.addClass(this.base + "failed-init");
        break;
    }
  }
  displayFromNow() {
    var _a;
    const timestamp = this.lastCommitTimestamp;
    if (timestamp) {
      const moment = window.moment;
      const fromNow = moment(timestamp).fromNow();
      this.statusBarEl.ariaLabel = `${this.plugin.offlineMode ? "Offline: " : ""}Last Commit: ${fromNow}`;
      if ((_a = this.unPushedCommits) != null ? _a :  > ) {
        this.statusBarEl.ariaLabel += `
(${this.unPushedCommits} unpushed commits)`;
      }
    } else {
      this.statusBarEl.ariaLabel = this.plugin.offlineMode ? "Git is offline" : "Git is ready";
    }
    if (this.plugin.offlineMode) {
      (, import_obsidian.setIcon)(this.iconEl, "globe");
    } else {
      (, import_obsidian.setIcon)(this.iconEl, "check");
    }
    if (this.plugin.settings.changedFilesInStatusBar && this.plugin.cachedStatus) {
      this.textEl.setText(
        this.plugin.cachedStatus.changed.length.toString()
      );
    }
    this.statusBarEl.addClass(this.base + "idle");
  }
  async refreshCommitTimestamp() {
    this.lastCommitTimestamp = await this.plugin.gitManager.getLastCommitTime();
    this.unPushedCommits = await this.plugin.gitManager.getUnpushedCommits();
  }
};

// src/ui/modals/changedFilesModal.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
var ChangedFilesModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(plugin, changedFiles) {
    super(plugin.app);
    this.plugin = plugin;
    this.changedFiles = changedFiles;
    this.setPlaceholder(
      "Not supported files will be opened by default app!"
    );
  }
  getItems() {
    return this.changedFiles;
  }
  getItemText(item) {
    if (item.index == "U" && item.working_dir == "U") {
      return `Untracked | ${item.vault_path}`;
    }
    let working_dir = "";
    let index = "";
    if (item.working_dir != " ")
      working_dir = `Working dir: ${item.working_dir} `;
    if (item.index != " ")
      index = `Index: ${item.index}`;
    return `${working_dir}${index} | ${item.vault_path}`;
  }
  onChooseItem(item, _) {
    if (this.plugin.app.metadataCache.getFirstLinkpathDest(
      item.vault_path,
      ""
    ) == null) {
      this.app.openWithDefaultApp(item.vault_path);
    } else {
      this.plugin.app.workspace.openLinkText(item.vault_path, "/");
    }
  }
};

// src/ui/modals/customMessageModal.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
var CustomMessageModal = class extends import_obsidian.SuggestModal {
  constructor(plugin, fromAutoBackup) {
    super(plugin.app);
    this.fromAutoBackup = fromAutoBackup;
    this.resolve = null;
    this.plugin = plugin;
    this.setPlaceholder(
      "Type your message and select optional the version with the added date."
    );
  }
  open() {
    super.open();
    return new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  onClose() {
    if (this.resolve)
      this.resolve(void );
  }
  selectSuggestion(value, evt) {
    if (this.resolve)
      this.resolve(value);
    super.selectSuggestion(value, evt);
  }
  getSuggestions(query) {
    const date = window.moment().format(this.plugin.settings.commitDateFormat);
    if (query == "")
      query = "...";
    return [query, `${date}: ${query}`, `${query}: ${date}`];
  }
  renderSuggestion(value, el) {
    el.innerText = value;
  }
  onChooseSuggestion(item, _) {
  }
};

// src/constants.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  commitMessage: "vault backup: {{date}}",
  commitDateFormat: "YYYY-MM-DD HH:mm:ss",
  autoSaveInterval: ,
  autoPushInterval: ,
  autoPullInterval: ,
  autoPullOnBoot: false,
  disablePush: false,
  pullBeforePush: true,
  disablePopups: false,
  listChangedFilesInMessageBody: false,
  showStatusBar: true,
  updateSubmodules: false,
  syncMethod: "merge",
  customMessageOnAutoBackup: false,
  autoBackupAfterFileChange: false,
  treeStructure: false,
  refreshSourceControl: import_obsidian.Platform.isDesktopApp,
  basePath: "",
  differentIntervalCommitAndPush: false,
  changedFilesInStatusBar: false,
  showedMobileNotice: false,
  refreshSourceControlTimer: e,
  showBranchStatusBar: true,
  setLastSaveToLastCommit: false,
  submoduleRecurseCheckout: false,
  gitDir: "",
  showFileMenu: true
};
var SOURCE_CONTROL_VIEW_CONFIG = {
  type: "git-view",
  name: "Source Control",
  icon: "git-pull-request"
};
var HISTORY_VIEW_CONFIG = {
  type: "git-history-view",
  name: "History",
  icon: "history"
};
var DIFF_VIEW_CONFIG = {
  type: "diff-view",
  name: "Diff View",
  icon: "git-pull-request"
};

// src/localStorageSettings.ts
init_polyfill_buffer();
var LocalStorageSettings = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.prefix = this.plugin.manifest.id + ":";
  }
  migrate() {
    const keys = [
      "password",
      "hostname",
      "conflict",
      "lastAutoPull",
      "lastAutoBackup",
      "lastAutoPush",
      "gitPath",
      "pluginDisabled"
    ];
    for (const key of keys) {
      const old = localStorage.getItem(this.prefix + key);
      if (app.loadLocalStorage(this.prefix + key) == null && old != null) {
        if (old != null) {
          app.saveLocalStorage(this.prefix + key, old);
          localStorage.removeItem(this.prefix + key);
        }
      }
    }
  }
  getPassword() {
    return app.loadLocalStorage(this.prefix + "password");
  }
  setPassword(value) {
    return app.saveLocalStorage(this.prefix + "password", value);
  }
  getUsername() {
    return app.loadLocalStorage(this.prefix + "username");
  }
  setUsername(value) {
    return app.saveLocalStorage(this.prefix + "username", value);
  }
  getHostname() {
    return app.loadLocalStorage(this.prefix + "hostname");
  }
  setHostname(value) {
    return app.saveLocalStorage(this.prefix + "hostname", value);
  }
  getConflict() {
    return app.loadLocalStorage(this.prefix + "conflict");
  }
  setConflict(value) {
    return app.saveLocalStorage(this.prefix + "conflict", value);
  }
  getLastAutoPull() {
    return app.loadLocalStorage(this.prefix + "lastAutoPull");
  }
  setLastAutoPull(value) {
    return app.saveLocalStorage(this.prefix + "lastAutoPull", value);
  }
  getLastAutoBackup() {
    return app.loadLocalStorage(this.prefix + "lastAutoBackup");
  }
  setLastAutoBackup(value) {
    return app.saveLocalStorage(this.prefix + "lastAutoBackup", value);
  }
  getLastAutoPush() {
    return app.loadLocalStorage(this.prefix + "lastAutoPush");
  }
  setLastAutoPush(value) {
    return app.saveLocalStorage(this.prefix + "lastAutoPush", value);
  }
  getGitPath() {
    return app.loadLocalStorage(this.prefix + "gitPath");
  }
  setGitPath(value) {
    return app.saveLocalStorage(this.prefix + "gitPath", value);
  }
  getPATHPaths() {
    var _a, _b;
    return (_b = (_a = app.loadLocalStorage(this.prefix + "PATHPaths")) == null ? void  : _a.split(":")) != null ? _b : [];
  }
  setPATHPaths(value) {
    return app.saveLocalStorage(this.prefix + "PATHPaths", value.join(":"));
  }
  getEnvVars() {
    var _a;
    return JSON.parse(
      (_a = app.loadLocalStorage(this.prefix + "envVars")) != null ? _a : "[]"
    );
  }
  setEnvVars(value) {
    return app.saveLocalStorage(
      this.prefix + "envVars",
      JSON.stringify(value)
    );
  }
  getPluginDisabled() {
    return app.loadLocalStorage(this.prefix + "pluginDisabled") == "true";
  }
  setPluginDisabled(value) {
    return app.saveLocalStorage(this.prefix + "pluginDisabled", `${value}`);
  }
};

// src/openInGitHub.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
async function openLineInGitHub(editor, file, manager) {
  const data = await getData(manager);
  if (data.result === "failure") {
    new import_obsidian.Notice(data.reason);
    return;
  }
  const { isGitHub, branch: branch, repo, user } = data;
  if (isGitHub) {
    const path = manager.getPath(file.path, true);
    const from = editor.getCursor("from").line + ;
    const to = editor.getCursor("to").line + ;
    if (from === to) {
      window.open(
        `https://github.com/${user}/${repo}/blob/${branch}/${path}?plain=L${from}`
      );
    } else {
      window.open(
        `https://github.com/${user}/${repo}/blob/${branch}/${path}?plain=L${from}-L${to}`
      );
    }
  } else {
    new import_obsidian.Notice("It seems like you are not using GitHub");
  }
}
async function openHistoryInGitHub(file, manager) {
  const data = await getData(manager);
  if (data.result === "failure") {
    new import_obsidian.Notice(data.reason);
    return;
  }
  const { isGitHub, branch: branch, repo, user } = data;
  const path = manager.getPath(file.path, true);
  if (isGitHub) {
    window.open(
      `https://github.com/${user}/${repo}/commits/${branch}/${path}`
    );
  } else {
    new import_obsidian.Notice("It seems like you are not using GitHub");
  }
}
async function getData(manager) {
  const branchInfo = await manager.branchInfo();
  const remoteBranch = branchInfo.tracking;
  const branch = branchInfo.current;
  if (remoteBranch == null) {
    return {
      result: "failure",
      reason: "Remote branch is not configured"
    };
  }
  if (branch == null) {
    return {
      result: "failure",
      reason: "Failed to get current branch name"
    };
  }
  const remote = remoteBranch.substring(, remoteBranch.indexOf("/"));
  const remoteUrl = await manager.getConfig(
    `remote.${remote}.url`
  );
  const [isGitHub, httpsUser, httpsRepo, sshUser, sshRepo] = remoteUrl.match(
    /(?:^https:\/\/github\.com\/(.)\/(.)\.git$)|(?:^git@github\.com:(.)\/(.)\.git$)/
  );
  return {
    result: "success",
    isGitHub: !!isGitHub,
    repo: httpsRepo || sshRepo,
    user: httpsUser || sshUser,
    branch: branch
  };
}

// src/ui/diff/diffView.ts
init_polyfill_buffer();

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/diffhtml.js
init_polyfill_buffer();

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/diff-parser.js
init_polyfill_buffer();

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/types.js
init_polyfill_buffer();
var LineType;
(function(LineType) {
  LineType["INSERT"] = "insert";
  LineType["DELETE"] = "delete";
  LineType["CONTEXT"] = "context";
})(LineType || (LineType = {}));
var OutputFormatType = {
  LINE_BY_LINE: "line-by-line",
  SIDE_BY_SIDE: "side-by-side"
};
var LineMatchingType = {
  LINES: "lines",
  WORDS: "words",
  NONE: "none"
};
var DiffStyleType = {
  WORD: "word",
  CHAR: "char"
};

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/utils.js
init_polyfill_buffer();
var specials = [
  "-",
  "[",
  "]",
  "/",
  "{",
  "}",
  "(",
  ")",
  "",
  "+",
  "?",
  ".",
  "\\",
  "^",
  "$",
  "|"
];
var regex = RegExp("[" + specials.join("\\") + "]", "g");
function escapeForRegExp(str) {
  return str.replace(regex, "\\$&");
}
function unifyPath(path) {
  return path ? path.replace(/\\/g, "/") : path;
}
function hashCode(text) {
  var i, chr, len;
  var hash = ;
  for (i = , len = text.length; i < len; i++) {
    chr = text.charCodeAt(i);
    hash = (hash << ) - hash + chr;
    hash |= ;
  }
  return hash;
}

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/diff-parser.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === )
    for (var i = , l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, , i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function getExtension(filename, language) {
  var filenameParts = filename.split(".");
  return filenameParts.length >  ? filenameParts[filenameParts.length - ] : language;
}
function startsWithAny(str, prefixes) {
  return prefixes.reduce(function(startsWith, prefix) {
    return startsWith || str.startsWith(prefix);
  }, false);
}
var baseDiffFilenamePrefixes = ["a/", "b/", "i/", "w/", "c/", "o/"];
function getFilename(line, linePrefix, extraPrefix) {
  var prefixes = extraPrefix !== void  ? __spreadArray(__spreadArray([], baseDiffFilenamePrefixes, true), [extraPrefix], false) : baseDiffFilenamePrefixes;
  var FilenameRegExp = linePrefix ? new RegExp("^".concat(escapeForRegExp(linePrefix), ' "?(.+?)"?$')) : new RegExp('^"?(.+?)"?$');
  var _a = FilenameRegExp.exec(line) || [], _b = _a[], filename = _b === void  ? "" : _b;
  var matchingPrefix = prefixes.find(function(p) {
    return filename.indexOf(p) === ;
  });
  var fnameWithoutPrefix = matchingPrefix ? filename.slice(matchingPrefix.length) : filename;
  return fnameWithoutPrefix.replace(/\s+\d{}-\d{}-\d{} \d{}:\d{}:\d{}(?:\.\d+)? [+-]\d{}.$/, "");
}
function getSrcFilename(line, srcPrefix) {
  return getFilename(line, "---", srcPrefix);
}
function getDstFilename(line, dstPrefix) {
  return getFilename(line, "+++", dstPrefix);
}
function parse(diffInput, config) {
  if (config === void ) {
    config = {};
  }
  var files = [];
  var currentFile = null;
  var currentBlock = null;
  var oldLine = null;
  var oldLine = null;
  var newLine = null;
  var possibleOldName = null;
  var possibleNewName = null;
  var oldFileNameHeader = "--- ";
  var newFileNameHeader = "+++ ";
  var hunkHeaderPrefix = "@@";
  var oldMode = /^old mode (\d{})/;
  var newMode = /^new mode (\d{})/;
  var deletedFileMode = /^deleted file mode (\d{})/;
  var newFileMode = /^new file mode (\d{})/;
  var copyFrom = /^copy from "?(.+)"?/;
  var copyTo = /^copy to "?(.+)"?/;
  var renameFrom = /^rename from "?(.+)"?/;
  var renameTo = /^rename to "?(.+)"?/;
  var similarityIndex = /^similarity index (\d+)%/;
  var dissimilarityIndex = /^dissimilarity index (\d+)%/;
  var index = /^index ([\da-z]+)\.\.([\da-z]+)\s(\d{})?/;
  var binaryFiles = /^Binary files (.) and (.) differ/;
  var binaryDiff = /^GIT binary patch/;
  var combinedIndex = /^index ([\da-z]+),([\da-z]+)\.\.([\da-z]+)/;
  var combinedMode = /^mode (\d{}),(\d{})\.\.(\d{})/;
  var combinedNewFile = /^new file mode (\d{})/;
  var combinedDeletedFile = /^deleted file mode (\d{}),(\d{})/;
  var diffLines = diffInput.replace(/\\ No newline at end of file/g, "").replace(/\r\n?/g, "\n").split("\n");
  function saveBlock() {
    if (currentBlock !== null && currentFile !== null) {
      currentFile.blocks.push(currentBlock);
      currentBlock = null;
    }
  }
  function saveFile() {
    if (currentFile !== null) {
      if (!currentFile.oldName && possibleOldName !== null) {
        currentFile.oldName = possibleOldName;
      }
      if (!currentFile.newName && possibleNewName !== null) {
        currentFile.newName = possibleNewName;
      }
      if (currentFile.newName) {
        files.push(currentFile);
        currentFile = null;
      }
    }
    possibleOldName = null;
    possibleNewName = null;
  }
  function startFile() {
    saveBlock();
    saveFile();
    currentFile = {
      blocks: [],
      deletedLines: ,
      addedLines: 
    };
  }
  function startBlock(line) {
    saveBlock();
    var values;
    if (currentFile !== null) {
      if (values = /^@@ -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@./.exec(line)) {
        currentFile.isCombined = false;
        oldLine = parseInt(values[], );
        newLine = parseInt(values[], );
      } else if (values = /^@@@ -(\d+)(?:,\d+)? -(\d+)(?:,\d+)? \+(\d+)(?:,\d+)? @@@./.exec(line)) {
        currentFile.isCombined = true;
        oldLine = parseInt(values[], );
        oldLine = parseInt(values[], );
        newLine = parseInt(values[], );
      } else {
        if (line.startsWith(hunkHeaderPrefix)) {
          console.error("Failed to parse lines, starting in !");
        }
        oldLine = ;
        newLine = ;
        currentFile.isCombined = false;
      }
    }
    currentBlock = {
      lines: [],
      oldStartLine: oldLine,
      oldStartLine: oldLine,
      newStartLine: newLine,
      header: line
    };
  }
  function createLine(line) {
    if (currentFile === null || currentBlock === null || oldLine === null || newLine === null)
      return;
    var currentLine = {
      content: line
    };
    var addedPrefixes = currentFile.isCombined ? ["+ ", " +", "++"] : ["+"];
    var deletedPrefixes = currentFile.isCombined ? ["- ", " -", "--"] : ["-"];
    if (startsWithAny(line, addedPrefixes)) {
      currentFile.addedLines++;
      currentLine.type = LineType.INSERT;
      currentLine.oldNumber = void ;
      currentLine.newNumber = newLine++;
    } else if (startsWithAny(line, deletedPrefixes)) {
      currentFile.deletedLines++;
      currentLine.type = LineType.DELETE;
      currentLine.oldNumber = oldLine++;
      currentLine.newNumber = void ;
    } else {
      currentLine.type = LineType.CONTEXT;
      currentLine.oldNumber = oldLine++;
      currentLine.newNumber = newLine++;
    }
    currentBlock.lines.push(currentLine);
  }
  function existHunkHeader(line, lineIdx) {
    var idx = lineIdx;
    while (idx < diffLines.length - ) {
      if (line.startsWith("diff")) {
        return false;
      }
      if (diffLines[idx].startsWith(oldFileNameHeader) && diffLines[idx + ].startsWith(newFileNameHeader) && diffLines[idx + ].startsWith(hunkHeaderPrefix)) {
        return true;
      }
      idx++;
    }
    return false;
  }
  diffLines.forEach(function(line, lineIndex) {
    if (!line || line.startsWith("")) {
      return;
    }
    var values;
    var prevLine = diffLines[lineIndex - ];
    var nxtLine = diffLines[lineIndex + ];
    var afterNxtLine = diffLines[lineIndex + ];
    if (line.startsWith("diff --git") || line.startsWith("diff --combined")) {
      startFile();
      var gitDiffStart = /^diff --git "?([a-ciow]\/.+)"? "?([a-ciow]\/.+)"?/;
      if (values = gitDiffStart.exec(line)) {
        possibleOldName = getFilename(values[], void , config.dstPrefix);
        possibleNewName = getFilename(values[], void , config.srcPrefix);
      }
      if (currentFile === null) {
        throw new Error("Where is my file !!!");
      }
      currentFile.isGitDiff = true;
      return;
    }
    if (line.startsWith("Binary files") && !(currentFile === null || currentFile === void  ? void  : currentFile.isGitDiff)) {
      startFile();
      var unixDiffBinaryStart = /^Binary files "?([a-ciow]\/.+)"? and "?([a-ciow]\/.+)"? differ/;
      if (values = unixDiffBinaryStart.exec(line)) {
        possibleOldName = getFilename(values[], void , config.dstPrefix);
        possibleNewName = getFilename(values[], void , config.srcPrefix);
      }
      if (currentFile === null) {
        throw new Error("Where is my file !!!");
      }
      currentFile.isBinary = true;
      return;
    }
    if (!currentFile || !currentFile.isGitDiff && currentFile && line.startsWith(oldFileNameHeader) && nxtLine.startsWith(newFileNameHeader) && afterNxtLine.startsWith(hunkHeaderPrefix)) {
      startFile();
    }
    if (currentFile === null || currentFile === void  ? void  : currentFile.isTooBig) {
      return;
    }
    if (currentFile && (typeof config.diffMaxChanges === "number" && currentFile.addedLines + currentFile.deletedLines > config.diffMaxChanges || typeof config.diffMaxLineLength === "number" && line.length > config.diffMaxLineLength)) {
      currentFile.isTooBig = true;
      currentFile.addedLines = ;
      currentFile.deletedLines = ;
      currentFile.blocks = [];
      currentBlock = null;
      var message = typeof config.diffTooBigMessage === "function" ? config.diffTooBigMessage(files.length) : "Diff too big to be displayed";
      startBlock(message);
      return;
    }
    if (line.startsWith(oldFileNameHeader) && nxtLine.startsWith(newFileNameHeader) || line.startsWith(newFileNameHeader) && prevLine.startsWith(oldFileNameHeader)) {
      if (currentFile && !currentFile.oldName && line.startsWith("--- ") && (values = getSrcFilename(line, config.srcPrefix))) {
        currentFile.oldName = values;
        currentFile.language = getExtension(currentFile.oldName, currentFile.language);
        return;
      }
      if (currentFile && !currentFile.newName && line.startsWith("+++ ") && (values = getDstFilename(line, config.dstPrefix))) {
        currentFile.newName = values;
        currentFile.language = getExtension(currentFile.newName, currentFile.language);
        return;
      }
    }
    if (currentFile && (line.startsWith(hunkHeaderPrefix) || currentFile.isGitDiff && currentFile.oldName && currentFile.newName && !currentBlock)) {
      startBlock(line);
      return;
    }
    if (currentBlock && (line.startsWith("+") || line.startsWith("-") || line.startsWith(" "))) {
      createLine(line);
      return;
    }
    var doesNotExistHunkHeader = !existHunkHeader(line, lineIndex);
    if (currentFile === null) {
      throw new Error("Where is my file !!!");
    }
    if (values = oldMode.exec(line)) {
      currentFile.oldMode = values[];
    } else if (values = newMode.exec(line)) {
      currentFile.newMode = values[];
    } else if (values = deletedFileMode.exec(line)) {
      currentFile.deletedFileMode = values[];
      currentFile.isDeleted = true;
    } else if (values = newFileMode.exec(line)) {
      currentFile.newFileMode = values[];
      currentFile.isNew = true;
    } else if (values = copyFrom.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.oldName = values[];
      }
      currentFile.isCopy = true;
    } else if (values = copyTo.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.newName = values[];
      }
      currentFile.isCopy = true;
    } else if (values = renameFrom.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.oldName = values[];
      }
      currentFile.isRename = true;
    } else if (values = renameTo.exec(line)) {
      if (doesNotExistHunkHeader) {
        currentFile.newName = values[];
      }
      currentFile.isRename = true;
    } else if (values = binaryFiles.exec(line)) {
      currentFile.isBinary = true;
      currentFile.oldName = getFilename(values[], void , config.srcPrefix);
      currentFile.newName = getFilename(values[], void , config.dstPrefix);
      startBlock("Binary file");
    } else if (binaryDiff.test(line)) {
      currentFile.isBinary = true;
      startBlock(line);
    } else if (values = similarityIndex.exec(line)) {
      currentFile.unchangedPercentage = parseInt(values[], );
    } else if (values = dissimilarityIndex.exec(line)) {
      currentFile.changedPercentage = parseInt(values[], );
    } else if (values = index.exec(line)) {
      currentFile.checksumBefore = values[];
      currentFile.checksumAfter = values[];
      values[] && (currentFile.mode = values[]);
    } else if (values = combinedIndex.exec(line)) {
      currentFile.checksumBefore = [values[], values[]];
      currentFile.checksumAfter = values[];
    } else if (values = combinedMode.exec(line)) {
      currentFile.oldMode = [values[], values[]];
      currentFile.newMode = values[];
    } else if (values = combinedNewFile.exec(line)) {
      currentFile.newFileMode = values[];
      currentFile.isNew = true;
    } else if (values = combinedDeletedFile.exec(line)) {
      currentFile.deletedFileMode = values[];
      currentFile.isDeleted = true;
    }
  });
  saveBlock();
  saveFile();
  return files;
}

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/file-list-renderer.js
init_polyfill_buffer();

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/render-utils.js
init_polyfill_buffer();

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/rematch.js
init_polyfill_buffer();
function levenshtein(a, b) {
  if (a.length === ) {
    return b.length;
  }
  if (b.length === ) {
    return a.length;
  }
  var matrix = [];
  var i;
  for (i = ; i <= b.length; i++) {
    matrix[i] = [i];
  }
  var j;
  for (j = ; j <= a.length; j++) {
    matrix[][j] = j;
  }
  for (i = ; i <= b.length; i++) {
    for (j = ; j <= a.length; j++) {
      if (b.charAt(i - ) === a.charAt(j - )) {
        matrix[i][j] = matrix[i - ][j - ];
      } else {
        matrix[i][j] = Math.min(matrix[i - ][j - ] + , Math.min(matrix[i][j - ] + , matrix[i - ][j] + ));
      }
    }
  }
  return matrix[b.length][a.length];
}
function newDistanceFn(str) {
  return function(x, y) {
    var xValue = str(x).trim();
    var yValue = str(y).trim();
    var lev = levenshtein(xValue, yValue);
    return lev / (xValue.length + yValue.length);
  };
}
function newMatcherFn(distance) {
  function findBestMatch(a, b, cache) {
    if (cache === void ) {
      cache = / @__PURE__ / new Map();
    }
    var bestMatchDist = Infinity;
    var bestMatch;
    for (var i = ; i < a.length; ++i) {
      for (var j = ; j < b.length; ++j) {
        var cacheKey = JSON.stringify([a[i], b[j]]);
        var md = void ;
        if (!(cache.has(cacheKey) && (md = cache.get(cacheKey)))) {
          md = distance(a[i], b[j]);
          cache.set(cacheKey, md);
        }
        if (md < bestMatchDist) {
          bestMatchDist = md;
          bestMatch = { indexA: i, indexB: j, score: bestMatchDist };
        }
      }
    }
    return bestMatch;
  }
  function group(a, b, level, cache) {
    if (level === void ) {
      level = ;
    }
    if (cache === void ) {
      cache = / @__PURE__ / new Map();
    }
    var bm = findBestMatch(a, b, cache);
    if (!bm || a.length + b.length < ) {
      return [[a, b]];
    }
    var a = a.slice(, bm.indexA);
    var b = b.slice(, bm.indexB);
    var aMatch = [a[bm.indexA]];
    var bMatch = [b[bm.indexB]];
    var tailA = bm.indexA + ;
    var tailB = bm.indexB + ;
    var a = a.slice(tailA);
    var b = b.slice(tailB);
    var group = group(a, b, level + , cache);
    var groupMatch = group(aMatch, bMatch, level + , cache);
    var group = group(a, b, level + , cache);
    var result = groupMatch;
    if (bm.indexA >  || bm.indexB > ) {
      result = group.concat(result);
    }
    if (a.length > tailA || b.length > tailB) {
      result = result.concat(group);
    }
    return result;
  }
  return group;
}

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/render-utils.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = , n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var CSSLineClass = {
  INSERTS: "dh-ins",
  DELETES: "dh-del",
  CONTEXT: "dh-cntx",
  INFO: "dh-info",
  INSERT_CHANGES: "dh-ins dh-change",
  DELETE_CHANGES: "dh-del dh-change"
};
var defaultRenderConfig = {
  matching: LineMatchingType.NONE,
  matchWordsThreshold: .,
  maxLineLengthHighlight: e,
  diffStyle: DiffStyleType.WORD
};
var separator = "/";
var distance = newDistanceFn(function(change) {
  return change.value;
});
var matcher = newMatcherFn(distance);
function isDevNullName(name) {
  return name.indexOf("dev/null") !== -;
}
function removeInsElements(line) {
  return line.replace(/(<ins[^>]>((.|\n)?)<\/ins>)/g, "");
}
function removeDelElements(line) {
  return line.replace(/(<del[^>]>((.|\n)?)<\/del>)/g, "");
}
function toCSSClass(lineType) {
  switch (lineType) {
    case LineType.CONTEXT:
      return CSSLineClass.CONTEXT;
    case LineType.INSERT:
      return CSSLineClass.INSERTS;
    case LineType.DELETE:
      return CSSLineClass.DELETES;
  }
}
function prefixLength(isCombined) {
  return isCombined ?  : ;
}
function escapeForHtml(str) {
  return str.slice().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&x;").replace(/\//g, "&xF;");
}
function deconstructLine(line, isCombined, escape) {
  if (escape === void ) {
    escape = true;
  }
  var indexToSplit = prefixLength(isCombined);
  return {
    prefix: line.substring(, indexToSplit),
    content: escape ? escapeForHtml(line.substring(indexToSplit)) : line.substring(indexToSplit)
  };
}
function filenameDiff(file) {
  var oldFilename = unifyPath(file.oldName);
  var newFilename = unifyPath(file.newName);
  if (oldFilename !== newFilename && !isDevNullName(oldFilename) && !isDevNullName(newFilename)) {
    var prefixPaths = [];
    var suffixPaths = [];
    var oldFilenameParts = oldFilename.split(separator);
    var newFilenameParts = newFilename.split(separator);
    var oldFilenamePartsSize = oldFilenameParts.length;
    var newFilenamePartsSize = newFilenameParts.length;
    var i = ;
    var j = oldFilenamePartsSize - ;
    var k = newFilenamePartsSize - ;
    while (i < j && i < k) {
      if (oldFilenameParts[i] === newFilenameParts[i]) {
        prefixPaths.push(newFilenameParts[i]);
        i += ;
      } else {
        break;
      }
    }
    while (j > i && k > i) {
      if (oldFilenameParts[j] === newFilenameParts[k]) {
        suffixPaths.unshift(newFilenameParts[k]);
        j -= ;
        k -= ;
      } else {
        break;
      }
    }
    var finalPrefix = prefixPaths.join(separator);
    var finalSuffix = suffixPaths.join(separator);
    var oldRemainingPath = oldFilenameParts.slice(i, j + ).join(separator);
    var newRemainingPath = newFilenameParts.slice(i, k + ).join(separator);
    if (finalPrefix.length && finalSuffix.length) {
      return finalPrefix + separator + "{" + oldRemainingPath + " \u " + newRemainingPath + "}" + separator + finalSuffix;
    } else if (finalPrefix.length) {
      return finalPrefix + separator + "{" + oldRemainingPath + " \u " + newRemainingPath + "}";
    } else if (finalSuffix.length) {
      return "{" + oldRemainingPath + " \u " + newRemainingPath + "}" + separator + finalSuffix;
    }
    return oldFilename + " \u " + newFilename;
  } else if (!isDevNullName(newFilename)) {
    return newFilename;
  } else {
    return oldFilename;
  }
}
function getHtmlId(file) {
  return "dh-".concat(hashCode(filenameDiff(file)).toString().slice(-));
}
function getFileIcon(file) {
  var templateName = "file-changed";
  if (file.isRename) {
    templateName = "file-renamed";
  } else if (file.isCopy) {
    templateName = "file-renamed";
  } else if (file.isNew) {
    templateName = "file-added";
  } else if (file.isDeleted) {
    templateName = "file-deleted";
  } else if (file.newName !== file.oldName) {
    templateName = "file-renamed";
  }
  return templateName;
}
function diffHighlight(diffLine, diffLine, isCombined, config) {
  if (config === void ) {
    config = {};
  }
  var _a = __assign(__assign({}, defaultRenderConfig), config), matching = _a.matching, maxLineLengthHighlight = _a.maxLineLengthHighlight, matchWordsThreshold = _a.matchWordsThreshold, diffStyle = _a.diffStyle;
  var line = deconstructLine(diffLine, isCombined, false);
  var line = deconstructLine(diffLine, isCombined, false);
  if (line.content.length > maxLineLengthHighlight || line.content.length > maxLineLengthHighlight) {
    return {
      oldLine: {
        prefix: line.prefix,
        content: escapeForHtml(line.content)
      },
      newLine: {
        prefix: line.prefix,
        content: escapeForHtml(line.content)
      }
    };
  }
  var diff = diffStyle === "char" ? diffChars(line.content, line.content) : diffWordsWithSpace(line.content, line.content);
  var changedWords = [];
  if (diffStyle === "word" && matching === "words") {
    var removed = diff.filter(function(element) {
      return element.removed;
    });
    var added = diff.filter(function(element) {
      return element.added;
    });
    var chunks = matcher(added, removed);
    chunks.forEach(function(chunk) {
      if (chunk[].length ===  && chunk[].length === ) {
        var dist = distance(chunk[][], chunk[][]);
        if (dist < matchWordsThreshold) {
          changedWords.push(chunk[][]);
          changedWords.push(chunk[][]);
        }
      }
    });
  }
  var highlightedLine = diff.reduce(function(highlightedLine, part) {
    var elemType = part.added ? "ins" : part.removed ? "del" : null;
    var addClass = changedWords.indexOf(part) > - ? ' class="dh-change"' : "";
    var escapedValue = escapeForHtml(part.value);
    return elemType !== null ? "".concat(highlightedLine, "<").concat(elemType).concat(addClass, ">").concat(escapedValue, "</").concat(elemType, ">") : "".concat(highlightedLine).concat(escapedValue);
  }, "");
  return {
    oldLine: {
      prefix: line.prefix,
      content: removeInsElements(highlightedLine)
    },
    newLine: {
      prefix: line.prefix,
      content: removeDelElements(highlightedLine)
    }
  };
}

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/file-list-renderer.js
var baseTemplatesPath = "file-summary";
var iconsBaseTemplatesPath = "icon";
function render(diffFiles, hoganUtils) {
  var files = diffFiles.map(function(file) {
    return hoganUtils.render(baseTemplatesPath, "line", {
      fileHtmlId: getHtmlId(file),
      oldName: file.oldName,
      newName: file.newName,
      fileName: filenameDiff(file),
      deletedLines: "-" + file.deletedLines,
      addedLines: "+" + file.addedLines
    }, {
      fileIcon: hoganUtils.template(iconsBaseTemplatesPath, getFileIcon(file))
    });
  }).join("\n");
  return hoganUtils.render(baseTemplatesPath, "wrapper", {
    filesNumber: diffFiles.length,
    files
  });
}

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/line-by-line-renderer.js
init_polyfill_buffer();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = , n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var defaultLineByLineRendererConfig = __assign(__assign({}, defaultRenderConfig), { renderNothingWhenEmpty: false, matchingMaxComparisons: , maxLineSizeInBlockForComparison:  });
var genericTemplatesPath = "generic";
var baseTemplatesPath = "line-by-line";
var iconsBaseTemplatesPath = "icon";
var tagsBaseTemplatesPath = "tag";
var LineByLineRenderer = function() {
  function LineByLineRenderer(hoganUtils, config) {
    if (config === void ) {
      config = {};
    }
    this.hoganUtils = hoganUtils;
    this.config = __assign(__assign({}, defaultLineByLineRendererConfig), config);
  }
  LineByLineRenderer.prototype.render = function(diffFiles) {
    var _this = this;
    var diffsHtml = diffFiles.map(function(file) {
      var diffs;
      if (file.blocks.length) {
        diffs = _this.generateFileHtml(file);
      } else {
        diffs = _this.generateEmptyDiff();
      }
      return _this.makeFileDiffHtml(file, diffs);
    }).join("\n");
    return this.hoganUtils.render(genericTemplatesPath, "wrapper", { content: diffsHtml });
  };
  LineByLineRenderer.prototype.makeFileDiffHtml = function(file, diffs) {
    if (this.config.renderNothingWhenEmpty && Array.isArray(file.blocks) && file.blocks.length === )
      return "";
    var fileDiffTemplate = this.hoganUtils.template(baseTemplatesPath, "file-diff");
    var filePathTemplate = this.hoganUtils.template(genericTemplatesPath, "file-path");
    var fileIconTemplate = this.hoganUtils.template(iconsBaseTemplatesPath, "file");
    var fileTagTemplate = this.hoganUtils.template(tagsBaseTemplatesPath, getFileIcon(file));
    return fileDiffTemplate.render({
      file,
      fileHtmlId: getHtmlId(file),
      diffs,
      filePath: filePathTemplate.render({
        fileDiffName: filenameDiff(file)
      }, {
        fileIcon: fileIconTemplate,
        fileTag: fileTagTemplate
      })
    });
  };
  LineByLineRenderer.prototype.generateEmptyDiff = function() {
    return this.hoganUtils.render(genericTemplatesPath, "empty-diff", {
      contentClass: "dh-code-line",
      CSSLineClass
    });
  };
  LineByLineRenderer.prototype.generateFileHtml = function(file) {
    var _this = this;
    var matcher = newMatcherFn(newDistanceFn(function(e) {
      return deconstructLine(e.content, file.isCombined).content;
    }));
    return file.blocks.map(function(block) {
      var lines = _this.hoganUtils.render(genericTemplatesPath, "block-header", {
        CSSLineClass,
        blockHeader: file.isTooBig ? block.header : escapeForHtml(block.header),
        lineClass: "dh-code-linenumber",
        contentClass: "dh-code-line"
      });
      _this.applyLineGroupping(block).forEach(function(_a) {
        var contextLines = _a[], oldLines = _a[], newLines = _a[];
        if (oldLines.length && newLines.length && !contextLines.length) {
          _this.applyRematchMatching(oldLines, newLines, matcher).map(function(_a) {
            var oldLines = _a[], newLines = _a[];
            var _b = _this.processChangedLines(file, file.isCombined, oldLines, newLines), left = _b.left, right = _b.right;
            lines += left;
            lines += right;
          });
        } else if (contextLines.length) {
          contextLines.forEach(function(line) {
            var _a = deconstructLine(line.content, file.isCombined), prefix = _a.prefix, content = _a.content;
            lines += _this.generateSingleLineHtml(file, {
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              oldNumber: line.oldNumber,
              newNumber: line.newNumber
            });
          });
        } else if (oldLines.length || newLines.length) {
          var _b = _this.processChangedLines(file, file.isCombined, oldLines, newLines), left = _b.left, right = _b.right;
          lines += left;
          lines += right;
        } else {
          console.error("Unknown state reached while processing groups of lines", contextLines, oldLines, newLines);
        }
      });
      return lines;
    }).join("\n");
  };
  LineByLineRenderer.prototype.applyLineGroupping = function(block) {
    var blockLinesGroups = [];
    var oldLines = [];
    var newLines = [];
    for (var i = ; i < block.lines.length; i++) {
      var diffLine = block.lines[i];
      if (diffLine.type !== LineType.INSERT && newLines.length || diffLine.type === LineType.CONTEXT && oldLines.length > ) {
        blockLinesGroups.push([[], oldLines, newLines]);
        oldLines = [];
        newLines = [];
      }
      if (diffLine.type === LineType.CONTEXT) {
        blockLinesGroups.push([[diffLine], [], []]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length === ) {
        blockLinesGroups.push([[], [], [diffLine]]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length > ) {
        newLines.push(diffLine);
      } else if (diffLine.type === LineType.DELETE) {
        oldLines.push(diffLine);
      }
    }
    if (oldLines.length || newLines.length) {
      blockLinesGroups.push([[], oldLines, newLines]);
      oldLines = [];
      newLines = [];
    }
    return blockLinesGroups;
  };
  LineByLineRenderer.prototype.applyRematchMatching = function(oldLines, newLines, matcher) {
    var comparisons = oldLines.length  newLines.length;
    var maxLineSizeInBlock = Math.max.apply(null, [].concat(oldLines.concat(newLines).map(function(elem) {
      return elem.content.length;
    })));
    var doMatching = comparisons < this.config.matchingMaxComparisons && maxLineSizeInBlock < this.config.maxLineSizeInBlockForComparison && (this.config.matching === "lines" || this.config.matching === "words");
    return doMatching ? matcher(oldLines, newLines) : [[oldLines, newLines]];
  };
  LineByLineRenderer.prototype.processChangedLines = function(file, isCombined, oldLines, newLines) {
    var fileHtml = {
      right: "",
      left: ""
    };
    var maxLinesNumber = Math.max(oldLines.length, newLines.length);
    for (var i = ; i < maxLinesNumber; i++) {
      var oldLine = oldLines[i];
      var newLine = newLines[i];
      var diff = oldLine !== void  && newLine !== void  ? diffHighlight(oldLine.content, newLine.content, isCombined, this.config) : void ;
      var preparedOldLine = oldLine !== void  && oldLine.oldNumber !== void  ? __assign(__assign({}, diff !== void  ? {
        prefix: diff.oldLine.prefix,
        content: diff.oldLine.content,
        type: CSSLineClass.DELETE_CHANGES
      } : __assign(__assign({}, deconstructLine(oldLine.content, isCombined)), { type: toCSSClass(oldLine.type) })), { oldNumber: oldLine.oldNumber, newNumber: oldLine.newNumber }) : void ;
      var preparedNewLine = newLine !== void  && newLine.newNumber !== void  ? __assign(__assign({}, diff !== void  ? {
        prefix: diff.newLine.prefix,
        content: diff.newLine.content,
        type: CSSLineClass.INSERT_CHANGES
      } : __assign(__assign({}, deconstructLine(newLine.content, isCombined)), { type: toCSSClass(newLine.type) })), { oldNumber: newLine.oldNumber, newNumber: newLine.newNumber }) : void ;
      var _a = this.generateLineHtml(file, preparedOldLine, preparedNewLine), left = _a.left, right = _a.right;
      fileHtml.left += left;
      fileHtml.right += right;
    }
    return fileHtml;
  };
  LineByLineRenderer.prototype.generateLineHtml = function(file, oldLine, newLine) {
    return {
      left: this.generateSingleLineHtml(file, oldLine),
      right: this.generateSingleLineHtml(file, newLine)
    };
  };
  LineByLineRenderer.prototype.generateSingleLineHtml = function(file, line) {
    if (line === void )
      return "";
    var lineNumberHtml = this.hoganUtils.render(baseTemplatesPath, "numbers", {
      oldNumber: line.oldNumber || "",
      newNumber: line.newNumber || ""
    });
    return this.hoganUtils.render(genericTemplatesPath, "line", {
      type: line.type,
      lineClass: "dh-code-linenumber",
      contentClass: "dh-code-line",
      prefix: line.prefix === " " ? "&nbsp;" : line.prefix,
      content: line.content,
      lineNumber: lineNumberHtml,
      line,
      file
    });
  };
  return LineByLineRenderer;
}();
var line_by_line_renderer_default = LineByLineRenderer;

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/side-by-side-renderer.js
init_polyfill_buffer();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = , n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var defaultSideBySideRendererConfig = __assign(__assign({}, defaultRenderConfig), { renderNothingWhenEmpty: false, matchingMaxComparisons: , maxLineSizeInBlockForComparison:  });
var genericTemplatesPath = "generic";
var baseTemplatesPath = "side-by-side";
var iconsBaseTemplatesPath = "icon";
var tagsBaseTemplatesPath = "tag";
var SideBySideRenderer = function() {
  function SideBySideRenderer(hoganUtils, config) {
    if (config === void ) {
      config = {};
    }
    this.hoganUtils = hoganUtils;
    this.config = __assign(__assign({}, defaultSideBySideRendererConfig), config);
  }
  SideBySideRenderer.prototype.render = function(diffFiles) {
    var _this = this;
    var diffsHtml = diffFiles.map(function(file) {
      var diffs;
      if (file.blocks.length) {
        diffs = _this.generateFileHtml(file);
      } else {
        diffs = _this.generateEmptyDiff();
      }
      return _this.makeFileDiffHtml(file, diffs);
    }).join("\n");
    return this.hoganUtils.render(genericTemplatesPath, "wrapper", { content: diffsHtml });
  };
  SideBySideRenderer.prototype.makeFileDiffHtml = function(file, diffs) {
    if (this.config.renderNothingWhenEmpty && Array.isArray(file.blocks) && file.blocks.length === )
      return "";
    var fileDiffTemplate = this.hoganUtils.template(baseTemplatesPath, "file-diff");
    var filePathTemplate = this.hoganUtils.template(genericTemplatesPath, "file-path");
    var fileIconTemplate = this.hoganUtils.template(iconsBaseTemplatesPath, "file");
    var fileTagTemplate = this.hoganUtils.template(tagsBaseTemplatesPath, getFileIcon(file));
    return fileDiffTemplate.render({
      file,
      fileHtmlId: getHtmlId(file),
      diffs,
      filePath: filePathTemplate.render({
        fileDiffName: filenameDiff(file)
      }, {
        fileIcon: fileIconTemplate,
        fileTag: fileTagTemplate
      })
    });
  };
  SideBySideRenderer.prototype.generateEmptyDiff = function() {
    return {
      right: "",
      left: this.hoganUtils.render(genericTemplatesPath, "empty-diff", {
        contentClass: "dh-code-side-line",
        CSSLineClass
      })
    };
  };
  SideBySideRenderer.prototype.generateFileHtml = function(file) {
    var _this = this;
    var matcher = newMatcherFn(newDistanceFn(function(e) {
      return deconstructLine(e.content, file.isCombined).content;
    }));
    return file.blocks.map(function(block) {
      var fileHtml = {
        left: _this.makeHeaderHtml(block.header, file),
        right: _this.makeHeaderHtml("")
      };
      _this.applyLineGroupping(block).forEach(function(_a) {
        var contextLines = _a[], oldLines = _a[], newLines = _a[];
        if (oldLines.length && newLines.length && !contextLines.length) {
          _this.applyRematchMatching(oldLines, newLines, matcher).map(function(_a) {
            var oldLines = _a[], newLines = _a[];
            var _b = _this.processChangedLines(file.isCombined, oldLines, newLines), left = _b.left, right = _b.right;
            fileHtml.left += left;
            fileHtml.right += right;
          });
        } else if (contextLines.length) {
          contextLines.forEach(function(line) {
            var _a = deconstructLine(line.content, file.isCombined), prefix = _a.prefix, content = _a.content;
            var _b = _this.generateLineHtml({
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              number: line.oldNumber
            }, {
              type: CSSLineClass.CONTEXT,
              prefix,
              content,
              number: line.newNumber
            }), left = _b.left, right = _b.right;
            fileHtml.left += left;
            fileHtml.right += right;
          });
        } else if (oldLines.length || newLines.length) {
          var _b = _this.processChangedLines(file.isCombined, oldLines, newLines), left = _b.left, right = _b.right;
          fileHtml.left += left;
          fileHtml.right += right;
        } else {
          console.error("Unknown state reached while processing groups of lines", contextLines, oldLines, newLines);
        }
      });
      return fileHtml;
    }).reduce(function(accomulated, html) {
      return { left: accomulated.left + html.left, right: accomulated.right + html.right };
    }, { left: "", right: "" });
  };
  SideBySideRenderer.prototype.applyLineGroupping = function(block) {
    var blockLinesGroups = [];
    var oldLines = [];
    var newLines = [];
    for (var i = ; i < block.lines.length; i++) {
      var diffLine = block.lines[i];
      if (diffLine.type !== LineType.INSERT && newLines.length || diffLine.type === LineType.CONTEXT && oldLines.length > ) {
        blockLinesGroups.push([[], oldLines, newLines]);
        oldLines = [];
        newLines = [];
      }
      if (diffLine.type === LineType.CONTEXT) {
        blockLinesGroups.push([[diffLine], [], []]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length === ) {
        blockLinesGroups.push([[], [], [diffLine]]);
      } else if (diffLine.type === LineType.INSERT && oldLines.length > ) {
        newLines.push(diffLine);
      } else if (diffLine.type === LineType.DELETE) {
        oldLines.push(diffLine);
      }
    }
    if (oldLines.length || newLines.length) {
      blockLinesGroups.push([[], oldLines, newLines]);
      oldLines = [];
      newLines = [];
    }
    return blockLinesGroups;
  };
  SideBySideRenderer.prototype.applyRematchMatching = function(oldLines, newLines, matcher) {
    var comparisons = oldLines.length  newLines.length;
    var maxLineSizeInBlock = Math.max.apply(null, [].concat(oldLines.concat(newLines).map(function(elem) {
      return elem.content.length;
    })));
    var doMatching = comparisons < this.config.matchingMaxComparisons && maxLineSizeInBlock < this.config.maxLineSizeInBlockForComparison && (this.config.matching === "lines" || this.config.matching === "words");
    return doMatching ? matcher(oldLines, newLines) : [[oldLines, newLines]];
  };
  SideBySideRenderer.prototype.makeHeaderHtml = function(blockHeader, file) {
    return this.hoganUtils.render(genericTemplatesPath, "block-header", {
      CSSLineClass,
      blockHeader: (file === null || file === void  ? void  : file.isTooBig) ? blockHeader : escapeForHtml(blockHeader),
      lineClass: "dh-code-side-linenumber",
      contentClass: "dh-code-side-line"
    });
  };
  SideBySideRenderer.prototype.processChangedLines = function(isCombined, oldLines, newLines) {
    var fileHtml = {
      right: "",
      left: ""
    };
    var maxLinesNumber = Math.max(oldLines.length, newLines.length);
    for (var i = ; i < maxLinesNumber; i++) {
      var oldLine = oldLines[i];
      var newLine = newLines[i];
      var diff = oldLine !== void  && newLine !== void  ? diffHighlight(oldLine.content, newLine.content, isCombined, this.config) : void ;
      var preparedOldLine = oldLine !== void  && oldLine.oldNumber !== void  ? __assign(__assign({}, diff !== void  ? {
        prefix: diff.oldLine.prefix,
        content: diff.oldLine.content,
        type: CSSLineClass.DELETE_CHANGES
      } : __assign(__assign({}, deconstructLine(oldLine.content, isCombined)), { type: toCSSClass(oldLine.type) })), { number: oldLine.oldNumber }) : void ;
      var preparedNewLine = newLine !== void  && newLine.newNumber !== void  ? __assign(__assign({}, diff !== void  ? {
        prefix: diff.newLine.prefix,
        content: diff.newLine.content,
        type: CSSLineClass.INSERT_CHANGES
      } : __assign(__assign({}, deconstructLine(newLine.content, isCombined)), { type: toCSSClass(newLine.type) })), { number: newLine.newNumber }) : void ;
      var _a = this.generateLineHtml(preparedOldLine, preparedNewLine), left = _a.left, right = _a.right;
      fileHtml.left += left;
      fileHtml.right += right;
    }
    return fileHtml;
  };
  SideBySideRenderer.prototype.generateLineHtml = function(oldLine, newLine) {
    return {
      left: this.generateSingleHtml(oldLine),
      right: this.generateSingleHtml(newLine)
    };
  };
  SideBySideRenderer.prototype.generateSingleHtml = function(line) {
    var lineClass = "dh-code-side-linenumber";
    var contentClass = "dh-code-side-line";
    return this.hoganUtils.render(genericTemplatesPath, "line", {
      type: (line === null || line === void  ? void  : line.type) || "".concat(CSSLineClass.CONTEXT, " dh-emptyplaceholder"),
      lineClass: line !== void  ? lineClass : "".concat(lineClass, " dh-code-side-emptyplaceholder"),
      contentClass: line !== void  ? contentClass : "".concat(contentClass, " dh-code-side-emptyplaceholder"),
      prefix: (line === null || line === void  ? void  : line.prefix) === " " ? "&nbsp;" : line === null || line === void  ? void  : line.prefix,
      content: line === null || line === void  ? void  : line.content,
      lineNumber: line === null || line === void  ? void  : line.number
    });
  };
  return SideBySideRenderer;
}();
var side_by_side_renderer_default = SideBySideRenderer;

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/hoganjs-utils.js
init_polyfill_buffer();
var Hogan = __toESM(require_hogan());

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/diffhtml-templates.js
init_polyfill_buffer();
var Hogan = __toESM(require_hogan());
var defaultTemplates = {};
defaultTemplates["file-summary-line"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<li class="dh-file-list-line">');
  t.b("\n" + i);
  t.b('    <span class="dh-file-name-wrapper">');
  t.b("\n" + i);
  t.b(t.rp("<fileIcon", c, p, "      "));
  t.b('      <a href="');
  t.b(t.v(t.f("fileHtmlId", c, p, )));
  t.b('" class="dh-file-name">');
  t.b(t.v(t.f("fileName", c, p, )));
  t.b("</a>");
  t.b("\n" + i);
  t.b('      <span class="dh-file-stats">');
  t.b("\n" + i);
  t.b('          <span class="dh-lines-added">');
  t.b(t.v(t.f("addedLines", c, p, )));
  t.b("</span>");
  t.b("\n" + i);
  t.b('          <span class="dh-lines-deleted">');
  t.b(t.v(t.f("deletedLines", c, p, )));
  t.b("</span>");
  t.b("\n" + i);
  t.b("      </span>");
  t.b("\n" + i);
  t.b("    </span>");
  t.b("\n" + i);
  t.b("</li>");
  return t.fl();
}, partials: { "<fileIcon": { name: "fileIcon", partials: {}, subs: {} } }, subs: {} });
defaultTemplates["file-summary-wrapper"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<div class="dh-file-list-wrapper">');
  t.b("\n" + i);
  t.b('    <div class="dh-file-list-header">');
  t.b("\n" + i);
  t.b('        <span class="dh-file-list-title">Files changed (');
  t.b(t.v(t.f("filesNumber", c, p, )));
  t.b(")</span>");
  t.b("\n" + i);
  t.b('        <a class="dh-file-switch dh-hide">hide</a>');
  t.b("\n" + i);
  t.b('        <a class="dh-file-switch dh-show">show</a>');
  t.b("\n" + i);
  t.b("    </div>");
  t.b("\n" + i);
  t.b('    <ol class="dh-file-list">');
  t.b("\n" + i);
  t.b("    ");
  t.b(t.t(t.f("files", c, p, )));
  t.b("\n" + i);
  t.b("    </ol>");
  t.b("\n" + i);
  t.b("</div>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-block-header"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b("<tr>");
  t.b("\n" + i);
  t.b('    <td class="');
  t.b(t.v(t.f("lineClass", c, p, )));
  t.b(" ");
  t.b(t.v(t.d("CSSLineClass.INFO", c, p, )));
  t.b('"></td>');
  t.b("\n" + i);
  t.b('    <td class="');
  t.b(t.v(t.d("CSSLineClass.INFO", c, p, )));
  t.b('">');
  t.b("\n" + i);
  t.b('        <div class="');
  t.b(t.v(t.f("contentClass", c, p, )));
  t.b('">');
  if (t.s(t.f("blockHeader", c, p, ), c, p, , , , "{{ }}")) {
    t.rs(c, p, function(c, p, t) {
      t.b(t.t(t.f("blockHeader", c, p, )));
    });
    c.pop();
  }
  if (!t.s(t.f("blockHeader", c, p, ), c, p, , , , "")) {
    t.b("&nbsp;");
  }
  ;
  t.b("</div>");
  t.b("\n" + i);
  t.b("    </td>");
  t.b("\n" + i);
  t.b("</tr>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-empty-diff"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b("<tr>");
  t.b("\n" + i);
  t.b('    <td class="');
  t.b(t.v(t.d("CSSLineClass.INFO", c, p, )));
  t.b('">');
  t.b("\n" + i);
  t.b('        <div class="');
  t.b(t.v(t.f("contentClass", c, p, )));
  t.b('">');
  t.b("\n" + i);
  t.b("            File without changes");
  t.b("\n" + i);
  t.b("        </div>");
  t.b("\n" + i);
  t.b("    </td>");
  t.b("\n" + i);
  t.b("</tr>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-file-path"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<span class="dh-file-name-wrapper">');
  t.b("\n" + i);
  t.b(t.rp("<fileIcon", c, p, "    "));
  t.b('    <span class="dh-file-name">');
  t.b(t.v(t.f("fileDiffName", c, p, )));
  t.b("</span>");
  t.b("\n" + i);
  t.b(t.rp("<fileTag", c, p, "    "));
  t.b("</span>");
  t.b("\n" + i);
  t.b('<label class="dh-file-collapse">');
  t.b("\n" + i);
  t.b('    <input class="dh-file-collapse-input" type="checkbox" name="viewed" value="viewed">');
  t.b("\n" + i);
  t.b("    Viewed");
  t.b("\n" + i);
  t.b("</label>");
  return t.fl();
}, partials: { "<fileIcon": { name: "fileIcon", partials: {}, subs: {} }, "<fileTag": { name: "fileTag", partials: {}, subs: {} } }, subs: {} });
defaultTemplates["generic-line"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b("<tr>");
  t.b("\n" + i);
  t.b('    <td class="');
  t.b(t.v(t.f("lineClass", c, p, )));
  t.b(" ");
  t.b(t.v(t.f("type", c, p, )));
  t.b('">');
  t.b("\n" + i);
  t.b("      ");
  t.b(t.t(t.f("lineNumber", c, p, )));
  t.b("\n" + i);
  t.b("    </td>");
  t.b("\n" + i);
  t.b('    <td class="');
  t.b(t.v(t.f("type", c, p, )));
  t.b('">');
  t.b("\n" + i);
  t.b('        <div class="');
  t.b(t.v(t.f("contentClass", c, p, )));
  t.b('">');
  t.b("\n" + i);
  if (t.s(t.f("prefix", c, p, ), c, p, , , , "{{ }}")) {
    t.rs(c, p, function(c, p, t) {
      t.b('            <span class="dh-code-line-prefix">');
      t.b(t.t(t.f("prefix", c, p, )));
      t.b("</span>");
      t.b("\n" + i);
    });
    c.pop();
  }
  if (!t.s(t.f("prefix", c, p, ), c, p, , , , "")) {
    t.b('            <span class="dh-code-line-prefix">&nbsp;</span>');
    t.b("\n" + i);
  }
  ;
  if (t.s(t.f("content", c, p, ), c, p, , , , "{{ }}")) {
    t.rs(c, p, function(c, p, t) {
      t.b('            <span class="dh-code-line-ctn">');
      t.b(t.t(t.f("content", c, p, )));
      t.b("</span>");
      t.b("\n" + i);
    });
    c.pop();
  }
  if (!t.s(t.f("content", c, p, ), c, p, , , , "")) {
    t.b('            <span class="dh-code-line-ctn"><br></span>');
    t.b("\n" + i);
  }
  ;
  t.b("        </div>");
  t.b("\n" + i);
  t.b("    </td>");
  t.b("\n" + i);
  t.b("</tr>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["generic-wrapper"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<div class="dh-wrapper">');
  t.b("\n" + i);
  t.b("    ");
  t.b(t.t(t.f("content", c, p, )));
  t.b("\n" + i);
  t.b("</div>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-added"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<svg aria-hidden="true" class="dh-icon dh-added" height="" title="added" version="." viewBox="   "');
  t.b("\n" + i);
  t.b('     width="">');
  t.b("\n" + i);
  t.b('    <path d="M HC.   .  vc . .   hc.  -. -Vc-.-.---z m HVhvzM HVhVhvhvHvHVz"></path>');
  t.b("\n" + i);
  t.b("</svg>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-changed"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<svg aria-hidden="true" class="dh-icon dh-changed" height="" title="modified" version="."');
  t.b("\n" + i);
  t.b('     viewBox="   " width="">');
  t.b("\n" + i);
  t.b('    <path d="M HC.   .  vc . .   hc.  -. -Vc-.-.---z m HVhvzM c-. .- -s .  -. - --.--z"></path>');
  t.b("\n" + i);
  t.b("</svg>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-deleted"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<svg aria-hidden="true" class="dh-icon dh-deleted" height="" title="removed" version="."');
  t.b("\n" + i);
  t.b('     viewBox="   " width="">');
  t.b("\n" + i);
  t.b('    <path d="M HC.   .  vc . .   hc.  -. -Vc-.-.---z m HVhvzM HVhvz"></path>');
  t.b("\n" + i);
  t.b("</svg>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file-renamed"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<svg aria-hidden="true" class="dh-icon dh-moved" height="" title="renamed" version="."');
  t.b("\n" + i);
  t.b('     viewBox="   " width="">');
  t.b("\n" + i);
  t.b('    <path d="M HVhVl - Vz m-vc .-. - Hc-. --.--Vc-. .- -hc.   .  z m- HvhVz"></path>');
  t.b("\n" + i);
  t.b("</svg>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["icon-file"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<svg aria-hidden="true" class="dh-icon" height="" version="." viewBox="   " width="">');
  t.b("\n" + i);
  t.b('    <path d="M Hv-hvzM hv-Hvz m hv-Hvz m hv-Hvz m-.v.c .-. - Hc-. --.--Vc-. .- -h.l. .z m- .L HvhVz"></path>');
  t.b("\n" + i);
  t.b("</svg>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["line-by-line-file-diff"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<div id="');
  t.b(t.v(t.f("fileHtmlId", c, p, )));
  t.b('" class="dh-file-wrapper" data-lang="');
  t.b(t.v(t.d("file.language", c, p, )));
  t.b('">');
  t.b("\n" + i);
  t.b('    <div class="dh-file-header">');
  t.b("\n" + i);
  t.b("    ");
  t.b(t.t(t.f("filePath", c, p, )));
  t.b("\n" + i);
  t.b("    </div>");
  t.b("\n" + i);
  t.b('    <div class="dh-file-diff">');
  t.b("\n" + i);
  t.b('        <div class="dh-code-wrapper">');
  t.b("\n" + i);
  t.b('            <table class="dh-diff-table">');
  t.b("\n" + i);
  t.b('                <tbody class="dh-diff-tbody">');
  t.b("\n" + i);
  t.b("                ");
  t.b(t.t(t.f("diffs", c, p, )));
  t.b("\n" + i);
  t.b("                </tbody>");
  t.b("\n" + i);
  t.b("            </table>");
  t.b("\n" + i);
  t.b("        </div>");
  t.b("\n" + i);
  t.b("    </div>");
  t.b("\n" + i);
  t.b("</div>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["line-by-line-numbers"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<div class="line-num">');
  t.b(t.v(t.f("oldNumber", c, p, )));
  t.b("</div>");
  t.b("\n" + i);
  t.b('<div class="line-num">');
  t.b(t.v(t.f("newNumber", c, p, )));
  t.b("</div>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["side-by-side-file-diff"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<div id="');
  t.b(t.v(t.f("fileHtmlId", c, p, )));
  t.b('" class="dh-file-wrapper" data-lang="');
  t.b(t.v(t.d("file.language", c, p, )));
  t.b('">');
  t.b("\n" + i);
  t.b('    <div class="dh-file-header">');
  t.b("\n" + i);
  t.b("      ");
  t.b(t.t(t.f("filePath", c, p, )));
  t.b("\n" + i);
  t.b("    </div>");
  t.b("\n" + i);
  t.b('    <div class="dh-files-diff">');
  t.b("\n" + i);
  t.b('        <div class="dh-file-side-diff">');
  t.b("\n" + i);
  t.b('            <div class="dh-code-wrapper">');
  t.b("\n" + i);
  t.b('                <table class="dh-diff-table">');
  t.b("\n" + i);
  t.b('                    <tbody class="dh-diff-tbody">');
  t.b("\n" + i);
  t.b("                    ");
  t.b(t.t(t.d("diffs.left", c, p, )));
  t.b("\n" + i);
  t.b("                    </tbody>");
  t.b("\n" + i);
  t.b("                </table>");
  t.b("\n" + i);
  t.b("            </div>");
  t.b("\n" + i);
  t.b("        </div>");
  t.b("\n" + i);
  t.b('        <div class="dh-file-side-diff">');
  t.b("\n" + i);
  t.b('            <div class="dh-code-wrapper">');
  t.b("\n" + i);
  t.b('                <table class="dh-diff-table">');
  t.b("\n" + i);
  t.b('                    <tbody class="dh-diff-tbody">');
  t.b("\n" + i);
  t.b("                    ");
  t.b(t.t(t.d("diffs.right", c, p, )));
  t.b("\n" + i);
  t.b("                    </tbody>");
  t.b("\n" + i);
  t.b("                </table>");
  t.b("\n" + i);
  t.b("            </div>");
  t.b("\n" + i);
  t.b("        </div>");
  t.b("\n" + i);
  t.b("    </div>");
  t.b("\n" + i);
  t.b("</div>");
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-added"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<span class="dh-tag dh-added dh-added-tag">ADDED</span>');
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-changed"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<span class="dh-tag dh-changed dh-changed-tag">CHANGED</span>');
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-deleted"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<span class="dh-tag dh-deleted dh-deleted-tag">DELETED</span>');
  return t.fl();
}, partials: {}, subs: {} });
defaultTemplates["tag-file-renamed"] = new Hogan.Template({ code: function(c, p, i) {
  var t = this;
  t.b(i = i || "");
  t.b('<span class="dh-tag dh-moved dh-moved-tag">RENAMED</span>');
  return t.fl();
}, partials: {}, subs: {} });

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/hoganjs-utils.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = , n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var HoganJsUtils = function() {
  function HoganJsUtils(_a) {
    var _b = _a.compiledTemplates, compiledTemplates = _b === void  ? {} : _b, _c = _a.rawTemplates, rawTemplates = _c === void  ? {} : _c;
    var compiledRawTemplates = Object.entries(rawTemplates).reduce(function(previousTemplates, _a) {
      var _b;
      var name = _a[], templateString = _a[];
      var compiledTemplate = Hogan.compile(templateString, { asString: false });
      return __assign(__assign({}, previousTemplates), (_b = {}, _b[name] = compiledTemplate, _b));
    }, {});
    this.preCompiledTemplates = __assign(__assign(__assign({}, defaultTemplates), compiledTemplates), compiledRawTemplates);
  }
  HoganJsUtils.compile = function(templateString) {
    return Hogan.compile(templateString, { asString: false });
  };
  HoganJsUtils.prototype.render = function(namespace, view, params, partials, indent) {
    var templateKey = this.templateKey(namespace, view);
    try {
      var template = this.preCompiledTemplates[templateKey];
      return template.render(params, partials, indent);
    } catch (e) {
      throw new Error("Could not find template to render '".concat(templateKey, "'"));
    }
  };
  HoganJsUtils.prototype.template = function(namespace, view) {
    return this.preCompiledTemplates[this.templateKey(namespace, view)];
  };
  HoganJsUtils.prototype.templateKey = function(namespace, view) {
    return "".concat(namespace, "-").concat(view);
  };
  return HoganJsUtils;
}();
var hoganjs_utils_default = HoganJsUtils;

// node_modules/.pnpm/diffhtml@../node_modules/diffhtml/lib-esm/diffhtml.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = , n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var defaultDiffHtmlConfig = __assign(__assign(__assign({}, defaultLineByLineRendererConfig), defaultSideBySideRendererConfig), { outputFormat: OutputFormatType.LINE_BY_LINE, drawFileList: true });
function html(diffInput, configuration) {
  if (configuration === void ) {
    configuration = {};
  }
  var config = __assign(__assign({}, defaultDiffHtmlConfig), configuration);
  var diffJson = typeof diffInput === "string" ? parse(diffInput, config) : diffInput;
  var hoganUtils = new hoganjs_utils_default(config);
  var fileList = config.drawFileList ? render(diffJson, hoganUtils) : "";
  var diffOutput = config.outputFormat === "side-by-side" ? new side_by_side_renderer_default(hoganUtils, config).render(diffJson) : new line_by_line_renderer_default(hoganUtils, config).render(diffJson);
  return fileList + diffOutput;
}

// src/ui/diff/diffView.ts
var import_obsidian = require("obsidian");
var DiffView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.gettingDiff = false;
    this.parser = new DOMParser();
    this.navigation = true;
    addEventListener("git-refresh", this.refresh.bind(this));
  }
  getViewType() {
    return DIFF_VIEW_CONFIG.type;
  }
  getDisplayText() {
    var _a;
    if (((_a = this.state) == null ? void  : _a.file) != null) {
      let fileName = this.state.file.split("/").last();
      if (fileName == null ? void  : fileName.endsWith(".md"))
        fileName = fileName.slice(, -);
      return DIFF_VIEW_CONFIG.name + ` (${fileName})`;
    }
    return DIFF_VIEW_CONFIG.name;
  }
  getIcon() {
    return DIFF_VIEW_CONFIG.icon;
  }
  async setState(state, result) {
    this.state = state;
    await this.refresh();
    return;
  }
  getState() {
    return this.state;
  }
  onClose() {
    removeEventListener("git-refresh", this.refresh.bind(this));
    return super.onClose();
  }
  onOpen() {
    this.refresh();
    return super.onOpen();
  }
  async refresh() {
    var _a;
    if (((_a = this.state) == null ? void  : _a.file) && !this.gettingDiff && this.plugin.gitManager) {
      this.gettingDiff = true;
      try {
        let diff = await this.plugin.gitManager.getDiffString(
          this.state.file,
          this.state.staged,
          this.state.hash
        );
        this.contentEl.empty();
        if (!diff) {
          const content = await this.app.vault.adapter.read(
            this.plugin.gitManager.getVaultPath(this.state.file)
          );
          const header = `--- /dev/null
+++ ${this.state.file}
@@ -, +,${content.split("\n").length} @@`;
          diff = [
            ...header.split("\n"),
            ...content.split("\n").map((line) => `+${line}`)
          ].join("\n");
        }
        const diffEl = this.parser.parseFromString(html(diff), "text/html").querySelector(".dh-file-diff");
        this.contentEl.append(diffEl);
      } finally {
        this.gettingDiff = false;
      }
    }
  }
};

// src/ui/history/historyView.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");

// src/ui/history/historyView.svelte
init_polyfill_buffer();

// node_modules/.pnpm/svelte@../node_modules/svelte/internal/index.mjs
init_polyfill_buffer();
function noop() {
}
var identity = (x) => x;
function run(fn) {
  return fn();
}
function blank_object() {
  return / @__PURE__ / Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === ;
}
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
var tasks = / @__PURE__ / new Set();
function run_tasks(now) {
  tasks.forEach((task) => {
    if (!task.c(now)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== )
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === )
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = ; i < iterations.length; i += ) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element) {
  return Array.from(element.childNodes);
}
function set_data(text, data) {
  data = "" + data;
  if (text.wholeText !== data)
    text.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value === null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element, name, toggle) {
  element.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var managed_styles = / @__PURE__ / new Map();
var active = ;
function hash(str) {
  let hash = ;
  let i = str.length;
  while (i--)
    hash = (hash << ) - hash ^ str.charCodeAt(i);
  return hash >>> ;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = ) {
  const step = . / duration;
  let keyframes = "{\n";
  for (let p = ; p <= ; p += step) {
    const t = a + (b - a)  ease(p);
    keyframes += p   + `%{${fn(t,  - t)}}
`;
  }
  const rule = keyframes + `% {${fn(b,  - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms  both`;
  active += ;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) <  : (anim) => anim.indexOf("__svelte") === -
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = / @__PURE__ / Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = / @__PURE__ / new Set();
var flushidx = ;
function flush() {
  if (flushidx !== ) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = ;
      flushidx = ;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = ;
    flushidx = ;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = ; i < render_callbacks.length; i += ) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = ;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === - ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = / @__PURE__ / new Set();
var outros;
function group_outros() {
  outros = {
    r: ,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach)
          block.d();
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration:  };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t = intro ?  : ;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init(program, duration) {
    const d = program.b - t;
    duration = Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const { delay: delay = , duration = , easing = identity, tick: tick = noop, css } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += ;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick(, );
      running_program = init(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now) => {
        if (pending_program && now > pending_program.start) {
          running_program = init(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, , easing, config.css);
          }
        }
        if (running_program) {
          if (now >= running_program.end) {
            tick(t = running_program.b,  - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now >= running_program.start) {
            const p = now - running_program.start;
            t = running_program.a + running_program.d  easing(p / running_program.duration);
            tick(t,  - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          config = config(options);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = / @__PURE__ / new Set([..._boolean_attributes]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[] === -) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill();
  }
  component.$$.dirty[i /  | ] |=  << i % ;
}
function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr, _oldValue, newValue) {
      this[attr] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, );
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -)
          callbacks.splice(index, );
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, );
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -)
        callbacks.splice(index, );
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/.pnpm/tslib@../node_modules/tslib/tslib.es.js
init_polyfill_buffer();
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

// src/ui/history/historyView.svelte
var import_obsidian = require("obsidian");

// node_modules/.pnpm/svelte@../node_modules/svelte/index.mjs
init_polyfill_buffer();

// src/ui/history/components/logComponent.svelte
init_polyfill_buffer();

// node_modules/.pnpm/svelte@../node_modules/svelte/transition/index.mjs
init_polyfill_buffer();

// node_modules/.pnpm/svelte@../node_modules/svelte/easing/index.mjs
init_polyfill_buffer();
function cubicOut(t) {
  const f = t - ;
  return f  f  f + ;
}

// node_modules/.pnpm/svelte@../node_modules/svelte/transition/index.mjs
function slide(node, { delay: delay = , duration = , easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map((e) => `${e[].toUpperCase()}${e.slice()}`);
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[]}`]);
  const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[]}Width`]);
  const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[]}Width`]);
  return {
    delay: delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t  , )  opacity};${primary_property}: ${t  primary_property_value}px;padding-${secondary_properties[]}: ${t  padding_start_value}px;padding-${secondary_properties[]}: ${t  padding_end_value}px;margin-${secondary_properties[]}: ${t  margin_start_value}px;margin-${secondary_properties[]}: ${t  margin_end_value}px;border-${secondary_properties[]}-width: ${t  border_width_start_value}px;border-${secondary_properties[]}-width: ${t  border_width_end_value}px;`
  };
}

// src/ui/history/components/logFileComponent.svelte
init_polyfill_buffer();
var import_obsidian = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-pmbon", "main.svelte-pmbon .nav-file-title-content.svelte-pmbon{display:flex;align-items:center}");
}
function create_if_block(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "data-icon", "go-to-file");
      attr(div, "aria-label", "Open File");
      attr(div, "class", "clickable-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[](div);
      if (!mounted) {
        dispose = [
          listen(div, "auxclick", stop_propagation(
            /open/
            ctx[]
          )),
          listen(div, "click", stop_propagation(
            /open/
            ctx[]
          ))
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment(ctx) {
  let main;
  let div;
  let div;
  let t_value = getDisplayPath(
    /diff/
    ctx[].vault_path
  ) + "";
  let t;
  let t;
  let div;
  let div;
  let show_if = (
    /view/
    ctx[].app.vault.getAbstractFileByPath(
      /diff/
      ctx[].vault_path
    )
  );
  let t;
  let span;
  let t_value = (
    /diff/
    ctx[].status + ""
  );
  let t;
  let span_data_type_value;
  let div_aria_label_value;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block(ctx);
  return {
    c() {
      main = element("main");
      div = element("div");
      div = element("div");
      t = text(t_value);
      t = space();
      div = element("div");
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      span = element("span");
      t = text(t_value);
      attr(div, "class", "nav-file-title-content svelte-pmbon");
      attr(div, "class", "buttons");
      attr(span, "class", "type");
      attr(span, "data-type", span_data_type_value = /diff/
      ctx[].status);
      attr(div, "class", "git-tools");
      attr(div, "class", "nav-file-title");
      attr(
        div,
        "aria-label-position",
        /side/
        ctx[]
      );
      attr(div, "aria-label", div_aria_label_value = /diff/
      ctx[].vault_path);
      attr(main, "class", "nav-file svelte-pmbon");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div);
      append(div, div);
      append(div, t);
      append(div, t);
      append(div, div);
      append(div, div);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      append(div, span);
      append(span, t);
      if (!mounted) {
        dispose = [
          listen(main, "click", stop_propagation(
            /showDiff/
            ctx[]
          )),
          listen(main, "auxclick", stop_propagation(
            /showDiff/
            ctx[]
          )),
          listen(
            main,
            "focus",
            /focus_handler/
            ctx[]
          )
        ];
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /diff/
       && t_value !== (t_value = getDisplayPath(
        /diff/
        ctx[].vault_path
      ) + ""))
        set_data(t, t_value);
      if (dirty & /view, diff/
      )
        show_if = /view/
        ctx[].app.vault.getAbstractFileByPath(
          /diff/
          ctx[].vault_path
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d();
        if_block = null;
      }
      if (dirty & /diff/
       && t_value !== (t_value = /diff/
      ctx[].status + ""))
        set_data(t, t_value);
      if (dirty & /diff/
       && span_data_type_value !== (span_data_type_value = /diff/
      ctx[].status)) {
        attr(span, "data-type", span_data_type_value);
      }
      if (dirty & /side/
      ) {
        attr(
          div,
          "aria-label-position",
          /side/
          ctx[]
        );
      }
      if (dirty & /diff/
       && div_aria_label_value !== (div_aria_label_value = /diff/
      ctx[].vault_path)) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(main);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let side;
  let { diff: diff } = $$props;
  let { view } = $$props;
  let buttons = [];
  window.setTimeout(() => buttons.forEach((b) => (, import_obsidian.setIcon)(b, b.getAttr("data-icon"))), );
  function open(event) {
    var _a;
    const file = view.app.vault.getAbstractFileByPath(diff.vault_path);
    if (file instanceof import_obsidian.TFile) {
      (_a = getNewLeaf(event)) === null || _a === void  ? void  : _a.openFile(file);
    }
  }
  function showDiff(event) {
    var _a;
    (_a = getNewLeaf(event)) === null || _a === void  ? void  : _a.setViewState({
      type: DIFF_VIEW_CONFIG.type,
      active: true,
      state: {
        file: diff.path,
        staged: false,
        hash: diff.hash
      }
    });
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  $$self.$$set = ($$props) => {
    if ("diff" in $$props)
      $$invalidate(, diff = $$props.diff);
    if ("view" in $$props)
      $$invalidate(, view = $$props.view);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /view/
    ) {
      $:
        $$invalidate(, side = view.leaf.getRoot().side == "left" ? "right" : "left");
    }
  };
  return [diff, view, buttons, side, open, showDiff, focus_handler, div_binding];
}
var LogFileComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { diff: , view:  }, add_css);
  }
};
var logFileComponent_default = LogFileComponent;

// src/ui/history/components/logTreeComponent.svelte
init_polyfill_buffer();
function add_css(target) {
  append_styles(target, "svelte-lnld", "main.svelte-lnld .nav-folder-title-content.svelte-lnld{display:flex;align-items:center}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let div;
  let div;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t_value = (
    /entity/
    ctx[].title + ""
  );
  let t;
  let div_aria_label_value;
  let t;
  let t;
  let current;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /click_handler/
      ctx[](
        /entity/
        ctx[]
      )
    );
  }
  let if_block = !/closed/
  ctx[][
    /entity/
    ctx[].title
  ] && create_if_block_(ctx);
  return {
    c() {
      div = element("div");
      div = element("div");
      div = element("div");
      t = space();
      div = element("div");
      div.innerHTML = `<svg xmlns="http://www.w.org//svg" width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M L L "></path></svg>`;
      t = space();
      div = element("div");
      t = text(t_value);
      t = space();
      if (if_block)
        if_block.c();
      t = space();
      attr(div, "data-icon", "folder");
      set_style(div, "padding-right", "px");
      set_style(div, "display", "flex");
      attr(div, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div, "class", "nav-folder-title-content svelte-lnld");
      attr(div, "class", "nav-folder-title");
      attr(
        div,
        "aria-label-position",
        /side/
        ctx[]
      );
      attr(div, "aria-label", div_aria_label_value = /entity/
      ctx[].vaultPath);
      attr(div, "class", "nav-folder");
      toggle_class(
        div,
        "is-collapsed",
        /closed/
        ctx[][
          /entity/
          ctx[].title
        ]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, div);
      append(div, div);
      append(div, t);
      append(div, div);
      append(div, t);
      append(div, div);
      append(div, t);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /hierarchy/
      ) && t_value !== (t_value = /entity/
      ctx[].title + ""))
        set_data(t, t_value);
      if (!current || dirty & /side/
      ) {
        attr(
          div,
          "aria-label-position",
          /side/
          ctx[]
        );
      }
      if (!current || dirty & /hierarchy/
       && div_aria_label_value !== (div_aria_label_value = /entity/
      ctx[].vaultPath)) {
        attr(div, "aria-label", div_aria_label_value);
      }
      if (!/closed/
      ctx[][
        /entity/
        ctx[].title
      ]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /closed, hierarchy/
          ) {
            transition_in(if_block, );
          }
        } else {
          if_block = create_if_block_(ctx);
          if_block.c();
          transition_in(if_block, );
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, , , () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /closed, hierarchy/
      ) {
        toggle_class(
          div,
          "is-collapsed",
          /closed/
          ctx[][
            /entity/
            ctx[].title
          ]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block(ctx) {
  let div;
  let logfilecomponent;
  let t;
  let current;
  logfilecomponent = new logFileComponent_default({
    props: {
      diff: (
        /entity/
        ctx[].data
      ),
      view: (
        /view/
        ctx[]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(logfilecomponent.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(logfilecomponent, div, null);
      append(div, t);
      current = true;
    },
    p(ctx, dirty) {
      const logfilecomponent_changes = {};
      if (dirty & /hierarchy/
      )
        logfilecomponent_changes.diff = /entity/
        ctx[].data;
      if (dirty & /view/
      )
        logfilecomponent_changes.view = /view/
        ctx[];
      logfilecomponent.$set(logfilecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(logfilecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(logfilecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(logfilecomponent);
    }
  };
}
function create_if_block_(ctx) {
  let div;
  let logtreecomponent;
  let div_transition;
  let current;
  logtreecomponent = new LogTreeComponent({
    props: {
      hierarchy: (
        /entity/
        ctx[]
      ),
      plugin: (
        /plugin/
        ctx[]
      ),
      view: (
        /view/
        ctx[]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(logtreecomponent.$$.fragment);
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(logtreecomponent, div, null);
      current = true;
    },
    p(ctx, dirty) {
      const logtreecomponent_changes = {};
      if (dirty & /hierarchy/
      )
        logtreecomponent_changes.hierarchy = /entity/
        ctx[];
      if (dirty & /plugin/
      )
        logtreecomponent_changes.plugin = /plugin/
        ctx[];
      if (dirty & /view/
      )
        logtreecomponent_changes.view = /view/
        ctx[];
      logtreecomponent.$set(logtreecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(logtreecomponent.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, { duration:  }, true);
          div_transition.run();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(logtreecomponent.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration:  }, false);
        div_transition.run();
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(logtreecomponent);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_each_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if (
      /entity/
      ctx[].data
    )
      return ;
    return ;
  }
  current_block_type_index = select_block_type(ctx, -);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], , , () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, );
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment(ctx) {
  let main;
  let current;
  let each_value = (
    /hierarchy/
    ctx[].children
  );
  let each_blocks = [];
  for (let i = ; i < each_value.length; i += ) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], , , () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      main = element("main");
      for (let i = ; i < each_blocks.length; i += ) {
        each_blocks[i].c();
      }
      attr(main, "class", "svelte-lnld");
      toggle_class(
        main,
        "topLevel",
        /topLevel/
        ctx[]
      );
    },
    m(target, anchor) {
      insert(target, main, anchor);
      for (let i = ; i < each_blocks.length; i += ) {
        if (each_blocks[i]) {
          each_blocks[i].m(main, null);
        }
      }
      current = true;
    },
    p(ctx, [dirty]) {
      if (dirty & /hierarchy, view, closed, plugin, side, fold/
      ) {
        each_value = /hierarchy/
        ctx[].children;
        let i;
        for (i = ; i < each_value.length; i += ) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], );
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], );
            each_blocks[i].m(main, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += ) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /topLevel/
      ) {
        toggle_class(
          main,
          "topLevel",
          /topLevel/
          ctx[]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = ; i < each_value.length; i += ) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = ; i < each_blocks.length; i += ) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let side;
  let { hierarchy } = $$props;
  let { plugin } = $$props;
  let { view } = $$props;
  let { topLevel = false } = $$props;
  const closed = {};
  function fold(item) {
    $$invalidate(, closed[item.title] = !closed[item.title], closed);
  }
  const click_handler = (entity) => fold(entity);
  $$self.$$set = ($$props) => {
    if ("hierarchy" in $$props)
      $$invalidate(, hierarchy = $$props.hierarchy);
    if ("plugin" in $$props)
      $$invalidate(, plugin = $$props.plugin);
    if ("view" in $$props)
      $$invalidate(, view = $$props.view);
    if ("topLevel" in $$props)
      $$invalidate(, topLevel = $$props.topLevel);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /view/
    ) {
      $:
        $$invalidate(, side = view.leaf.getRoot().side == "left" ? "right" : "left");
    }
  };
  return [hierarchy, plugin, view, topLevel, closed, side, fold, click_handler];
}
var LogTreeComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        hierarchy: ,
        plugin: ,
        view: ,
        topLevel: 
      },
      add_css
    );
  }
};
var logTreeComponent_default = LogTreeComponent;

// src/ui/history/components/logComponent.svelte
function add_css(target) {
  append_styles(target, "svelte-tegnt", ".git-ref.svelte-tegnt{color:var(--text-accent)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[] = list[i];
  return child_ctx;
}
function create_if_block_(ctx) {
  let div;
  let t_value = (
    /log/
    ctx[].refs.join(", ") + ""
  );
  let t;
  return {
    c() {
      div = element("div");
      t = text(t_value);
      attr(div, "class", "git-ref svelte-tegnt");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, t);
    },
    p(ctx, dirty) {
      if (dirty & /log/
       && t_value !== (t_value = /log/
      ctx[].refs.join(", ") + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_transition;
  let current;
  const if_block_creators = [create_if_block_, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if (
      /showTree/
      ctx[]
    )
      return ;
    return ;
  }
  current_block_type_index = select_block_type(ctx, -);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], , , () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, );
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, { duration:  }, true);
          div_transition.run();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration:  }, false);
        div_transition.run();
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_else_block(ctx) {
  let each__anchor;
  let current;
  let each_value = (
    /log/
    ctx[].diff.files
  );
  let each_blocks = [];
  for (let i = ; i < each_value.length; i += ) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], , , () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = ; i < each_blocks.length; i += ) {
        each_blocks[i].c();
      }
      each__anchor = empty();
    },
    m(target, anchor) {
      for (let i = ; i < each_blocks.length; i += ) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each__anchor, anchor);
      current = true;
    },
    p(ctx, dirty) {
      if (dirty & /view, log/
      ) {
        each_value = /log/
        ctx[].diff.files;
        let i;
        for (i = ; i < each_value.length; i += ) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], );
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], );
            each_blocks[i].m(each__anchor.parentNode, each__anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += ) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = ; i < each_value.length; i += ) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = ; i < each_blocks.length; i += ) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each__anchor);
    }
  };
}
function create_if_block_(ctx) {
  let logtreecomponent;
  let current;
  logtreecomponent = new logTreeComponent_default({
    props: {
      hierarchy: (
        /logsHierarchy/
        ctx[]
      ),
      plugin: (
        /plugin/
        ctx[]
      ),
      view: (
        /view/
        ctx[]
      ),
      topLevel: true
    }
  });
  return {
    c() {
      create_component(logtreecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(logtreecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const logtreecomponent_changes = {};
      if (dirty & /logsHierarchy/
      )
        logtreecomponent_changes.hierarchy = /logsHierarchy/
        ctx[];
      if (dirty & /plugin/
      )
        logtreecomponent_changes.plugin = /plugin/
        ctx[];
      if (dirty & /view/
      )
        logtreecomponent_changes.view = /view/
        ctx[];
      logtreecomponent.$set(logtreecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(logtreecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(logtreecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(logtreecomponent, detaching);
    }
  };
}
function create_each_block(ctx) {
  let logfilecomponent;
  let current;
  logfilecomponent = new logFileComponent_default({
    props: {
      view: (
        /view/
        ctx[]
      ),
      diff: (
        /file/
        ctx[]
      )
    }
  });
  return {
    c() {
      create_component(logfilecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(logfilecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const logfilecomponent_changes = {};
      if (dirty & /view/
      )
        logfilecomponent_changes.view = /view/
        ctx[];
      if (dirty & /log/
      )
        logfilecomponent_changes.diff = /file/
        ctx[];
      logfilecomponent.$set(logfilecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(logfilecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(logfilecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(logfilecomponent, detaching);
    }
  };
}
function create_fragment(ctx) {
  let main;
  let div;
  let div;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t_value = (
    /log/
    ctx[].message + ""
  );
  let t;
  let div_aria_label_value;
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /log/
    ctx[].refs.length >  && create_if_block_(ctx)
  );
  let if_block = !/isCollapsed/
  ctx[] && create_if_block(ctx);
  return {
    c() {
      main = element("main");
      div = element("div");
      div = element("div");
      div = element("div");
      div.innerHTML = `<svg xmlns="http://www.w.org//svg" width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M L L "></path></svg>`;
      t = space();
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      t = text(t_value);
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div, "class", "nav-folder-title-content");
      attr(div, "aria-label", div_aria_label_value = /log/
      ctx[].message);
      attr(
        div,
        "aria-label-position",
        /side/
        ctx[]
      );
      attr(div, "class", "nav-folder-title");
      attr(div, "class", "staged nav-folder");
      toggle_class(
        div,
        "is-collapsed",
        /isCollapsed/
        ctx[]
      );
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div);
      append(div, div);
      append(div, div);
      append(div, t);
      append(div, div);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      append(div, div);
      append(div, t);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /click_handler/
          ctx[]
        );
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (
        /log/
        ctx[].refs.length > 
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_(ctx);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d();
        if_block = null;
      }
      if ((!current || dirty & /log/
      ) && t_value !== (t_value = /log/
      ctx[].message + ""))
        set_data(t, t_value);
      if (!current || dirty & /log/
       && div_aria_label_value !== (div_aria_label_value = /log/
      ctx[].message)) {
        attr(div, "aria-label", div_aria_label_value);
      }
      if (!current || dirty & /side/
      ) {
        attr(
          div,
          "aria-label-position",
          /side/
          ctx[]
        );
      }
      if (!/isCollapsed/
      ctx[]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /isCollapsed/
          ) {
            transition_in(if_block, );
          }
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          transition_in(if_block, );
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, , , () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /isCollapsed/
      ) {
        toggle_class(
          div,
          "is-collapsed",
          /isCollapsed/
          ctx[]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      if (if_block)
        if_block.d();
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let logsHierarchy;
  let side;
  let { log: log } = $$props;
  let { view } = $$props;
  let { showTree } = $$props;
  let { plugin } = $$props;
  let isCollapsed = true;
  const click_handler = () => $$invalidate(, isCollapsed = !isCollapsed);
  $$self.$$set = ($$props) => {
    if ("log" in $$props)
      $$invalidate(, log = $$props.log);
    if ("view" in $$props)
      $$invalidate(, view = $$props.view);
    if ("showTree" in $$props)
      $$invalidate(, showTree = $$props.showTree);
    if ("plugin" in $$props)
      $$invalidate(, plugin = $$props.plugin);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /plugin, log/
    ) {
      $:
        $$invalidate(, logsHierarchy = {
          title: "",
          path: "",
          vaultPath: "",
          children: plugin.gitManager.getTreeStructure(log.diff.files)
        });
    }
    if ($$self.$$.dirty & /view/
    ) {
      $:
        $$invalidate(, side = view.leaf.getRoot().side == "left" ? "right" : "left");
    }
  };
  return [log, view, showTree, plugin, isCollapsed, side, logsHierarchy, click_handler];
}
var LogComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { log: , view: , showTree: , plugin:  }, add_css);
  }
};
var logComponent_default = LogComponent;

// src/ui/history/historyView.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[] = list[i];
  return child_ctx;
}
function create_if_block(ctx) {
  let div;
  let div;
  let current;
  let each_value = (
    /logs/
    ctx[]
  );
  let each_blocks = [];
  for (let i = ; i < each_value.length; i += ) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], , , () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      div = element("div");
      for (let i = ; i < each_blocks.length; i += ) {
        each_blocks[i].c();
      }
      attr(div, "class", "nav-folder-children");
      attr(div, "class", "nav-folder mod-root");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, div);
      for (let i = ; i < each_blocks.length; i += ) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx, dirty) {
      if (dirty & /view, showTree, logs, plugin/
      ) {
        each_value = /logs/
        ctx[];
        let i;
        for (i = ; i < each_value.length; i += ) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], );
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], );
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += ) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = ; i < each_value.length; i += ) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = ; i < each_blocks.length; i += ) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let logcomponent;
  let current;
  logcomponent = new logComponent_default({
    props: {
      view: (
        /view/
        ctx[]
      ),
      showTree: (
        /showTree/
        ctx[]
      ),
      log: (
        /log/
        ctx[]
      ),
      plugin: (
        /plugin/
        ctx[]
      )
    }
  });
  return {
    c() {
      create_component(logcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(logcomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const logcomponent_changes = {};
      if (dirty & /view/
      )
        logcomponent_changes.view = /view/
        ctx[];
      if (dirty & /showTree/
      )
        logcomponent_changes.showTree = /showTree/
        ctx[];
      if (dirty & /logs/
      )
        logcomponent_changes.log = /log/
        ctx[];
      if (dirty & /plugin/
      )
        logcomponent_changes.plugin = /plugin/
        ctx[];
      logcomponent.$set(logcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(logcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(logcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(logcomponent, detaching);
    }
  };
}
function create_fragment(ctx) {
  let main;
  let div;
  let div;
  let div;
  let t;
  let div;
  let t;
  let div;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /logs/
    ctx[] && create_if_block(ctx)
  );
  return {
    c() {
      main = element("main");
      div = element("div");
      div = element("div");
      div = element("div");
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "id", "layoutChange");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "aria-label", "Change Layout");
      attr(div, "id", "refresh");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "data-icon", "refresh-cw");
      attr(div, "aria-label", "Refresh");
      set_style(div, "margin", "px");
      toggle_class(
        div,
        "loading",
        /loading/
        ctx[]
      );
      attr(div, "class", "nav-buttons-container");
      attr(div, "class", "nav-header");
      attr(div, "class", "nav-files-container");
      set_style(div, "position", "relative");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div);
      append(div, div);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(main, t);
      append(main, div);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /click_handler/
            ctx[]
          ),
          listen(div, "click", triggerRefresh)
        ];
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (!current || dirty & /loading/
      ) {
        toggle_class(
          div,
          "loading",
          /loading/
          ctx[]
        );
      }
      if (
        /logs/
        ctx[]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /logs/
          ) {
            transition_in(if_block, );
          }
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          transition_in(if_block, );
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, , , () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      ctx[](null);
      ctx[](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function triggerRefresh() {
  dispatchEvent(new CustomEvent("git-refresh"));
}
function instance($$self, $$props, $$invalidate) {
  let { plugin } = $$props;
  let { view } = $$props;
  let loading;
  let buttons = [];
  let logs;
  let showTree = plugin.settings.treeStructure;
  let layoutBtn;
  addEventListener("git-view-refresh", refresh);
  plugin.app.workspace.onLayoutReady(() => {
    window.setTimeout(
      () => {
        buttons.forEach((btn) => (, import_obsidian.setIcon)(btn, btn.getAttr("data-icon"), ));
        (, import_obsidian.setIcon)(layoutBtn, showTree ? "list" : "folder", );
      },
      
    );
  });
  onDestroy(() => {
    removeEventListener("git-view-refresh", refresh);
  });
  function refresh() {
    return __awaiter(this, void , void , function () {
      $$invalidate(, loading = true);
      const isSimpleGit = plugin.gitManager instanceof SimpleGit;
      $$invalidate(, logs = yield plugin.gitManager.log(void , false, isSimpleGit ?  : ));
      $$invalidate(, loading = false);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      layoutBtn = $$value;
      $$invalidate(, layoutBtn);
    });
  }
  const click_handler = () => {
    $$invalidate(, showTree = !showTree);
    $$invalidate(, plugin.settings.treeStructure = showTree, plugin);
    plugin.saveSettings();
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  $$self.$$set = ($$props) => {
    if ("plugin" in $$props)
      $$invalidate(, plugin = $$props.plugin);
    if ("view" in $$props)
      $$invalidate(, view = $$props.view);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /layoutBtn, showTree/
    ) {
      $: {
        if (layoutBtn) {
          layoutBtn.empty();
          (, import_obsidian.setIcon)(layoutBtn, showTree ? "list" : "folder", );
        }
      }
    }
  };
  return [
    plugin,
    view,
    showTree,
    layoutBtn,
    loading,
    buttons,
    logs,
    div_binding,
    click_handler,
    div_binding
  ];
}
var HistoryView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { plugin: , view:  });
  }
};
var historyView_default = HistoryView;

// src/ui/history/historyView.ts
var HistoryView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.hoverPopover = null;
  }
  getViewType() {
    return HISTORY_VIEW_CONFIG.type;
  }
  getDisplayText() {
    return HISTORY_VIEW_CONFIG.name;
  }
  getIcon() {
    return HISTORY_VIEW_CONFIG.icon;
  }
  onClose() {
    return super.onClose();
  }
  onOpen() {
    this._view = new historyView_default({
      target: this.contentEl,
      props: {
        plugin: this.plugin,
        view: this
      }
    });
    return super.onOpen();
  }
};

// src/ui/modals/branchModal.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
var BranchModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(branches) {
    super(app);
    this.branches = branches;
    this.setPlaceholder("Select branch to checkout");
  }
  getItems() {
    return this.branches;
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    this.resolve(item);
  }
  open() {
    super.open();
    return new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  async onClose() {
    await new Promise((resolve) => setTimeout(resolve, ));
    if (this.resolve)
      this.resolve(void );
  }
};

// src/ui/modals/ignoreModal.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
var IgnoreModal = class extends import_obsidian.Modal {
  constructor(app, content) {
    super(app);
    this.content = content;
    this.resolve = null;
  }
  open() {
    super.open();
    return new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText("Edit .gitignore");
    const div = contentEl.createDiv();
    const text = div.createEl("textarea", {
      text: this.content,
      cls: ["obsidian-git-textarea"],
      attr: { rows: , cols: , wrap: "off" }
    });
    div.createEl("button", {
      cls: ["mod-cta", "obsidian-git-center-button"],
      text: "Save"
    }).addEventListener("click", async () => {
      this.resolve(text.value);
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    this.resolve(void );
    contentEl.empty();
  }
};

// src/ui/sourceControl/sourceControl.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");

// src/ui/sourceControl/sourceControl.svelte
init_polyfill_buffer();
var import_obsidian = require("obsidian");

// src/ui/modals/discardModal.ts
init_polyfill_buffer();
var import_obsidian = require("obsidian");
var DiscardModal = class extends import_obsidian.Modal {
  constructor(app, deletion, filename) {
    super(app);
    this.deletion = deletion;
    this.filename = filename;
    this.resolve = null;
  }
  myOpen() {
    this.open();
    return new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText(`${this.deletion ? "Delete" : "Discard"} this file?`);
    contentEl.createEl("p").setText(
      `Do you really want to ${this.deletion ? "delete" : "discard the changes of"} "${this.filename}"`
    );
    const div = contentEl.createDiv({ cls: "modal-button-container" });
    const discard = div.createEl("button", {
      cls: "mod-warning",
      text: this.deletion ? "Delete" : "Discard"
    });
    discard.addEventListener("click", async () => {
      if (this.resolve)
        this.resolve(true);
      this.close();
    });
    discard.addEventListener("keypress", async () => {
      if (this.resolve)
        this.resolve(true);
      this.close();
    });
    const close = div.createEl("button", {
      text: "Cancel"
    });
    close.addEventListener("click", () => {
      if (this.resolve)
        this.resolve(false);
      return this.close();
    });
    close.addEventListener("keypress", () => {
      if (this.resolve)
        this.resolve(false);
      return this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/ui/sourceControl/components/fileComponent.svelte
init_polyfill_buffer();
var import_obsidian = require("obsidian");

// node_modules/.pnpm/obsidian-community-lib@.._ydzxqoixmcltkebsha/node_modules/obsidian-community-lib/dist/index.js
init_polyfill_buffer();

// node_modules/.pnpm/obsidian-community-lib@.._ydzxqoixmcltkebsha/node_modules/obsidian-community-lib/dist/utils.js
init_polyfill_buffer();
var feather = __toESM(require_feather());
var import_obsidian = require("obsidian");
function hoverPreview(event, view, to) {
  const targetEl = event.target;
  app.workspace.trigger("hover-link", {
    event,
    source: view.getViewType(),
    hoverParent: view,
    targetEl,
    linktext: to
  });
}

// src/ui/sourceControl/components/fileComponent.svelte
function add_css(target) {
  append_styles(target, "svelte-pmbon", "main.svelte-pmbon .nav-file-title-content.svelte-pmbon{display:flex;align-items:center}");
}
function create_if_block(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "data-icon", "go-to-file");
      attr(div, "aria-label", "Open File");
      attr(div, "class", "clickable-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[](div);
      if (!mounted) {
        dispose = [
          listen(div, "auxclick", stop_propagation(
            /open/
            ctx[]
          )),
          listen(div, "click", stop_propagation(
            /open/
            ctx[]
          ))
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment(ctx) {
  let main;
  let div;
  let div;
  let t_value = getDisplayPath(
    /change/
    ctx[].vault_path
  ) + "";
  let t;
  let t;
  let div;
  let div;
  let show_if = (
    /view/
    ctx[].app.vault.getAbstractFileByPath(
      /change/
      ctx[].vault_path
    )
  );
  let t;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t_value = (
    /change/
    ctx[].working_dir + ""
  );
  let t;
  let div_data_type_value;
  let div_aria_label_value;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block(ctx);
  return {
    c() {
      main = element("main");
      div = element("div");
      div = element("div");
      t = text(t_value);
      t = space();
      div = element("div");
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      t = text(t_value);
      attr(div, "class", "nav-file-title-content svelte-pmbon");
      attr(div, "data-icon", "undo");
      attr(div, "aria-label", "Discard");
      attr(div, "class", "clickable-icon");
      attr(div, "data-icon", "plus");
      attr(div, "aria-label", "Stage");
      attr(div, "class", "clickable-icon");
      attr(div, "class", "buttons");
      attr(div, "class", "type");
      attr(div, "data-type", div_data_type_value = /change/
      ctx[].working_dir);
      attr(div, "class", "git-tools");
      attr(div, "class", "nav-file-title");
      attr(
        div,
        "aria-label-position",
        /side/
        ctx[]
      );
      attr(div, "aria-label", div_aria_label_value = /change/
      ctx[].vault_path);
      attr(main, "class", "nav-file svelte-pmbon");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div);
      append(div, div);
      append(div, t);
      append(div, t);
      append(div, div);
      append(div, div);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      append(div, t);
      if (!mounted) {
        dispose = [
          listen(div, "click", stop_propagation(
            /discard/
            ctx[]
          )),
          listen(div, "click", stop_propagation(
            /stage/
            ctx[]
          )),
          listen(
            main,
            "mouseover",
            /hover/
            ctx[]
          ),
          listen(main, "click", stop_propagation(
            /showDiff/
            ctx[]
          )),
          listen(main, "auxclick", stop_propagation(
            /showDiff/
            ctx[]
          )),
          listen(
            main,
            "focus",
            /focus_handler/
            ctx[]
          )
        ];
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /change/
       && t_value !== (t_value = getDisplayPath(
        /change/
        ctx[].vault_path
      ) + ""))
        set_data(t, t_value);
      if (dirty & /view, change/
      )
        show_if = /view/
        ctx[].app.vault.getAbstractFileByPath(
          /change/
          ctx[].vault_path
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d();
        if_block = null;
      }
      if (dirty & /change/
       && t_value !== (t_value = /change/
      ctx[].working_dir + ""))
        set_data(t, t_value);
      if (dirty & /change/
       && div_data_type_value !== (div_data_type_value = /change/
      ctx[].working_dir)) {
        attr(div, "data-type", div_data_type_value);
      }
      if (dirty & /side/
      ) {
        attr(
          div,
          "aria-label-position",
          /side/
          ctx[]
        );
      }
      if (dirty & /change/
       && div_aria_label_value !== (div_aria_label_value = /change/
      ctx[].vault_path)) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(main);
      if (if_block)
        if_block.d();
      ctx[](null);
      ctx[](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let side;
  let { change } = $$props;
  let { view } = $$props;
  let { manager } = $$props;
  let buttons = [];
  window.setTimeout(() => buttons.forEach((b) => (, import_obsidian.setIcon)(b, b.getAttr("data-icon"))), );
  function hover(event) {
    if (app.vault.getAbstractFileByPath(change.vault_path)) {
      hoverPreview(event, view, change.vault_path);
    }
  }
  function open(event) {
    var _a;
    const file = view.app.vault.getAbstractFileByPath(change.vault_path);
    console.log(event);
    if (file instanceof import_obsidian.TFile) {
      (_a = getNewLeaf(event)) === null || _a === void  ? void  : _a.openFile(file);
    }
  }
  function stage() {
    manager.stage(change.path, false).finally(() => {
      dispatchEvent(new CustomEvent("git-refresh"));
    });
  }
  function showDiff(event) {
    var _a;
    (_a = getNewLeaf(event)) === null || _a === void  ? void  : _a.setViewState({
      type: DIFF_VIEW_CONFIG.type,
      active: true,
      state: { file: change.path, staged: false }
    });
  }
  function discard() {
    const deleteFile = change.working_dir == "U";
    new DiscardModal(view.app, deleteFile, change.vault_path).myOpen().then((shouldDiscard) => {
      if (shouldDiscard === true) {
        if (deleteFile) {
          view.app.vault.adapter.remove(change.vault_path).finally(() => {
            dispatchEvent(new CustomEvent("git-refresh"));
          });
        } else {
          manager.discard(change.path).finally(() => {
            dispatchEvent(new CustomEvent("git-refresh"));
          });
        }
      }
    });
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  $$self.$$set = ($$props) => {
    if ("change" in $$props)
      $$invalidate(, change = $$props.change);
    if ("view" in $$props)
      $$invalidate(, view = $$props.view);
    if ("manager" in $$props)
      $$invalidate(, manager = $$props.manager);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /view/
    ) {
      $:
        $$invalidate(, side = view.leaf.getRoot().side == "left" ? "right" : "left");
    }
  };
  return [
    change,
    view,
    buttons,
    side,
    hover,
    open,
    stage,
    showDiff,
    discard,
    manager,
    focus_handler,
    div_binding,
    div_binding,
    div_binding
  ];
}
var FileComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { change: , view: , manager:  }, add_css);
  }
};
var fileComponent_default = FileComponent;

// src/ui/sourceControl/components/pulledFileComponent.svelte
init_polyfill_buffer();
var import_obsidian = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-pmbon", "main.svelte-pmbon .nav-file-title-content.svelte-pmbon{display:flex;align-items:center}");
}
function create_fragment(ctx) {
  let main;
  let div;
  let div;
  let t_value = getDisplayPath(
    /change/
    ctx[].vault_path
  ) + "";
  let t;
  let t;
  let div;
  let span;
  let t_value = (
    /change/
    ctx[].working_dir + ""
  );
  let t;
  let span_data_type_value;
  let div_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      main = element("main");
      div = element("div");
      div = element("div");
      t = text(t_value);
      t = space();
      div = element("div");
      span = element("span");
      t = text(t_value);
      attr(div, "class", "nav-file-title-content svelte-pmbon");
      attr(span, "class", "type");
      attr(span, "data-type", span_data_type_value = /change/
      ctx[].working_dir);
      attr(div, "class", "git-tools");
      attr(div, "class", "nav-file-title");
      attr(
        div,
        "aria-label-position",
        /side/
        ctx[]
      );
      attr(div, "aria-label", div_aria_label_value = /change/
      ctx[].vault_path);
      attr(main, "class", "nav-file svelte-pmbon");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div);
      append(div, div);
      append(div, t);
      append(div, t);
      append(div, div);
      append(div, span);
      append(span, t);
      if (!mounted) {
        dispose = [
          listen(
            main,
            "mouseover",
            /hover/
            ctx[]
          ),
          listen(main, "click", stop_propagation(
            /open/
            ctx[]
          )),
          listen(main, "auxclick", stop_propagation(
            /open/
            ctx[]
          )),
          listen(
            main,
            "focus",
            /focus_handler/
            ctx[]
          )
        ];
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /change/
       && t_value !== (t_value = getDisplayPath(
        /change/
        ctx[].vault_path
      ) + ""))
        set_data(t, t_value);
      if (dirty & /change/
       && t_value !== (t_value = /change/
      ctx[].working_dir + ""))
        set_data(t, t_value);
      if (dirty & /change/
       && span_data_type_value !== (span_data_type_value = /change/
      ctx[].working_dir)) {
        attr(span, "data-type", span_data_type_value);
      }
      if (dirty & /side/
      ) {
        attr(
          div,
          "aria-label-position",
          /side/
          ctx[]
        );
      }
      if (dirty & /change/
       && div_aria_label_value !== (div_aria_label_value = /change/
      ctx[].vault_path)) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(main);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let side;
  let { change } = $$props;
  let { view } = $$props;
  function hover(event) {
    if (app.vault.getAbstractFileByPath(change.vault_path)) {
      hoverPreview(event, view, change.vault_path);
    }
  }
  function open(event) {
    var _a;
    const file = view.app.vault.getAbstractFileByPath(change.vault_path);
    if (file instanceof import_obsidian.TFile) {
      (_a = getNewLeaf(event)) === null || _a === void  ? void  : _a.openFile(file);
    }
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props) => {
    if ("change" in $$props)
      $$invalidate(, change = $$props.change);
    if ("view" in $$props)
      $$invalidate(, view = $$props.view);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /view/
    ) {
      $:
        $$invalidate(, side = view.leaf.getRoot().side == "left" ? "right" : "left");
    }
  };
  return [change, side, hover, open, view, focus_handler];
}
var PulledFileComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { change: , view:  }, add_css);
  }
};
var pulledFileComponent_default = PulledFileComponent;

// src/ui/sourceControl/components/stagedFileComponent.svelte
init_polyfill_buffer();
var import_obsidian = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-pmbon", "main.svelte-pmbon .nav-file-title-content.svelte-pmbon{display:flex;align-items:center}");
}
function create_if_block(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "data-icon", "go-to-file");
      attr(div, "aria-label", "Open File");
      attr(div, "class", "clickable-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[](div);
      if (!mounted) {
        dispose = listen(div, "click", stop_propagation(
          /open/
          ctx[]
        ));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let main;
  let div;
  let div;
  let t_value = getDisplayPath(
    /change/
    ctx[].vault_path
  ) + "";
  let t;
  let t;
  let div;
  let div;
  let show_if = (
    /view/
    ctx[].app.vault.getAbstractFileByPath(
      /change/
      ctx[].vault_path
    )
  );
  let t;
  let div;
  let t;
  let div;
  let t_value = (
    /change/
    ctx[].index + ""
  );
  let t;
  let div_data_type_value;
  let div_aria_label_value;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block(ctx);
  return {
    c() {
      main = element("main");
      div = element("div");
      div = element("div");
      t = text(t_value);
      t = space();
      div = element("div");
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      t = text(t_value);
      attr(div, "class", "nav-file-title-content svelte-pmbon");
      attr(div, "data-icon", "minus");
      attr(div, "aria-label", "Unstage");
      attr(div, "class", "clickable-icon");
      attr(div, "class", "buttons");
      attr(div, "class", "type");
      attr(div, "data-type", div_data_type_value = /change/
      ctx[].index);
      attr(div, "class", "git-tools");
      attr(div, "class", "nav-file-title");
      attr(
        div,
        "aria-label-position",
        /side/
        ctx[]
      );
      attr(div, "aria-label", div_aria_label_value = /change/
      ctx[].vault_path);
      attr(main, "class", "nav-file svelte-pmbon");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div);
      append(div, div);
      append(div, t);
      append(div, t);
      append(div, div);
      append(div, div);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      append(div, t);
      if (!mounted) {
        dispose = [
          listen(div, "click", stop_propagation(
            /unstage/
            ctx[]
          )),
          listen(
            main,
            "mouseover",
            /hover/
            ctx[]
          ),
          listen(
            main,
            "focus",
            /focus_handler/
            ctx[]
          ),
          listen(main, "click", stop_propagation(
            /showDiff/
            ctx[]
          )),
          listen(main, "auxclick", stop_propagation(
            /showDiff/
            ctx[]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx, [dirty]) {
      if (dirty & /change/
       && t_value !== (t_value = getDisplayPath(
        /change/
        ctx[].vault_path
      ) + ""))
        set_data(t, t_value);
      if (dirty & /view, change/
      )
        show_if = /view/
        ctx[].app.vault.getAbstractFileByPath(
          /change/
          ctx[].vault_path
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d();
        if_block = null;
      }
      if (dirty & /change/
       && t_value !== (t_value = /change/
      ctx[].index + ""))
        set_data(t, t_value);
      if (dirty & /change/
       && div_data_type_value !== (div_data_type_value = /change/
      ctx[].index)) {
        attr(div, "data-type", div_data_type_value);
      }
      if (dirty & /side/
      ) {
        attr(
          div,
          "aria-label-position",
          /side/
          ctx[]
        );
      }
      if (dirty & /change/
       && div_aria_label_value !== (div_aria_label_value = /change/
      ctx[].vault_path)) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(main);
      if (if_block)
        if_block.d();
      ctx[](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let formattedPath;
  let side;
  let { change } = $$props;
  let { view } = $$props;
  let { manager } = $$props;
  let buttons = [];
  window.setTimeout(() => buttons.forEach((b) => (, import_obsidian.setIcon)(b, b.getAttr("data-icon"), )), );
  function hover(event) {
    if (app.vault.getAbstractFileByPath(change.vault_path)) {
      hoverPreview(event, view, change.vault_path);
    }
  }
  function open(event) {
    var _a;
    const file = view.app.vault.getAbstractFileByPath(change.vault_path);
    if (file instanceof import_obsidian.TFile) {
      (_a = getNewLeaf(event)) === null || _a === void  ? void  : _a.openFile(file);
    }
  }
  function showDiff(event) {
    var _a;
    (_a = getNewLeaf(event)) === null || _a === void  ? void  : _a.setViewState({
      type: DIFF_VIEW_CONFIG.type,
      active: true,
      state: { file: change.path, staged: true }
    });
  }
  function unstage() {
    manager.unstage(change.path, false).finally(() => {
      dispatchEvent(new CustomEvent("git-refresh"));
    });
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  $$self.$$set = ($$props) => {
    if ("change" in $$props)
      $$invalidate(, change = $$props.change);
    if ("view" in $$props)
      $$invalidate(, view = $$props.view);
    if ("manager" in $$props)
      $$invalidate(, manager = $$props.manager);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /change/
    ) {
      $:
        formattedPath = change.vault_path;
    }
    if ($$self.$$.dirty & /view/
    ) {
      $:
        $$invalidate(, side = view.leaf.getRoot().side == "left" ? "right" : "left");
    }
  };
  return [
    change,
    view,
    buttons,
    side,
    hover,
    open,
    showDiff,
    unstage,
    manager,
    focus_handler,
    div_binding,
    div_binding
  ];
}
var StagedFileComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { change: , view: , manager:  }, add_css);
  }
};
var stagedFileComponent_default = StagedFileComponent;

// src/ui/sourceControl/components/treeComponent.svelte
init_polyfill_buffer();
function add_css(target) {
  append_styles(target, "svelte-lnld", "main.svelte-lnld .nav-folder-title-content.svelte-lnld{display:flex;align-items:center}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let div;
  let div;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t_value = (
    /entity/
    ctx[].title + ""
  );
  let t;
  let t;
  let div;
  let div;
  let t;
  let div;
  let div_aria_label_value;
  let t;
  let t;
  let current;
  let mounted;
  let dispose;
  function select_block_type_(ctx, dirty) {
    if (
      /fileType/
      ctx[] ==  / staged /
    )
      return create_if_block_;
    return create_else_block_;
  }
  let current_block_type = select_block_type_(ctx, -);
  let if_block = current_block_type(ctx);
  let if_block = !/closed/
  ctx[][
    /entity/
    ctx[].title
  ] && create_if_block_(ctx);
  function click_handler_() {
    return (
      /click_handler_/
      ctx[](
        /entity/
        ctx[]
      )
    );
  }
  return {
    c() {
      div = element("div");
      div = element("div");
      div = element("div");
      t = space();
      div = element("div");
      div.innerHTML = `<svg xmlns="http://www.w.org//svg" width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M L L "></path></svg>`;
      t = space();
      div = element("div");
      t = text(t_value);
      t = space();
      div = element("div");
      div = element("div");
      if_block.c();
      t = space();
      div = element("div");
      t = space();
      if (if_block)
        if_block.c();
      t = space();
      attr(div, "data-icon", "folder");
      set_style(div, "padding-right", "px");
      set_style(div, "display", "flex");
      attr(div, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div, "class", "nav-folder-title-content svelte-lnld");
      set_style(div, "width", "px");
      attr(div, "class", "buttons");
      attr(div, "class", "git-tools");
      attr(div, "class", "nav-folder-title");
      attr(
        div,
        "aria-label-position",
        /side/
        ctx[]
      );
      attr(div, "aria-label", div_aria_label_value = /entity/
      ctx[].vaultPath);
      attr(div, "class", "nav-folder");
      toggle_class(
        div,
        "is-collapsed",
        /closed/
        ctx[][
          /entity/
          ctx[].title
        ]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, div);
      append(div, div);
      append(div, t);
      append(div, div);
      append(div, t);
      append(div, div);
      append(div, t);
      append(div, t);
      append(div, div);
      append(div, div);
      if_block.m(div, null);
      append(div, t);
      append(div, div);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", click_handler_);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /hierarchy/
      ) && t_value !== (t_value = /entity/
      ctx[].title + ""))
        set_data(t, t_value);
      if (current_block_type === (current_block_type = select_block_type_(ctx, dirty)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d();
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(div, t);
        }
      }
      if (!current || dirty & /side/
      ) {
        attr(
          div,
          "aria-label-position",
          /side/
          ctx[]
        );
      }
      if (!current || dirty & /hierarchy/
       && div_aria_label_value !== (div_aria_label_value = /entity/
      ctx[].vaultPath)) {
        attr(div, "aria-label", div_aria_label_value);
      }
      if (!/closed/
      ctx[][
        /entity/
        ctx[].title
      ]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /closed, hierarchy/
          ) {
            transition_in(if_block, );
          }
        } else {
          if_block = create_if_block_(ctx);
          if_block.c();
          transition_in(if_block, );
          if_block.m(div, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, , , () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /closed, hierarchy/
      ) {
        toggle_class(
          div,
          "is-collapsed",
          /closed/
          ctx[][
            /entity/
            ctx[].title
          ]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_block.d();
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let t;
  let current;
  const if_block_creators = [create_if_block_, create_if_block_, create_if_block_];
  const if_blocks = [];
  function select_block_type_(ctx, dirty) {
    if (
      /fileType/
      ctx[] ==  / staged /
    )
      return ;
    if (
      /fileType/
      ctx[] ==  / changed /
    )
      return ;
    if (
      /fileType/
      ctx[] ==  / pulled /
    )
      return ;
    return -;
  }
  if (~(current_block_type_index = select_block_type_(ctx, -))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      div = element("div");
      if (if_block)
        if_block.c();
      t = space();
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append(div, t);
      current = true;
    },
    p(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], , , () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, );
          if_block.m(div, t);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_else_block_(ctx) {
  let div;
  let t;
  let div;
  let mounted;
  let dispose;
  function click_handler_() {
    return (
      /click_handler_/
      ctx[](
        /entity/
        ctx[]
      )
    );
  }
  function click_handler_() {
    return (
      /click_handler_/
      ctx[](
        /entity/
        ctx[]
      )
    );
  }
  return {
    c() {
      div = element("div");
      div.innerHTML = `<svg xmlns="http://www.w.org//svg" width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-undo"><path d="M vh"></path><path d="M a    --     - .L "></path></svg>`;
      t = space();
      div = element("div");
      div.innerHTML = `<svg width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-plus"><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line></svg>`;
      attr(div, "data-icon", "undo");
      attr(div, "aria-label", "Discard");
      attr(div, "class", "clickable-icon");
      attr(div, "data-icon", "plus");
      attr(div, "aria-label", "Stage");
      attr(div, "class", "clickable-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      insert(target, t, anchor);
      insert(target, div, anchor);
      if (!mounted) {
        dispose = [
          listen(div, "click", stop_propagation(click_handler_)),
          listen(div, "click", stop_propagation(click_handler_))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (detaching)
        detach(t);
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_(ctx) {
  let div;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /click_handler/
      ctx[](
        /entity/
        ctx[]
      )
    );
  }
  return {
    c() {
      div = element("div");
      div.innerHTML = `<svg width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-minus"><line x="" y="" x="" y=""></line></svg>`;
      attr(div, "data-icon", "minus");
      attr(div, "aria-label", "Unstage");
      attr(div, "class", "clickable-icon");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = listen(div, "click", stop_propagation(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_(ctx) {
  let div;
  let treecomponent;
  let div_transition;
  let current;
  treecomponent = new TreeComponent({
    props: {
      hierarchy: (
        /entity/
        ctx[]
      ),
      plugin: (
        /plugin/
        ctx[]
      ),
      view: (
        /view/
        ctx[]
      ),
      fileType: (
        /fileType/
        ctx[]
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(treecomponent.$$.fragment);
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(treecomponent, div, null);
      current = true;
    },
    p(ctx, dirty) {
      const treecomponent_changes = {};
      if (dirty & /hierarchy/
      )
        treecomponent_changes.hierarchy = /entity/
        ctx[];
      if (dirty & /plugin/
      )
        treecomponent_changes.plugin = /plugin/
        ctx[];
      if (dirty & /view/
      )
        treecomponent_changes.view = /view/
        ctx[];
      if (dirty & /fileType/
      )
        treecomponent_changes.fileType = /fileType/
        ctx[];
      treecomponent.$set(treecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treecomponent.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, { duration:  }, true);
          div_transition.run();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(treecomponent.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration:  }, false);
        div_transition.run();
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(treecomponent);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block_(ctx) {
  let pulledfilecomponent;
  let current;
  pulledfilecomponent = new pulledFileComponent_default({
    props: {
      change: (
        /entity/
        ctx[].data
      ),
      view: (
        /view/
        ctx[]
      )
    }
  });
  return {
    c() {
      create_component(pulledfilecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pulledfilecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const pulledfilecomponent_changes = {};
      if (dirty & /hierarchy/
      )
        pulledfilecomponent_changes.change = /entity/
        ctx[].data;
      if (dirty & /view/
      )
        pulledfilecomponent_changes.view = /view/
        ctx[];
      pulledfilecomponent.$set(pulledfilecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pulledfilecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pulledfilecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pulledfilecomponent, detaching);
    }
  };
}
function create_if_block_(ctx) {
  let filecomponent;
  let current;
  filecomponent = new fileComponent_default({
    props: {
      change: (
        /entity/
        ctx[].data
      ),
      manager: (
        /plugin/
        ctx[].gitManager
      ),
      view: (
        /view/
        ctx[]
      )
    }
  });
  return {
    c() {
      create_component(filecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const filecomponent_changes = {};
      if (dirty & /hierarchy/
      )
        filecomponent_changes.change = /entity/
        ctx[].data;
      if (dirty & /plugin/
      )
        filecomponent_changes.manager = /plugin/
        ctx[].gitManager;
      if (dirty & /view/
      )
        filecomponent_changes.view = /view/
        ctx[];
      filecomponent.$set(filecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filecomponent, detaching);
    }
  };
}
function create_if_block_(ctx) {
  let stagedfilecomponent;
  let current;
  stagedfilecomponent = new stagedFileComponent_default({
    props: {
      change: (
        /entity/
        ctx[].data
      ),
      manager: (
        /plugin/
        ctx[].gitManager
      ),
      view: (
        /view/
        ctx[]
      )
    }
  });
  return {
    c() {
      create_component(stagedfilecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(stagedfilecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const stagedfilecomponent_changes = {};
      if (dirty & /hierarchy/
      )
        stagedfilecomponent_changes.change = /entity/
        ctx[].data;
      if (dirty & /plugin/
      )
        stagedfilecomponent_changes.manager = /plugin/
        ctx[].gitManager;
      if (dirty & /view/
      )
        stagedfilecomponent_changes.view = /view/
        ctx[];
      stagedfilecomponent.$set(stagedfilecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(stagedfilecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(stagedfilecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(stagedfilecomponent, detaching);
    }
  };
}
function create_each_block(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if (
      /entity/
      ctx[].data
    )
      return ;
    return ;
  }
  current_block_type_index = select_block_type(ctx, -);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], , , () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, );
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment(ctx) {
  let main;
  let current;
  let each_value = (
    /hierarchy/
    ctx[].children
  );
  let each_blocks = [];
  for (let i = ; i < each_value.length; i += ) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], , , () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      main = element("main");
      for (let i = ; i < each_blocks.length; i += ) {
        each_blocks[i].c();
      }
      attr(main, "class", "svelte-lnld");
      toggle_class(
        main,
        "topLevel",
        /topLevel/
        ctx[]
      );
    },
    m(target, anchor) {
      insert(target, main, anchor);
      for (let i = ; i < each_blocks.length; i += ) {
        if (each_blocks[i]) {
          each_blocks[i].m(main, null);
        }
      }
      current = true;
    },
    p(ctx, [dirty]) {
      if (dirty & /hierarchy, plugin, view, fileType, FileType, closed, fold, side, unstage, stage, discard/
      ) {
        each_value = /hierarchy/
        ctx[].children;
        let i;
        for (i = ; i < each_value.length; i += ) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], );
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], );
            each_blocks[i].m(main, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += ) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /topLevel/
      ) {
        toggle_class(
          main,
          "topLevel",
          /topLevel/
          ctx[]
        );
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = ; i < each_value.length; i += ) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = ; i < each_blocks.length; i += ) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let side;
  let { hierarchy } = $$props;
  let { plugin } = $$props;
  let { view } = $$props;
  let { fileType } = $$props;
  let { topLevel = false } = $$props;
  const closed = {};
  function stage(path) {
    plugin.gitManager.stageAll({ dir: path }).finally(() => {
      dispatchEvent(new CustomEvent("git-refresh"));
    });
  }
  function unstage(path) {
    plugin.gitManager.unstageAll({ dir: path }).finally(() => {
      dispatchEvent(new CustomEvent("git-refresh"));
    });
  }
  function discard(item) {
    new DiscardModal(view.app, false, item.vaultPath).myOpen().then((shouldDiscard) => {
      if (shouldDiscard === true) {
        plugin.gitManager.discardAll({
          dir: item.path,
          status: plugin.cachedStatus
        }).finally(() => {
          dispatchEvent(new CustomEvent("git-refresh"));
        });
      }
    });
  }
  function fold(item) {
    $$invalidate(, closed[item.title] = !closed[item.title], closed);
  }
  const click_handler = (entity) => unstage(entity.path);
  const click_handler_ = (entity) => discard(entity);
  const click_handler_ = (entity) => stage(entity.path);
  const click_handler_ = (entity) => fold(entity);
  $$self.$$set = ($$props) => {
    if ("hierarchy" in $$props)
      $$invalidate(, hierarchy = $$props.hierarchy);
    if ("plugin" in $$props)
      $$invalidate(, plugin = $$props.plugin);
    if ("view" in $$props)
      $$invalidate(, view = $$props.view);
    if ("fileType" in $$props)
      $$invalidate(, fileType = $$props.fileType);
    if ("topLevel" in $$props)
      $$invalidate(, topLevel = $$props.topLevel);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /view/
    ) {
      $:
        $$invalidate(, side = view.leaf.getRoot().side == "left" ? "right" : "left");
    }
  };
  return [
    hierarchy,
    plugin,
    view,
    fileType,
    topLevel,
    closed,
    side,
    stage,
    unstage,
    discard,
    fold,
    click_handler,
    click_handler_,
    click_handler_,
    click_handler_
  ];
}
var TreeComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        hierarchy: ,
        plugin: ,
        view: ,
        fileType: ,
        topLevel: 
      },
      add_css
    );
  }
};
var treeComponent_default = TreeComponent;

// src/ui/sourceControl/sourceControl.svelte
function add_css(target) {
  append_styles(target, "svelte-bivb", `.commit-msg-input.svelte-bivb.svelte-bivb{width:%;overflow:hidden;resize:none;padding:px px;background-color:var(--background-modifier-form-field)}.git-commit-msg.svelte-bivb.svelte-bivb{position:relative;padding:;width:calc(% - var(--size--));margin:px auto}main.svelte-bivb .git-tools .files-count.svelte-bivb{padding-left:var(--size--);width:px;display:flex;align-items:center;justify-content:center}.git-commit-msg-clear-button.svelte-bivb.svelte-bivb{position:absolute;background:transparent;border-radius:%;color:var(--search-clear-button-color);cursor:var(--cursor);top:-px;right:px;bottom:px;line-height:;height:var(--input-height);width:px;margin:auto;padding: ;text-align:center;display:flex;justify-content:center;align-items:center;transition:color .s ease-in-out}.git-commit-msg-clear-button.svelte-bivb.svelte-bivb:after{content:"";height:var(--search-clear-button-size);width:var(--search-clear-button-size);display:block;background-color:currentColor;-webkit-mask-image:url("data:image/svg+xml,<svg viewBox='   ' fill='none' xmlns='http://www.w.org//svg'%E%Cpath fill-rule='evenodd' clip-rule='evenodd' d='M C.   .  C . .   C.   .  C . .   ZM. .L. .L. .L. .L. .L. .L. .L. .L. .L. .L. .L. .L. .Z' fill='currentColor'/></svg>");-webkit-mask-repeat:no-repeat}`);
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[] = list[i];
  return child_ctx;
}
function get_each_context_(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[] = list[i];
  return child_ctx;
}
function get_each_context_(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[] = list[i];
  return child_ctx;
}
function create_if_block_(ctx) {
  let div;
  let div_aria_label_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "git-commit-msg-clear-button svelte-bivb");
      attr(div, "aria-label", div_aria_label_value = "Clear");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /click_handler_/
          ctx[]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block(ctx) {
  let div;
  let div;
  let div;
  let div;
  let div;
  let t;
  let div;
  let t;
  let div;
  let div;
  let div;
  let t;
  let div;
  let t_value = (
    /status/
    ctx[].staged.length + ""
  );
  let t;
  let t;
  let t;
  let div;
  let div;
  let div;
  let t;
  let div;
  let t;
  let div;
  let div;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t_value = (
    /status/
    ctx[].changed.length + ""
  );
  let t;
  let t;
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /stagedOpen/
    ctx[] && create_if_block_(ctx)
  );
  let if_block = (
    /changesOpen/
    ctx[] && create_if_block_(ctx)
  );
  let if_block = (
    /lastPulledFiles/
    ctx[].length >  && create_if_block_(ctx)
  );
  return {
    c() {
      div = element("div");
      div = element("div");
      div = element("div");
      div = element("div");
      div = element("div");
      div.innerHTML = `<svg xmlns="http://www.w.org//svg" width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M L L "></path></svg>`;
      t = space();
      div = element("div");
      div.textContent = "Staged Changes";
      t = space();
      div = element("div");
      div = element("div");
      div = element("div");
      div.innerHTML = `<svg width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-minus"><line x="" y="" x="" y=""></line></svg>`;
      t = space();
      div = element("div");
      t = text(t_value);
      t = space();
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      div = element("div");
      div = element("div");
      div.innerHTML = `<svg xmlns="http://www.w.org//svg" width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M L L "></path></svg>`;
      t = space();
      div = element("div");
      div.textContent = "Changes";
      t = space();
      div = element("div");
      div = element("div");
      div = element("div");
      div.innerHTML = `<svg xmlns="http://www.w.org//svg" width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-undo"><path d="M vh"></path><path d="M a    --     - .L "></path></svg>`;
      t = space();
      div = element("div");
      div.innerHTML = `<svg xmlns="http://www.w.org//svg" width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-plus"><line x="" y="" x="" y=""></line><line x="" y="" x="" y=""></line></svg>`;
      t = space();
      div = element("div");
      t = text(t_value);
      t = space();
      if (if_block)
        if_block.c();
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div, "class", "nav-folder-title-content");
      attr(div, "data-icon", "minus");
      attr(div, "aria-label", "Unstage");
      attr(div, "class", "clickable-icon");
      attr(div, "class", "buttons");
      attr(div, "class", "files-count svelte-bivb");
      attr(div, "class", "git-tools");
      attr(div, "class", "nav-folder-title");
      attr(div, "class", "staged nav-folder");
      toggle_class(div, "is-collapsed", !/stagedOpen/
      ctx[]);
      attr(div, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div, "class", "nav-folder-title-content");
      attr(div, "data-icon", "undo");
      attr(div, "aria-label", "Discard");
      attr(div, "class", "clickable-icon");
      attr(div, "data-icon", "plus");
      attr(div, "aria-label", "Stage");
      attr(div, "class", "clickable-icon");
      attr(div, "class", "buttons");
      attr(div, "class", "files-count svelte-bivb");
      attr(div, "class", "git-tools");
      attr(div, "class", "nav-folder-title");
      attr(div, "class", "changes nav-folder");
      toggle_class(div, "is-collapsed", !/changesOpen/
      ctx[]);
      attr(div, "class", "nav-folder-children");
      attr(div, "class", "nav-folder mod-root");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, div);
      append(div, div);
      append(div, div);
      append(div, div);
      append(div, t);
      append(div, div);
      append(div, t);
      append(div, div);
      append(div, div);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      append(div, t);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      append(div, div);
      append(div, div);
      append(div, div);
      append(div, t);
      append(div, div);
      append(div, t);
      append(div, div);
      append(div, div);
      append(div, div);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      append(div, t);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "click", stop_propagation(
            /unstageAll/
            ctx[]
          )),
          listen(
            div,
            "click",
            /click_handler_/
            ctx[]
          ),
          listen(div, "click", stop_propagation(
            /discard/
            ctx[]
          )),
          listen(div, "click", stop_propagation(
            /stageAll/
            ctx[]
          )),
          listen(
            div,
            "click",
            /click_handler_/
            ctx[]
          )
        ];
        mounted = true;
      }
    },
    p(ctx, dirty) {
      if ((!current || dirty[] & /status/
      ) && t_value !== (t_value = /status/
      ctx[].staged.length + ""))
        set_data(t, t_value);
      if (
        /stagedOpen/
        ctx[]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[] & /stagedOpen/
          ) {
            transition_in(if_block, );
          }
        } else {
          if_block = create_if_block_(ctx);
          if_block.c();
          transition_in(if_block, );
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, , , () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[] & /stagedOpen/
      ) {
        toggle_class(div, "is-collapsed", !/stagedOpen/
        ctx[]);
      }
      if ((!current || dirty[] & /status/
      ) && t_value !== (t_value = /status/
      ctx[].changed.length + ""))
        set_data(t, t_value);
      if (
        /changesOpen/
        ctx[]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[] & /changesOpen/
          ) {
            transition_in(if_block, );
          }
        } else {
          if_block = create_if_block_(ctx);
          if_block.c();
          transition_in(if_block, );
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, , , () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[] & /changesOpen/
      ) {
        toggle_class(div, "is-collapsed", !/changesOpen/
        ctx[]);
      }
      if (
        /lastPulledFiles/
        ctx[].length > 
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[] & /lastPulledFiles/
          ) {
            transition_in(if_block, );
          }
        } else {
          if_block = create_if_block_(ctx);
          if_block.c();
          transition_in(if_block, );
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, , , () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(if_block);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(if_block);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[](null);
      if (if_block)
        if_block.d();
      ctx[](null);
      if (if_block)
        if_block.d();
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_transition;
  let current;
  const if_block_creators = [create_if_block_, create_else_block_];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if (
      /showTree/
      ctx[]
    )
      return ;
    return ;
  }
  current_block_type_index = select_block_type(ctx, [-, -]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], , , () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, );
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, { duration:  }, true);
          div_transition.run();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration:  }, false);
        div_transition.run();
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_else_block_(ctx) {
  let each__anchor;
  let current;
  let each_value_ = (
    /status/
    ctx[].staged
  );
  let each_blocks = [];
  for (let i = ; i < each_value_.length; i += ) {
    each_blocks[i] = create_each_block_(get_each_context_(ctx, each_value_, i));
  }
  const out = (i) => transition_out(each_blocks[i], , , () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = ; i < each_blocks.length; i += ) {
        each_blocks[i].c();
      }
      each__anchor = empty();
    },
    m(target, anchor) {
      for (let i = ; i < each_blocks.length; i += ) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each__anchor, anchor);
      current = true;
    },
    p(ctx, dirty) {
      if (dirty[] & /status, view, plugin/
      ) {
        each_value_ = /status/
        ctx[].staged;
        let i;
        for (i = ; i < each_value_.length; i += ) {
          const child_ctx = get_each_context_(ctx, each_value_, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], );
          } else {
            each_blocks[i] = create_each_block_(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], );
            each_blocks[i].m(each__anchor.parentNode, each__anchor);
          }
        }
        group_outros();
        for (i = each_value_.length; i < each_blocks.length; i += ) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = ; i < each_value_.length; i += ) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = ; i < each_blocks.length; i += ) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each__anchor);
    }
  };
}
function create_if_block_(ctx) {
  let treecomponent;
  let current;
  treecomponent = new treeComponent_default({
    props: {
      hierarchy: (
        /stagedHierarchy/
        ctx[]
      ),
      plugin: (
        /plugin/
        ctx[]
      ),
      view: (
        /view/
        ctx[]
      ),
      fileType:  / staged /,
      topLevel: true
    }
  });
  return {
    c() {
      create_component(treecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const treecomponent_changes = {};
      if (dirty[] & /stagedHierarchy/
      )
        treecomponent_changes.hierarchy = /stagedHierarchy/
        ctx[];
      if (dirty[] & /plugin/
      )
        treecomponent_changes.plugin = /plugin/
        ctx[];
      if (dirty[] & /view/
      )
        treecomponent_changes.view = /view/
        ctx[];
      treecomponent.$set(treecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treecomponent, detaching);
    }
  };
}
function create_each_block_(ctx) {
  let stagedfilecomponent;
  let current;
  stagedfilecomponent = new stagedFileComponent_default({
    props: {
      change: (
        /stagedFile/
        ctx[]
      ),
      view: (
        /view/
        ctx[]
      ),
      manager: (
        /plugin/
        ctx[].gitManager
      )
    }
  });
  return {
    c() {
      create_component(stagedfilecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(stagedfilecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const stagedfilecomponent_changes = {};
      if (dirty[] & /status/
      )
        stagedfilecomponent_changes.change = /stagedFile/
        ctx[];
      if (dirty[] & /view/
      )
        stagedfilecomponent_changes.view = /view/
        ctx[];
      if (dirty[] & /plugin/
      )
        stagedfilecomponent_changes.manager = /plugin/
        ctx[].gitManager;
      stagedfilecomponent.$set(stagedfilecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(stagedfilecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(stagedfilecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(stagedfilecomponent, detaching);
    }
  };
}
function create_if_block_(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_transition;
  let current;
  const if_block_creators = [create_if_block_, create_else_block_];
  const if_blocks = [];
  function select_block_type_(ctx, dirty) {
    if (
      /showTree/
      ctx[]
    )
      return ;
    return ;
  }
  current_block_type_index = select_block_type_(ctx, [-, -]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], , , () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, );
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, { duration:  }, true);
          div_transition.run();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration:  }, false);
        div_transition.run();
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_else_block_(ctx) {
  let each__anchor;
  let current;
  let each_value_ = (
    /status/
    ctx[].changed
  );
  let each_blocks = [];
  for (let i = ; i < each_value_.length; i += ) {
    each_blocks[i] = create_each_block_(get_each_context_(ctx, each_value_, i));
  }
  const out = (i) => transition_out(each_blocks[i], , , () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = ; i < each_blocks.length; i += ) {
        each_blocks[i].c();
      }
      each__anchor = empty();
    },
    m(target, anchor) {
      for (let i = ; i < each_blocks.length; i += ) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each__anchor, anchor);
      current = true;
    },
    p(ctx, dirty) {
      if (dirty[] & /status, view, plugin/
      ) {
        each_value_ = /status/
        ctx[].changed;
        let i;
        for (i = ; i < each_value_.length; i += ) {
          const child_ctx = get_each_context_(ctx, each_value_, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], );
          } else {
            each_blocks[i] = create_each_block_(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], );
            each_blocks[i].m(each__anchor.parentNode, each__anchor);
          }
        }
        group_outros();
        for (i = each_value_.length; i < each_blocks.length; i += ) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = ; i < each_value_.length; i += ) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = ; i < each_blocks.length; i += ) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each__anchor);
    }
  };
}
function create_if_block_(ctx) {
  let treecomponent;
  let current;
  treecomponent = new treeComponent_default({
    props: {
      hierarchy: (
        /changeHierarchy/
        ctx[]
      ),
      plugin: (
        /plugin/
        ctx[]
      ),
      view: (
        /view/
        ctx[]
      ),
      fileType:  / changed /,
      topLevel: true
    }
  });
  return {
    c() {
      create_component(treecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const treecomponent_changes = {};
      if (dirty[] & /changeHierarchy/
      )
        treecomponent_changes.hierarchy = /changeHierarchy/
        ctx[];
      if (dirty[] & /plugin/
      )
        treecomponent_changes.plugin = /plugin/
        ctx[];
      if (dirty[] & /view/
      )
        treecomponent_changes.view = /view/
        ctx[];
      treecomponent.$set(treecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treecomponent, detaching);
    }
  };
}
function create_each_block_(ctx) {
  let filecomponent;
  let current;
  filecomponent = new fileComponent_default({
    props: {
      change: (
        /change/
        ctx[]
      ),
      view: (
        /view/
        ctx[]
      ),
      manager: (
        /plugin/
        ctx[].gitManager
      )
    }
  });
  filecomponent.$on("git-refresh", triggerRefresh);
  return {
    c() {
      create_component(filecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(filecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const filecomponent_changes = {};
      if (dirty[] & /status/
      )
        filecomponent_changes.change = /change/
        ctx[];
      if (dirty[] & /view/
      )
        filecomponent_changes.view = /view/
        ctx[];
      if (dirty[] & /plugin/
      )
        filecomponent_changes.manager = /plugin/
        ctx[].gitManager;
      filecomponent.$set(filecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(filecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(filecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(filecomponent, detaching);
    }
  };
}
function create_if_block_(ctx) {
  let div;
  let div;
  let div;
  let t;
  let div;
  let t;
  let span;
  let t_value = (
    /lastPulledFiles/
    ctx[].length + ""
  );
  let t;
  let t;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /lastPulledFilesOpen/
    ctx[] && create_if_block_(ctx)
  );
  return {
    c() {
      div = element("div");
      div = element("div");
      div = element("div");
      div.innerHTML = `<svg xmlns="http://www.w.org//svg" width="" height="" viewBox="   " fill="none" stroke="currentColor" stroke-width="" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M L L "></path></svg>`;
      t = space();
      div = element("div");
      div.textContent = "Recently Pulled Files";
      t = space();
      span = element("span");
      t = text(t_value);
      t = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "nav-folder-collapse-indicator collapse-icon");
      attr(div, "class", "nav-folder-title-content");
      attr(span, "class", "tree-item-flair");
      attr(div, "class", "nav-folder-title");
      attr(div, "class", "pulled nav-folder");
      toggle_class(div, "is-collapsed", !/lastPulledFilesOpen/
      ctx[]);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, div);
      append(div, div);
      append(div, t);
      append(div, div);
      append(div, t);
      append(div, span);
      append(span, t);
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /click_handler_/
          ctx[]
        );
        mounted = true;
      }
    },
    p(ctx, dirty) {
      if ((!current || dirty[] & /lastPulledFiles/
      ) && t_value !== (t_value = /lastPulledFiles/
      ctx[].length + ""))
        set_data(t, t_value);
      if (
        /lastPulledFilesOpen/
        ctx[]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[] & /lastPulledFilesOpen/
          ) {
            transition_in(if_block, );
          }
        } else {
          if_block = create_if_block_(ctx);
          if_block.c();
          transition_in(if_block, );
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, , , () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[] & /lastPulledFilesOpen/
      ) {
        toggle_class(div, "is-collapsed", !/lastPulledFilesOpen/
        ctx[]);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_transition;
  let current;
  const if_block_creators = [create_if_block_, create_else_block];
  const if_blocks = [];
  function select_block_type_(ctx, dirty) {
    if (
      /showTree/
      ctx[]
    )
      return ;
    return ;
  }
  current_block_type_index = select_block_type_(ctx, [-, -]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(div, "class", "nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      current = true;
    },
    p(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], , , () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, );
        if_block.m(div, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div, slide, { duration:  }, true);
          div_transition.run();
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div, slide, { duration:  }, false);
        div_transition.run();
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_else_block(ctx) {
  let each__anchor;
  let current;
  let each_value = (
    /lastPulledFiles/
    ctx[]
  );
  let each_blocks = [];
  for (let i = ; i < each_value.length; i += ) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], , , () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = ; i < each_blocks.length; i += ) {
        each_blocks[i].c();
      }
      each__anchor = empty();
    },
    m(target, anchor) {
      for (let i = ; i < each_blocks.length; i += ) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each__anchor, anchor);
      current = true;
    },
    p(ctx, dirty) {
      if (dirty[] & /lastPulledFiles, view/
      ) {
        each_value = /lastPulledFiles/
        ctx[];
        let i;
        for (i = ; i < each_value.length; i += ) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], );
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], );
            each_blocks[i].m(each__anchor.parentNode, each__anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += ) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = ; i < each_value.length; i += ) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = ; i < each_blocks.length; i += ) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each__anchor);
    }
  };
}
function create_if_block_(ctx) {
  let treecomponent;
  let current;
  treecomponent = new treeComponent_default({
    props: {
      hierarchy: (
        /lastPulledFilesHierarchy/
        ctx[]
      ),
      plugin: (
        /plugin/
        ctx[]
      ),
      view: (
        /view/
        ctx[]
      ),
      fileType:  / pulled /,
      topLevel: true
    }
  });
  return {
    c() {
      create_component(treecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(treecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const treecomponent_changes = {};
      if (dirty[] & /lastPulledFilesHierarchy/
      )
        treecomponent_changes.hierarchy = /lastPulledFilesHierarchy/
        ctx[];
      if (dirty[] & /plugin/
      )
        treecomponent_changes.plugin = /plugin/
        ctx[];
      if (dirty[] & /view/
      )
        treecomponent_changes.view = /view/
        ctx[];
      treecomponent.$set(treecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treecomponent, detaching);
    }
  };
}
function create_each_block(ctx) {
  let pulledfilecomponent;
  let current;
  pulledfilecomponent = new pulledFileComponent_default({
    props: {
      change: (
        /change/
        ctx[]
      ),
      view: (
        /view/
        ctx[]
      )
    }
  });
  pulledfilecomponent.$on("git-refresh", triggerRefresh);
  return {
    c() {
      create_component(pulledfilecomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pulledfilecomponent, target, anchor);
      current = true;
    },
    p(ctx, dirty) {
      const pulledfilecomponent_changes = {};
      if (dirty[] & /lastPulledFiles/
      )
        pulledfilecomponent_changes.change = /change/
        ctx[];
      if (dirty[] & /view/
      )
        pulledfilecomponent_changes.view = /view/
        ctx[];
      pulledfilecomponent.$set(pulledfilecomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pulledfilecomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pulledfilecomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pulledfilecomponent, detaching);
    }
  };
}
function create_fragment(ctx) {
  let main;
  let div;
  let div;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t;
  let div;
  let t;
  let div;
  let textarea;
  let t;
  let t;
  let div;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /commitMessage/
    ctx[] && create_if_block_(ctx)
  );
  let if_block = (
    /status/
    ctx[] && /stagedHierarchy/
    ctx[] && /changeHierarchy/
    ctx[] && create_if_block(ctx)
  );
  return {
    c() {
      main = element("main");
      div = element("div");
      div = element("div");
      div = element("div");
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      t = space();
      div = element("div");
      textarea = element("textarea");
      t = space();
      if (if_block)
        if_block.c();
      t = space();
      div = element("div");
      if (if_block)
        if_block.c();
      attr(div, "id", "backup-btn");
      attr(div, "data-icon", "arrow-up-circle");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "aria-label", "Backup");
      attr(div, "id", "commit-btn");
      attr(div, "data-icon", "check");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "aria-label", "Commit");
      attr(div, "id", "stage-all");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "data-icon", "plus-circle");
      attr(div, "aria-label", "Stage all");
      attr(div, "id", "unstage-all");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "data-icon", "minus-circle");
      attr(div, "aria-label", "Unstage all");
      attr(div, "id", "push");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "data-icon", "upload");
      attr(div, "aria-label", "Push");
      attr(div, "id", "pull");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "data-icon", "download");
      attr(div, "aria-label", "Pull");
      attr(div, "id", "layoutChange");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "aria-label", "Change Layout");
      attr(div, "id", "refresh");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "data-icon", "refresh-cw");
      attr(div, "aria-label", "Refresh");
      set_style(div, "margin", "px");
      toggle_class(
        div,
        "loading",
        /loading/
        ctx[]
      );
      attr(div, "class", "nav-buttons-container");
      attr(div, "class", "nav-header");
      attr(
        textarea,
        "rows",
        /rows/
        ctx[]
      );
      attr(textarea, "class", "commit-msg-input svelte-bivb");
      attr(textarea, "spellcheck", "true");
      attr(textarea, "placeholder", "Commit Message");
      attr(div, "class", "git-commit-msg svelte-bivb");
      attr(div, "class", "nav-files-container");
      set_style(div, "position", "relative");
      attr(main, "class", "svelte-bivb");
    },
    m(target, anchor) {
      insert(target, main, anchor);
      append(main, div);
      append(div, div);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(div, t);
      append(div, div);
      ctx[](div);
      append(main, t);
      append(main, div);
      append(div, textarea);
      set_input_value(
        textarea,
        /commitMessage/
        ctx[]
      );
      append(div, t);
      if (if_block)
        if_block.m(div, null);
      append(main, t);
      append(main, div);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div,
            "click",
            /backup/
            ctx[]
          ),
          listen(
            div,
            "click",
            /commit/
            ctx[]
          ),
          listen(
            div,
            "click",
            /stageAll/
            ctx[]
          ),
          listen(
            div,
            "click",
            /unstageAll/
            ctx[]
          ),
          listen(
            div,
            "click",
            /push/
            ctx[]
          ),
          listen(
            div,
            "click",
            /pull/
            ctx[]
          ),
          listen(
            div,
            "click",
            /click_handler/
            ctx[]
          ),
          listen(div, "click", triggerRefresh),
          listen(
            textarea,
            "input",
            /textarea_input_handler/
            ctx[]
          )
        ];
        mounted = true;
      }
    },
    p(ctx, dirty) {
      if (!current || dirty[] & /loading/
      ) {
        toggle_class(
          div,
          "loading",
          /loading/
          ctx[]
        );
      }
      if (!current || dirty[] & /rows/
      ) {
        attr(
          textarea,
          "rows",
          /rows/
          ctx[]
        );
      }
      if (dirty[] & /commitMessage/
      ) {
        set_input_value(
          textarea,
          /commitMessage/
          ctx[]
        );
      }
      if (
        /commitMessage/
        ctx[]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_(ctx);
          if_block.c();
          if_block.m(div, null);
        }
      } else if (if_block) {
        if_block.d();
        if_block = null;
      }
      if (
        /status/
        ctx[] && /stagedHierarchy/
        ctx[] && /changeHierarchy/
        ctx[]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[] & /status, stagedHierarchy, changeHierarchy/
          ) {
            transition_in(if_block, );
          }
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          transition_in(if_block, );
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, , , () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(main);
      ctx[](null);
      ctx[](null);
      ctx[](null);
      ctx[](null);
      ctx[](null);
      ctx[](null);
      ctx[](null);
      ctx[](null);
      if (if_block)
        if_block.d();
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function triggerRefresh() {
  dispatchEvent(new CustomEvent("git-refresh"));
}
function instance($$self, $$props, $$invalidate) {
  let rows;
  let { plugin } = $$props;
  let { view } = $$props;
  let loading;
  let status;
  let lastPulledFiles = [];
  let commitMessage = plugin.settings.commitMessage;
  let buttons = [];
  let changeHierarchy;
  let stagedHierarchy;
  let lastPulledFilesHierarchy;
  let changesOpen = true;
  let stagedOpen = true;
  let lastPulledFilesOpen = true;
  let showTree = plugin.settings.treeStructure;
  let layoutBtn;
  addEventListener("git-view-refresh", refresh);
  plugin.app.workspace.onLayoutReady(() => {
    window.setTimeout(
      () => {
        buttons.forEach((btn) => (, import_obsidian.setIcon)(btn, btn.getAttr("data-icon"), ));
        (, import_obsidian.setIcon)(layoutBtn, showTree ? "list" : "folder", );
      },
      
    );
  });
  onDestroy(() => {
    removeEventListener("git-view-refresh", refresh);
  });
  function commit() {
    return __awaiter(this, void , void , function () {
      $$invalidate(, loading = true);
      if (status) {
        if (yield plugin.hasTooBigFiles(status.staged)) {
          plugin.setState( / idle /);
          return false;
        }
        plugin.gitManager.commit(commitMessage).then(() => {
          if (commitMessage !== plugin.settings.commitMessage) {
            $$invalidate(, commitMessage = "");
          }
          plugin.setUpAutoBackup();
        }).finally(triggerRefresh);
      }
    });
  }
  function backup() {
    return __awaiter(this, void , void , function () {
      $$invalidate(, loading = true);
      if (status) {
        plugin.createBackup(false, false, commitMessage).then(() => {
          if (commitMessage !== plugin.settings.commitMessage) {
            $$invalidate(, commitMessage = "");
          }
        }).finally(triggerRefresh);
      }
    });
  }
  function refresh() {
    return __awaiter(this, void , void , function () {
      if (!plugin.gitReady) {
        $$invalidate(, status = void );
        return;
      }
      $$invalidate(, status = plugin.cachedStatus);
      if (plugin.lastPulledFiles && plugin.lastPulledFiles != lastPulledFiles) {
        $$invalidate(, lastPulledFiles = plugin.lastPulledFiles);
        $$invalidate(, lastPulledFilesHierarchy = {
          title: "",
          path: "",
          vaultPath: "",
          children: plugin.gitManager.getTreeStructure(lastPulledFiles)
        });
      }
      if (status) {
        const sort = (a, b) => {
          return a.vault_path.split("/").last().localeCompare(getDisplayPath(b.vault_path));
        };
        status.changed.sort(sort);
        status.staged.sort(sort);
        if (status.changed.length + status.staged.length > ) {
          $$invalidate(, status = void );
          if (!plugin.loading) {
            plugin.displayError("Too many changes to display");
          }
        } else {
          $$invalidate(, changeHierarchy = {
            title: "",
            path: "",
            vaultPath: "",
            children: plugin.gitManager.getTreeStructure(status.changed)
          });
          $$invalidate(, stagedHierarchy = {
            title: "",
            path: "",
            vaultPath: "",
            children: plugin.gitManager.getTreeStructure(status.staged)
          });
        }
      } else {
        $$invalidate(, changeHierarchy = void );
        $$invalidate(, stagedHierarchy = void );
      }
      $$invalidate(, loading = plugin.loading);
    });
  }
  function stageAll() {
    $$invalidate(, loading = true);
    plugin.gitManager.stageAll({ status: status }).finally(triggerRefresh);
  }
  function unstageAll() {
    $$invalidate(, loading = true);
    plugin.gitManager.unstageAll({ status: status }).finally(triggerRefresh);
  }
  function push() {
    $$invalidate(, loading = true);
    plugin.push().finally(triggerRefresh);
  }
  function pull() {
    $$invalidate(, loading = true);
    plugin.pullChangesFromRemote().finally(triggerRefresh);
  }
  function discard() {
    new DiscardModal(view.app, false, plugin.gitManager.getVaultPath("/")).myOpen().then((shouldDiscard) => {
      if (shouldDiscard === true) {
        plugin.gitManager.discardAll({ status: plugin.cachedStatus }).finally(() => {
          dispatchEvent(new CustomEvent("git-refresh"));
        });
      }
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      layoutBtn = $$value;
      $$invalidate(, layoutBtn);
    });
  }
  const click_handler = () => {
    $$invalidate(, showTree = !showTree);
    $$invalidate(, plugin.settings.treeStructure = showTree, plugin);
    plugin.saveSettings();
  };
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  function textarea_input_handler() {
    commitMessage = this.value;
    $$invalidate(, commitMessage);
  }
  const click_handler_ = () => $$invalidate(, commitMessage = "");
  function div_binding_($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  const click_handler_ = () => $$invalidate(, stagedOpen = !stagedOpen);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttons[] = $$value;
      $$invalidate(, buttons);
    });
  }
  const click_handler_ = () => $$invalidate(, changesOpen = !changesOpen);
  const click_handler_ = () => $$invalidate(, lastPulledFilesOpen = !lastPulledFilesOpen);
  $$self.$$set = ($$props) => {
    if ("plugin" in $$props)
      $$invalidate(, plugin = $$props.plugin);
    if ("view" in $$props)
      $$invalidate(, view = $$props.view);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[] & /layoutBtn, showTree/
    ) {
      $: {
        if (layoutBtn) {
          layoutBtn.empty();
          (, import_obsidian.setIcon)(layoutBtn, showTree ? "list" : "folder", );
        }
      }
    }
    if ($$self.$$.dirty[] & /commitMessage/
    ) {
      $:
        $$invalidate(, rows = (commitMessage.match(/\n/g) || []).length +  || );
    }
  };
  return [
    plugin,
    view,
    commitMessage,
    showTree,
    layoutBtn,
    loading,
    status,
    lastPulledFiles,
    buttons,
    changeHierarchy,
    stagedHierarchy,
    lastPulledFilesHierarchy,
    changesOpen,
    stagedOpen,
    lastPulledFilesOpen,
    rows,
    commit,
    backup,
    stageAll,
    unstageAll,
    push,
    pull,
    discard,
    div_binding,
    div_binding,
    div_binding,
    div_binding,
    div_binding,
    div_binding,
    div_binding,
    click_handler,
    div_binding,
    textarea_input_handler,
    click_handler_,
    div_binding_,
    click_handler_,
    div_binding,
    click_handler_,
    click_handler_
  ];
}
var SourceControl = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { plugin: , view:  }, add_css, [-, -]);
  }
};
var sourceControl_default = SourceControl;

// src/ui/sourceControl/sourceControl.ts
var GitView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.hoverPopover = null;
  }
  getViewType() {
    return SOURCE_CONTROL_VIEW_CONFIG.type;
  }
  getDisplayText() {
    return SOURCE_CONTROL_VIEW_CONFIG.name;
  }
  getIcon() {
    return SOURCE_CONTROL_VIEW_CONFIG.icon;
  }
  onClose() {
    return super.onClose();
  }
  onOpen() {
    this._view = new sourceControl_default({
      target: this.contentEl,
      props: {
        plugin: this.plugin,
        view: this
      }
    });
    return super.onOpen();
  }
};

// src/ui/statusBar/branchStatusBar.ts
init_polyfill_buffer();
var BranchStatusBar = class {
  constructor(statusBarEl, plugin) {
    this.statusBarEl = statusBarEl;
    this.plugin = plugin;
    this.statusBarEl.addClass("mod-clickable");
    this.statusBarEl.onClickEvent((e) => {
      this.plugin.switchBranch();
    });
  }
  async display() {
    if (this.plugin.gitReady) {
      const branchInfo = await this.plugin.gitManager.branchInfo();
      if (branchInfo.current != void ) {
        this.statusBarEl.setText(branchInfo.current);
      } else {
        this.statusBarEl.empty();
      }
    } else {
      this.statusBarEl.empty();
    }
  }
};

// src/main.ts
var ObsidianGit = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.gitReady = false;
    this.promiseQueue = new PromiseQueue();
    this.conflictOutputFile = "conflict-files-obsidian-git.md";
    this.offlineMode = false;
    this.loading = false;
  }
  setState(state) {
    var _a;
    this.state = state;
    (_a = this.statusBar) == null ? void  : _a.display();
  }
  async updateCachedStatus() {
    this.cachedStatus = await this.gitManager.status();
    return this.cachedStatus;
  }
  async refresh() {
    const gitView = this.app.workspace.getLeavesOfType(
      SOURCE_CONTROL_VIEW_CONFIG.type
    );
    const historyView = this.app.workspace.getLeavesOfType(
      HISTORY_VIEW_CONFIG.type
    );
    if (this.settings.changedFilesInStatusBar || gitView.length >  || historyView.length > ) {
      this.loading = true;
      dispatchEvent(new CustomEvent("git-view-refresh"));
      await this.updateCachedStatus();
      this.loading = false;
      dispatchEvent(new CustomEvent("git-view-refresh"));
    }
  }
  async onload() {
    console.log("loading " + this.manifest.name + " plugin");
    this.localStorage = new LocalStorageSettings(this);
    this.localStorage.migrate();
    await this.loadSettings();
    this.migrateSettings();
    this.addSettingTab(new ObsidianGitSettingsTab(this.app, this));
    if (!this.localStorage.getPluginDisabled()) {
      this.loadPlugin();
    }
  }
  async loadPlugin() {
    addEventListener("git-refresh", this.refresh.bind(this));
    this.registerView(SOURCE_CONTROL_VIEW_CONFIG.type, (leaf) => {
      return new GitView(leaf, this);
    });
    this.registerView(HISTORY_VIEW_CONFIG.type, (leaf) => {
      return new HistoryView(leaf, this);
    });
    this.registerView(DIFF_VIEW_CONFIG.type, (leaf) => {
      return new DiffView(leaf, this);
    });
    this.app.workspace.registerHoverLinkSource(
      SOURCE_CONTROL_VIEW_CONFIG.type,
      {
        display: "Git View",
        defaultMod: true
      }
    );
    this.setRefreshDebouncer();
    this.addCommand({
      id: "edit-gitignore",
      name: "Edit .gitignore",
      callback: async () => {
        const path = this.gitManager.getVaultPath(".gitignore");
        if (!await this.app.vault.adapter.exists(path)) {
          this.app.vault.adapter.write(path, "");
        }
        const content = await this.app.vault.adapter.read(path);
        const modal = new IgnoreModal(this.app, content);
        const res = await modal.open();
        if (res !== void ) {
          await this.app.vault.adapter.write(path, res);
          this.refresh();
        }
      }
    });
    this.addCommand({
      id: "open-git-view",
      name: "Open source control view",
      callback: async () => {
        const leafs = this.app.workspace.getLeavesOfType(
          SOURCE_CONTROL_VIEW_CONFIG.type
        );
        let leaf;
        if (leafs.length === ) {
          leaf = this.app.workspace.getRightLeaf(false);
          await leaf.setViewState({
            type: SOURCE_CONTROL_VIEW_CONFIG.type
          });
        } else {
          leaf = leafs.first();
        }
        this.app.workspace.revealLeaf(leaf);
        dispatchEvent(new CustomEvent("git-refresh"));
      }
    });
    this.addCommand({
      id: "open-history-view",
      name: "Open history view",
      callback: async () => {
        const leafs = this.app.workspace.getLeavesOfType(
          HISTORY_VIEW_CONFIG.type
        );
        let leaf;
        if (leafs.length === ) {
          leaf = this.app.workspace.getRightLeaf(false);
          await leaf.setViewState({
            type: HISTORY_VIEW_CONFIG.type
          });
        } else {
          leaf = leafs.first();
        }
        this.app.workspace.revealLeaf(leaf);
        dispatchEvent(new CustomEvent("git-refresh"));
      }
    });
    this.addCommand({
      id: "open-diff-view",
      name: "Open diff view",
      checkCallback: (checking) => {
        var _a;
        const file = this.app.workspace.getActiveFile();
        if (checking) {
          return file !== null;
        } else {
          (_a = getNewLeaf()) == null ? void  : _a.setViewState({
            type: DIFF_VIEW_CONFIG.type,
            active: true,
            state: {
              staged: false,
              file: this.gitManager.getPath(file.path, true)
            }
          });
        }
      }
    });
    this.addCommand({
      id: "view-file-on-github",
      name: "Open file on GitHub",
      editorCallback: (editor, { file }) => openLineInGitHub(editor, file, this.gitManager)
    });
    this.addCommand({
      id: "view-history-on-github",
      name: "Open file history on GitHub",
      editorCallback: (_, { file }) => openHistoryInGitHub(file, this.gitManager)
    });
    this.addCommand({
      id: "pull",
      name: "Pull",
      callback: () => this.promiseQueue.addTask(() => this.pullChangesFromRemote())
    });
    this.addCommand({
      id: "switch-to-remote-branch",
      name: "Switch to remote branch",
      callback: () => this.promiseQueue.addTask(() => this.switchRemoteBranch())
    });
    this.addCommand({
      id: "add-to-gitignore",
      name: "Add file to gitignore",
      checkCallback: (checking) => {
        const file = app.workspace.getActiveFile();
        if (checking) {
          return file !== null;
        } else {
          app.vault.adapter.append(
            this.gitManager.getVaultPath(".gitignore"),
            "\n" + this.gitManager.getPath(file.path, true)
          ).then(() => {
            this.refresh();
          });
        }
      }
    });
    this.addCommand({
      id: "push",
      name: "Create backup",
      callback: () => this.promiseQueue.addTask(() => this.createBackup(false))
    });
    this.addCommand({
      id: "backup-and-close",
      name: "Create backup and close",
      callback: () => this.promiseQueue.addTask(async () => {
        await this.createBackup(false);
        window.close();
      })
    });
    this.addCommand({
      id: "commit-push-specified-message",
      name: "Create backup with specific message",
      callback: () => this.promiseQueue.addTask(() => this.createBackup(false, true))
    });
    this.addCommand({
      id: "commit",
      name: "Commit all changes",
      callback: () => this.promiseQueue.addTask(
        () => this.commit({ fromAutoBackup: false })
      )
    });
    this.addCommand({
      id: "commit-specified-message",
      name: "Commit all changes with specific message",
      callback: () => this.promiseQueue.addTask(
        () => this.commit({
          fromAutoBackup: false,
          requestCustomMessage: true
        })
      )
    });
    this.addCommand({
      id: "commit-staged",
      name: "Commit staged",
      callback: () => this.promiseQueue.addTask(
        () => this.commit({
          fromAutoBackup: false,
          requestCustomMessage: false,
          onlyStaged: true
        })
      )
    });
    this.addCommand({
      id: "commit-staged-specified-message",
      name: "Commit staged with specific message",
      callback: () => this.promiseQueue.addTask(
        () => this.commit({
          fromAutoBackup: false,
          requestCustomMessage: true,
          onlyStaged: true
        })
      )
    });
    this.addCommand({
      id: "push",
      name: "Push",
      callback: () => this.promiseQueue.addTask(() => this.push())
    });
    this.addCommand({
      id: "stage-current-file",
      name: "Stage current file",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (checking) {
          return file !== null;
        } else {
          this.promiseQueue.addTask(() => this.stageFile(file));
        }
      }
    });
    this.addCommand({
      id: "unstage-current-file",
      name: "Unstage current file",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (checking) {
          return file !== null;
        } else {
          this.promiseQueue.addTask(() => this.unstageFile(file));
        }
      }
    });
    this.addCommand({
      id: "edit-remotes",
      name: "Edit remotes",
      callback: async () => this.editRemotes()
    });
    this.addCommand({
      id: "remove-remote",
      name: "Remove remote",
      callback: async () => this.removeRemote()
    });
    this.addCommand({
      id: "delete-repo",
      name: "CAUTION: Delete repository",
      callback: async () => {
        const repoExists = await this.app.vault.adapter.exists(
          `${this.settings.basePath}/.git`
        );
        if (repoExists) {
          const modal = new GeneralModal({
            options: ["NO", "YES"],
            placeholder: "Do you really want to delete the repository (.git directory)? This action cannot be undone.",
            onlySelection: true
          });
          const shouldDelete = await modal.open() === "YES";
          if (shouldDelete) {
            await this.app.vault.adapter.rmdir(
              `${this.settings.basePath}/.git`,
              true
            );
            new import_obsidian.Notice(
              "Successfully deleted repository. Reloading plugin..."
            );
            this.unloadPlugin();
            this.init();
          }
        } else {
          new import_obsidian.Notice("No repository found");
        }
      }
    });
    this.addCommand({
      id: "init-repo",
      name: "Initialize a new repo",
      callback: async () => this.createNewRepo()
    });
    this.addCommand({
      id: "clone-repo",
      name: "Clone an existing remote repo",
      callback: async () => this.cloneNewRepo()
    });
    this.addCommand({
      id: "list-changed-files",
      name: "List changed files",
      callback: async () => {
        if (!await this.isAllInitialized())
          return;
        const status = await this.gitManager.status();
        this.setState( / idle /);
        if (status.changed.length + status.staged.length > ) {
          this.displayError("Too many changes to display");
          return;
        }
        new ChangedFilesModal(this, status.changed).open();
      }
    });
    this.addCommand({
      id: "switch-branch",
      name: "Switch branch",
      callback: () => {
        this.switchBranch();
      }
    });
    this.addCommand({
      id: "create-branch",
      name: "Create new branch",
      callback: () => {
        this.createBranch();
      }
    });
    this.addCommand({
      id: "delete-branch",
      name: "Delete branch",
      callback: () => {
        this.deleteBranch();
      }
    });
    this.addCommand({
      id: "discard-all",
      name: "CAUTION: Discard all changes",
      callback: async () => {
        if (!await this.isAllInitialized())
          return false;
        const modal = new GeneralModal({
          options: ["NO", "YES"],
          placeholder: "Do you want to discard all changes to tracked files? This action cannot be undone.",
          onlySelection: true
        });
        const shouldDiscardAll = await modal.open() === "YES";
        if (shouldDiscardAll) {
          this.promiseQueue.addTask(() => this.discardAll());
        }
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file, source) => {
        this.handleFileMenu(menu, file, source);
      })
    );
    if (this.settings.showStatusBar) {
      const statusBarEl = this.addStatusBarItem();
      this.statusBar = new StatusBar(statusBarEl, this);
      this.registerInterval(
        window.setInterval(() => {
          var _a;
          return (_a = this.statusBar) == null ? void  : _a.display();
        }, e)
      );
    }
    if (import_obsidian.Platform.isDesktop && this.settings.showBranchStatusBar) {
      const branchStatusBarEl = this.addStatusBarItem();
      this.branchBar = new BranchStatusBar(branchStatusBarEl, this);
      this.registerInterval(
        window.setInterval(() => {
          var _a;
          return (_a = this.branchBar) == null ? void  : _a.display();
        }, e)
      );
    }
    this.app.workspace.onLayoutReady(() => this.init());
  }
  setRefreshDebouncer() {
    var _a;
    (_a = this.debRefresh) == null ? void  : _a.cancel();
    this.debRefresh = (, import_obsidian.debounce)(
      () => {
        if (this.settings.refreshSourceControl) {
          this.refresh();
        }
      },
      this.settings.refreshSourceControlTimer,
      true
    );
  }
  async showNotices() {
    const length = e;
    if (this.manifest.id === "obsidian-git" && import_obsidian.Platform.isDesktopApp && !this.settings.showedMobileNotice) {
      new import_obsidian.Notice(
        "Obsidian Git is now available on mobile! Please read the plugin's README for more information.",
        length
      );
      this.settings.showedMobileNotice = true;
      await this.saveSettings();
    }
    if (this.manifest.id === "obsidian-git-isomorphic") {
      new import_obsidian.Notice(
        "Obsidian Git Mobile is now deprecated. Please uninstall it and install Obsidian Git instead.",
        length
      );
    }
  }
  handleFileMenu(menu, file, source) {
    if (!this.settings.showFileMenu)
      return;
    if (source !== "file-explorer-context-menu") {
      return;
    }
    if (!file) {
      return;
    }
    if (!this.gitReady)
      return;
    menu.addItem((item) => {
      item.setTitle(`Git: Stage`).setIcon("plus-circle").setSection("action").onClick((_) => {
        this.promiseQueue.addTask(async () => {
          if (file instanceof import_obsidian.TFile) {
            await this.gitManager.stage(file.path, true);
          } else {
            await this.gitManager.stageAll({
              dir: this.gitManager.getPath(file.path, true)
            });
          }
          this.displayMessage(`Staged ${file.path}`);
        });
      });
    });
    menu.addItem((item) => {
      item.setTitle(`Git: Unstage`).setIcon("minus-circle").setSection("action").onClick((_) => {
        this.promiseQueue.addTask(async () => {
          if (file instanceof import_obsidian.TFile) {
            await this.gitManager.unstage(file.path, true);
          } else {
            await this.gitManager.unstageAll({
              dir: this.gitManager.getPath(file.path, true)
            });
          }
          this.displayMessage(`Unstaged ${file.path}`);
        });
      });
    });
  }
  async migrateSettings() {
    if (this.settings.mergeOnPull != void ) {
      this.settings.syncMethod = this.settings.mergeOnPull ? "merge" : "rebase";
      this.settings.mergeOnPull = void ;
      await this.saveSettings();
    }
    if (this.settings.autoCommitMessage === void ) {
      this.settings.autoCommitMessage = this.settings.commitMessage;
      await this.saveSettings();
    }
    if (this.settings.gitPath != void ) {
      this.localStorage.setGitPath(this.settings.gitPath);
      this.settings.gitPath = void ;
      await this.saveSettings();
    }
    if (this.settings.username != void ) {
      this.localStorage.setPassword(this.settings.username);
      this.settings.username = void ;
      await this.saveSettings();
    }
  }
  unloadPlugin() {
    this.gitReady = false;
    dispatchEvent(new CustomEvent("git-refresh"));
    this.clearAutoPull();
    this.clearAutoPush();
    this.clearAutoBackup();
    removeEventListener("git-refresh", this.refresh.bind(this));
    this.app.metadataCache.offref(this.modifyEvent);
    this.app.metadataCache.offref(this.deleteEvent);
    this.app.metadataCache.offref(this.createEvent);
    this.app.metadataCache.offref(this.renameEvent);
    this.debRefresh.cancel();
  }
  async onunload() {
    this.app.workspace.unregisterHoverLinkSource(
      SOURCE_CONTROL_VIEW_CONFIG.type
    );
    this.unloadPlugin();
    console.log("unloading " + this.manifest.name + " plugin");
  }
  async loadSettings() {
    let data = await this.loadData();
    if (data == void ) {
      data = { showedMobileNotice: true };
    }
    this.settings = Object.assign({}, DEFAULT_SETTINGS, data);
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async saveLastAuto(date, mode) {
    if (mode === "backup") {
      this.localStorage.setLastAutoBackup(date.toString());
    } else if (mode === "pull") {
      this.localStorage.setLastAutoPull(date.toString());
    } else if (mode === "push") {
      this.localStorage.setLastAutoPush(date.toString());
    }
  }
  async loadLastAuto() {
    var _a, _b, _c;
    return {
      backup: new Date((_a = this.localStorage.getLastAutoBackup()) != null ? _a : ""),
      pull: new Date((_b = this.localStorage.getLastAutoPull()) != null ? _b : ""),
      push: new Date((_c = this.localStorage.getLastAutoPush()) != null ? _c : "")
    };
  }
  async init() {
    var _a;
    this.showNotices();
    try {
      if (import_obsidian.Platform.isDesktopApp) {
        this.gitManager = new SimpleGit(this);
        await this.gitManager.setGitInstance();
      } else {
        this.gitManager = new IsomorphicGit(this);
      }
      const result = await this.gitManager.checkRequirements();
      switch (result) {
        case "missing-git":
          this.displayError("Cannot run git command");
          break;
        case "missing-repo":
          new import_obsidian.Notice(
            "Can't find a valid git repository. Please create one via the given command or clone an existing repo.",
            e
          );
          break;
        case "valid":
          this.gitReady = true;
          this.setState( / idle /);
          this.modifyEvent = this.app.vault.on("modify", () => {
            this.debRefresh();
          });
          this.deleteEvent = this.app.vault.on("delete", () => {
            this.debRefresh();
          });
          this.createEvent = this.app.vault.on("create", () => {
            this.debRefresh();
          });
          this.renameEvent = this.app.vault.on("rename", () => {
            this.debRefresh();
          });
          this.registerEvent(this.modifyEvent);
          this.registerEvent(this.deleteEvent);
          this.registerEvent(this.createEvent);
          this.registerEvent(this.renameEvent);
          (_a = this.branchBar) == null ? void  : _a.display();
          dispatchEvent(new CustomEvent("git-refresh"));
          if (this.settings.autoPullOnBoot) {
            this.promiseQueue.addTask(
              () => this.pullChangesFromRemote()
            );
          }
          this.setUpAutos();
          break;
        default:
          console.log(
            "Something weird happened. The 'checkRequirements' result is " + result
          );
      }
    } catch (error) {
      this.displayError(error);
      console.error(error);
    }
  }
  async createNewRepo() {
    await this.gitManager.init();
    new import_obsidian.Notice("Initialized new repo");
    await this.init();
  }
  async cloneNewRepo() {
    const modal = new GeneralModal({ placeholder: "Enter remote URL" });
    const url = await modal.open();
    if (url) {
      const confirmOption = "Vault Root";
      let dir = await new GeneralModal({
        options: [confirmOption],
        placeholder: "Enter directory for clone. It needs to be empty or not existent.",
        allowEmpty: this.gitManager instanceof IsomorphicGit
      }).open();
      if (dir !== void ) {
        if (dir === confirmOption) {
          dir = ".";
        }
        dir = (, import_obsidian.normalizePath)(dir);
        if (dir === "/") {
          dir = ".";
        }
        if (dir === ".") {
          const modal = new GeneralModal({
            options: ["NO", "YES"],
            placeholder: `Does your remote repo contain a ${app.vault.configDir} directory at the root?`,
            onlySelection: true
          });
          const containsConflictDir = await modal.open();
          if (containsConflictDir === void ) {
            new import_obsidian.Notice("Aborted clone");
            return;
          } else if (containsConflictDir === "YES") {
            const confirmOption = "DELETE ALL YOUR LOCAL CONFIG AND PLUGINS";
            const modal = new GeneralModal({
              options: ["Abort clone", confirmOption],
              placeholder: `To avoid conflicts, the local ${app.vault.configDir} directory needs to be deleted.`,
              onlySelection: true
            });
            const shouldDelete = await modal.open() === confirmOption;
            if (shouldDelete) {
              await this.app.vault.adapter.rmdir(
                app.vault.configDir,
                true
              );
            } else {
              new import_obsidian.Notice("Aborted clone");
              return;
            }
          }
        }
        const depth = await new GeneralModal({
          placeholder: "Specify depth of clone. Leave empty for full clone.",
          allowEmpty: true
        }).open();
        let depthInt = void ;
        if (depth !== "") {
          depthInt = parseInt(depth);
          if (isNaN(depthInt)) {
            new import_obsidian.Notice("Invalid depth. Aborting clone.");
            return;
          }
        }
        new import_obsidian.Notice(`Cloning new repo into "${dir}"`);
        const oldBase = this.settings.basePath;
        const customDir = dir && dir !== ".";
        if (customDir) {
          this.settings.basePath = dir;
        }
        try {
          await this.gitManager.clone(url, dir, depthInt);
        } catch (error) {
          this.settings.basePath = oldBase;
          this.saveSettings();
          throw error;
        }
        new import_obsidian.Notice("Cloned new repo.");
        new import_obsidian.Notice("Please restart Obsidian");
        if (customDir) {
          this.saveSettings();
        }
      }
    }
  }
  /
    Retries to call `this.init()` if necessary, otherwise returns directly
    @returns true if `this.gitManager` is ready to be used, false if not.
   /
  async isAllInitialized() {
    if (!this.gitReady) {
      await this.init();
    }
    return this.gitReady;
  }
  ///Used for command
  async pullChangesFromRemote() {
    if (!await this.isAllInitialized())
      return;
    const filesUpdated = await this.pull();
    this.setUpAutoBackup();
    if (!filesUpdated) {
      this.displayMessage("Everything is up-to-date");
    }
    if (this.gitManager instanceof SimpleGit) {
      const status = await this.gitManager.status();
      if (status.conflicted.length > ) {
        this.displayError(
          `You have conflicts in ${status.conflicted.length} ${status.conflicted.length ==  ? "file" : "files"}`
        );
        this.handleConflict(status.conflicted);
      }
    }
    dispatchEvent(new CustomEvent("git-refresh"));
    this.setState( / idle /);
  }
  async createBackup(fromAutoBackup, requestCustomMessage = false, commitMessage) {
    if (!await this.isAllInitialized())
      return;
    if (this.settings.syncMethod == "reset" && this.settings.pullBeforePush) {
      await this.pull();
    }
    if (!await this.commit({
      fromAutoBackup,
      requestCustomMessage,
      commitMessage
    }))
      return;
    if (!this.settings.disablePush) {
      if (await this.gitManager.canPush()) {
        if (this.settings.syncMethod != "reset" && this.settings.pullBeforePush) {
          await this.pull();
        }
        await this.push();
      } else {
        this.displayMessage("No changes to push");
      }
    }
    this.setState( / idle /);
  }
  // Returns true if commit was successfully
  async commit({
    fromAutoBackup,
    requestCustomMessage = false,
    onlyStaged = false,
    commitMessage
  }) {
    if (!await this.isAllInitialized())
      return false;
    const hadConflict = this.localStorage.getConflict() === "true";
    let changedFiles;
    let status;
    let unstagedFiles;
    if (this.gitManager instanceof SimpleGit) {
      this.mayDeleteConflictFile();
      status = await this.updateCachedStatus();
      if (fromAutoBackup && status.conflicted.length > ) {
        this.displayError(
          `Did not commit, because you have conflicts in ${status.conflicted.length} ${status.conflicted.length ==  ? "file" : "files"}. Please resolve them and commit per command.`
        );
        this.handleConflict(status.conflicted);
        return false;
      }
      changedFiles = [...status.changed, ...status.staged];
    } else if (fromAutoBackup && hadConflict) {
      this.setState( / conflicted /);
      this.displayError(
        `Did not commit, because you have conflicts. Please resolve them and commit per command.`
      );
      return false;
    } else if (hadConflict) {
      await this.mayDeleteConflictFile();
      status = await this.updateCachedStatus();
      changedFiles = [...status.changed, ...status.staged];
    } else {
      if (onlyStaged) {
        changedFiles = await this.gitManager.getStagedFiles();
      } else {
        unstagedFiles = await this.gitManager.getUnstagedFiles();
        changedFiles = unstagedFiles.map(({ filepath }) => ({
          vault_path: this.gitManager.getVaultPath(filepath)
        }));
      }
    }
    if (await this.hasTooBigFiles(changedFiles)) {
      this.setState( / idle /);
      return false;
    }
    if (changedFiles.length !==  || hadConflict) {
      let cmtMessage = commitMessage != null ? commitMessage : commitMessage = fromAutoBackup ? this.settings.autoCommitMessage : this.settings.commitMessage;
      if (fromAutoBackup && this.settings.customMessageOnAutoBackup || requestCustomMessage) {
        if (!this.settings.disablePopups && fromAutoBackup) {
          new import_obsidian.Notice(
            "Auto backup: Please enter a custom commit message. Leave empty to abort"
          );
        }
        const tempMessage = await new CustomMessageModal(
          this,
          true
        ).open();
        if (tempMessage != void  && tempMessage != "" && tempMessage != "...") {
          cmtMessage = tempMessage;
        } else {
          this.setState( / idle /);
          return false;
        }
      }
      let committedFiles;
      if (onlyStaged) {
        committedFiles = await this.gitManager.commit(cmtMessage);
      } else {
        committedFiles = await this.gitManager.commitAll({
          // A type error occurs here because `this.settings.autoCommitMessage` is possibly undefined.
          // However, since `this.settings.autoCommitMessage` is always set to string in `this.migrateSettings`,
          // `undefined` is never passed here. Therefore, temporarily ignore this error.
          // @ts-ignore
          message: cmtMessage,
          status: status,
          unstagedFiles
        });
      }
      let roughly = false;
      if (committedFiles === void ) {
        roughly = true;
        committedFiles = changedFiles.length;
      }
      this.setUpAutoBackup();
      this.displayMessage(
        `Committed${roughly ? " approx." : ""} ${committedFiles} ${committedFiles ==  ? "file" : "files"}`
      );
    } else {
      this.displayMessage("No changes to commit");
    }
    dispatchEvent(new CustomEvent("git-refresh"));
    this.setState( / idle /);
    return true;
  }
  async hasTooBigFiles(files) {
    const branchInfo = await this.gitManager.branchInfo();
    const remote = branchInfo.tracking ? splitRemoteBranch(branchInfo.tracking)[] : null;
    if (remote) {
      const remoteUrl = await this.gitManager.getRemoteUrl(remote);
      if (remoteUrl == null ? void  : remoteUrl.includes("github.com")) {
        const tooBigFiles = files.filter((f) => {
          const file = this.app.vault.getAbstractFileByPath(
            f.vault_path
          );
          if (file instanceof import_obsidian.TFile) {
            return file.stat.size >= e;
          }
          return false;
        });
        if (tooBigFiles.length > ) {
          this.displayError(
            `Did not commit, because following files are too big: ${tooBigFiles.map(
              (e) => e.vault_path
            )}. Please remove them.`
          );
          return true;
        }
      }
    }
    return false;
  }
  async push() {
    if (!await this.isAllInitialized())
      return false;
    if (!await this.remotesAreSet()) {
      return false;
    }
    const hadConflict = this.localStorage.getConflict() === "true";
    if (this.gitManager instanceof SimpleGit)
      await this.mayDeleteConflictFile();
    let status;
    if (this.gitManager instanceof SimpleGit && (status = await this.updateCachedStatus()).conflicted.length > ) {
      this.displayError(
        `Cannot push. You have conflicts in ${status.conflicted.length} ${status.conflicted.length ==  ? "file" : "files"}`
      );
      this.handleConflict(status.conflicted);
      return false;
    } else if (this.gitManager instanceof IsomorphicGit && hadConflict) {
      this.displayError(`Cannot push. You have conflicts`);
      this.setState( / conflicted /);
      return false;
    }
    {
      console.log("Pushing....");
      const pushedFiles = await this.gitManager.push();
      console.log("Pushed!", pushedFiles);
      if (pushedFiles > ) {
        this.displayMessage(
          `Pushed ${pushedFiles} ${pushedFiles ==  ? "file" : "files"} to remote`
        );
      } else {
        this.displayMessage(`No changes to push`);
      }
      this.offlineMode = false;
      this.setState( / idle /);
      return true;
    }
  }
  /// Used for internals
  /// Returns whether the pull added a commit or not.
  async pull() {
    if (!await this.remotesAreSet()) {
      return false;
    }
    const pulledFiles = await this.gitManager.pull() || [];
    this.offlineMode = false;
    if (pulledFiles.length > ) {
      this.displayMessage(
        `Pulled ${pulledFiles.length} ${pulledFiles.length ==  ? "file" : "files"} from remote`
      );
      this.lastPulledFiles = pulledFiles;
    }
    return pulledFiles.length != ;
  }
  async mayDeleteConflictFile() {
    const file = this.app.vault.getAbstractFileByPath(
      this.conflictOutputFile
    );
    if (file) {
      this.app.workspace.iterateAllLeaves((leaf) => {
        if (leaf.view instanceof import_obsidian.MarkdownView && leaf.view.file.path == file.path) {
          leaf.detach();
        }
      });
      await this.app.vault.delete(file);
    }
  }
  async stageFile(file) {
    if (!await this.isAllInitialized())
      return false;
    await this.gitManager.stage(file.path, true);
    this.displayMessage(`Staged ${file.path}`);
    dispatchEvent(new CustomEvent("git-refresh"));
    this.setState( / idle /);
    return true;
  }
  async unstageFile(file) {
    if (!await this.isAllInitialized())
      return false;
    await this.gitManager.unstage(file.path, true);
    this.displayMessage(`Unstaged ${file.path}`);
    dispatchEvent(new CustomEvent("git-refresh"));
    this.setState( / idle /);
    return true;
  }
  async switchBranch() {
    var _a;
    if (!await this.isAllInitialized())
      return;
    const branchInfo = await this.gitManager.branchInfo();
    const selectedBranch = await new BranchModal(
      branchInfo.branches
    ).open();
    if (selectedBranch != void ) {
      await this.gitManager.checkout(selectedBranch);
      this.displayMessage(`Switched to ${selectedBranch}`);
      (_a = this.branchBar) == null ? void  : _a.display();
      return selectedBranch;
    }
  }
  async switchRemoteBranch() {
    var _a;
    if (!await this.isAllInitialized())
      return;
    const selectedBranch = await this.selectRemoteBranch() || "";
    const [remote, branch] = splitRemoteBranch(selectedBranch);
    if (branch != void  && remote != void ) {
      await this.gitManager.checkout(branch, remote);
      this.displayMessage(`Switched to ${selectedBranch}`);
      (_a = this.branchBar) == null ? void  : _a.display();
      return selectedBranch;
    }
  }
  async createBranch() {
    var _a;
    if (!await this.isAllInitialized())
      return;
    const newBranch = await new GeneralModal({
      placeholder: "Create new branch"
    }).open();
    if (newBranch != void ) {
      await this.gitManager.createBranch(newBranch);
      this.displayMessage(`Created new branch ${newBranch}`);
      (_a = this.branchBar) == null ? void  : _a.display();
      return newBranch;
    }
  }
  async deleteBranch() {
    var _a;
    if (!await this.isAllInitialized())
      return;
    const branchInfo = await this.gitManager.branchInfo();
    if (branchInfo.current)
      branchInfo.branches.remove(branchInfo.current);
    const branch = await new GeneralModal({
      options: branchInfo.branches,
      placeholder: "Delete branch",
      onlySelection: true
    }).open();
    if (branch != void ) {
      let force = false;
      const merged = await this.gitManager.branchIsMerged(branch);
      if (!merged) {
        const forceAnswer = await new GeneralModal({
          options: ["YES", "NO"],
          placeholder: "This branch isn't merged into HEAD. Force delete?",
          onlySelection: true
        }).open();
        if (forceAnswer !== "YES") {
          return;
        }
        force = forceAnswer === "YES";
      }
      await this.gitManager.deleteBranch(branch, force);
      this.displayMessage(`Deleted branch ${branch}`);
      (_a = this.branchBar) == null ? void  : _a.display();
      return branch;
    }
  }
  async remotesAreSet() {
    if (!(await this.gitManager.branchInfo()).tracking) {
      new import_obsidian.Notice("No upstream branch is set. Please select one.");
      const remoteBranch = await this.selectRemoteBranch();
      if (remoteBranch == void ) {
        this.displayError("Aborted. No upstream-branch is set!", e);
        this.setState( / idle /);
        return false;
      } else {
        await this.gitManager.updateUpstreamBranch(remoteBranch);
        return true;
      }
    }
    return true;
  }
  async setUpAutoBackup() {
    if (this.settings.setLastSaveToLastCommit) {
      this.clearAutoBackup();
      const lastCommitDate = await this.gitManager.getLastCommitTime();
      if (lastCommitDate) {
        this.localStorage.setLastAutoBackup(lastCommitDate.toString());
      }
    }
    if (!this.timeoutIDBackup && !this.onFileModifyEventRef) {
      const lastAutos = await this.loadLastAuto();
      if (this.settings.autoSaveInterval > ) {
        const now = / @__PURE__ / new Date();
        const diff = this.settings.autoSaveInterval - Math.round(
          (now.getTime() - lastAutos.backup.getTime()) / e / 
        );
        this.startAutoBackup(diff <=  ?  : diff);
      }
    }
  }
  async setUpAutos() {
    this.setUpAutoBackup();
    const lastAutos = await this.loadLastAuto();
    if (this.settings.differentIntervalCommitAndPush && this.settings.autoPushInterval > ) {
      const now = / @__PURE__ / new Date();
      const diff = this.settings.autoPushInterval - Math.round(
        (now.getTime() - lastAutos.push.getTime()) / e / 
      );
      this.startAutoPush(diff <=  ?  : diff);
    }
    if (this.settings.autoPullInterval > ) {
      const now = / @__PURE__ / new Date();
      const diff = this.settings.autoPullInterval - Math.round(
        (now.getTime() - lastAutos.pull.getTime()) / e / 
      );
      this.startAutoPull(diff <=  ?  : diff);
    }
  }
  async discardAll() {
    await this.gitManager.discardAll({
      status: this.cachedStatus
    });
    new import_obsidian.Notice(
      "All local changes have been discarded. New files remain untouched."
    );
  }
  clearAutos() {
    this.clearAutoBackup();
    this.clearAutoPush();
    this.clearAutoPull();
  }
  startAutoBackup(minutes) {
    let time = (minutes != null ? minutes : this.settings.autoSaveInterval)  e;
    if (this.settings.autoBackupAfterFileChange) {
      if (minutes === ) {
        this.doAutoBackup();
      } else {
        this.onFileModifyEventRef = this.app.vault.on(
          "modify",
          () => this.autoBackupDebouncer()
        );
        this.autoBackupDebouncer = (, import_obsidian.debounce)(
          () => this.doAutoBackup(),
          time,
          true
        );
      }
    } else {
      if (time > )
        time = ;
      this.timeoutIDBackup = window.setTimeout(
        () => this.doAutoBackup(),
        time
      );
    }
  }
  // This is used for both auto backup and commit
  doAutoBackup() {
    this.promiseQueue.addTask(() => {
      if (this.settings.differentIntervalCommitAndPush) {
        return this.commit({ fromAutoBackup: true });
      } else {
        return this.createBackup(true);
      }
    });
    this.saveLastAuto(/ @__PURE__ / new Date(), "backup");
    this.saveSettings();
    this.startAutoBackup();
  }
  startAutoPull(minutes) {
    let time = (minutes != null ? minutes : this.settings.autoPullInterval)  e;
    if (time > )
      time = ;
    this.timeoutIDPull = window.setTimeout(() => {
      this.promiseQueue.addTask(() => this.pullChangesFromRemote());
      this.saveLastAuto(/ @__PURE__ / new Date(), "pull");
      this.saveSettings();
      this.startAutoPull();
    }, time);
  }
  startAutoPush(minutes) {
    let time = (minutes != null ? minutes : this.settings.autoPushInterval)  e;
    if (time > )
      time = ;
    this.timeoutIDPush = window.setTimeout(() => {
      this.promiseQueue.addTask(() => this.push());
      this.saveLastAuto(/ @__PURE__ / new Date(), "push");
      this.saveSettings();
      this.startAutoPush();
    }, time);
  }
  clearAutoBackup() {
    var _a;
    let wasActive = false;
    if (this.timeoutIDBackup) {
      window.clearTimeout(this.timeoutIDBackup);
      this.timeoutIDBackup = void ;
      wasActive = true;
    }
    if (this.onFileModifyEventRef) {
      (_a = this.autoBackupDebouncer) == null ? void  : _a.cancel();
      this.app.vault.offref(this.onFileModifyEventRef);
      this.onFileModifyEventRef = void ;
      wasActive = true;
    }
    return wasActive;
  }
  clearAutoPull() {
    if (this.timeoutIDPull) {
      window.clearTimeout(this.timeoutIDPull);
      this.timeoutIDPull = void ;
      return true;
    }
    return false;
  }
  clearAutoPush() {
    if (this.timeoutIDPush) {
      window.clearTimeout(this.timeoutIDPush);
      this.timeoutIDPush = void ;
      return true;
    }
    return false;
  }
  async handleConflict(conflicted) {
    this.setState( / conflicted /);
    this.localStorage.setConflict("true");
    let lines;
    if (conflicted !== void ) {
      lines = [
        " Conflicts",
        "Please resolve them and commit them using the commands `Obsidian Git: Commit all changes` followed by `Obsidian Git: Push`",
        "(This file will automatically be deleted before commit)",
        "[[Additional Instructions]] available below file list",
        "",
        ...conflicted.map((e) => {
          const file = this.app.vault.getAbstractFileByPath(e);
          if (file instanceof import_obsidian.TFile) {
            const link = this.app.metadataCache.fileToLinktext(
              file,
              "/"
            );
            return `- [[${link}]]`;
          } else {
            return `- Not a file: ${e}`;
          }
        }),
        `
 Additional Instructions
I strongly recommend to use "Source mode" for viewing the conflicted files. For simple conflicts, in each file listed above replace every occurrence of the following text blocks with the desired text.

\`\`\`diff
<<<<<<< HEAD
    File changes in local repository
=======
    File changes in remote repository
>>>>>>> origin/main
\`\`\``
      ];
    }
    this.writeAndOpenFile(lines == null ? void  : lines.join("\n"));
  }
  async editRemotes() {
    if (!await this.isAllInitialized())
      return;
    const remotes = await this.gitManager.getRemotes();
    const nameModal = new GeneralModal({
      options: remotes,
      placeholder: "Select or create a new remote by typing its name and selecting it"
    });
    const remoteName = await nameModal.open();
    if (remoteName) {
      const oldUrl = await this.gitManager.getRemoteUrl(remoteName);
      const urlModal = new GeneralModal({ initialValue: oldUrl });
      const remoteURL = await urlModal.open();
      if (remoteURL) {
        await this.gitManager.setRemote(remoteName, remoteURL);
        return remoteName;
      }
    }
  }
  async selectRemoteBranch() {
    let remotes = await this.gitManager.getRemotes();
    let selectedRemote;
    if (remotes.length === ) {
      selectedRemote = await this.editRemotes();
      if (selectedRemote == void ) {
        remotes = await this.gitManager.getRemotes();
      }
    }
    const nameModal = new GeneralModal({
      options: remotes,
      placeholder: "Select or create a new remote by typing its name and selecting it"
    });
    const remoteName = selectedRemote != null ? selectedRemote : await nameModal.open();
    if (remoteName) {
      this.displayMessage("Fetching remote branches");
      await this.gitManager.fetch(remoteName);
      const branches = await this.gitManager.getRemoteBranches(
        remoteName
      );
      const branchModal = new GeneralModal({
        options: branches,
        placeholder: "Select or create a new remote branch by typing its name and selecting it"
      });
      return await branchModal.open();
    }
  }
  async removeRemote() {
    if (!await this.isAllInitialized())
      return;
    const remotes = await this.gitManager.getRemotes();
    const nameModal = new GeneralModal({
      options: remotes,
      placeholder: "Select a remote"
    });
    const remoteName = await nameModal.open();
    if (remoteName) {
      this.gitManager.removeRemote(remoteName);
    }
  }
  async writeAndOpenFile(text) {
    if (text !== void ) {
      await this.app.vault.adapter.write(this.conflictOutputFile, text);
    }
    let fileIsAlreadyOpened = false;
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.getDisplayText() != "" && this.conflictOutputFile.startsWith(leaf.getDisplayText())) {
        fileIsAlreadyOpened = true;
      }
    });
    if (!fileIsAlreadyOpened) {
      this.app.workspace.openLinkText(this.conflictOutputFile, "/", true);
    }
  }
  // region: displaying / formatting messages
  displayMessage(message, timeout =   e) {
    var _a;
    (_a = this.statusBar) == null ? void  : _a.displayMessage(message.toLowerCase(), timeout);
    if (!this.settings.disablePopups) {
      new import_obsidian.Notice(message,   e);
    }
    console.log(`git obsidian message: ${message}`);
  }
  displayError(message, timeout =   e) {
    var _a;
    if (message instanceof Errors.UserCanceledError) {
      new import_obsidian.Notice("Aborted");
      return;
    }
    message = message.toString();
    new import_obsidian.Notice(message, timeout);
    console.log(`git obsidian error: ${message}`);
    (_a = this.statusBar) == null ? void  : _a.displayMessage(message.toLowerCase(), timeout);
  }
};
/! Bundled license information:

ieee/index.js:
  (! ieee. BSD--Clause License. Feross Aboukhadijeh <https://feross.org/opensource> )

buffer/index.js:
  (!
    The buffer module from node.js, for the browser.
   
    @author   Feross Aboukhadijeh <https://feross.org>
    @license  MIT
   )

safe-buffer/index.js:
  (! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> )

crc-/crc.js:
  (! crc.js (C) -present SheetJS -- http://sheetjs.com )

feather-icons/dist/feather.js:
  (!
    Copyright (c)  Jed Watson.
    Licensed under the MIT License (MIT), see
    http://jedwatson.github.io/classnames
  )
/
